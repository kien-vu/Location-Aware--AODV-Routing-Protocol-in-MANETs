diff -u -r --new-file ./common/agent.h ../../ns-2.33-hls_working/ns-2.33/common/agent.h
--- ./common/agent.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/common/agent.h	2006-04-05 15:14:18.000000000 +0200
@@ -54,6 +54,10 @@
  * Note that timers are now implemented using timer-handler.{cc,h}
  */
 
+// ->
+#define TRACE_CONN(p,me,src,dst)
+// insterted - to
+
 #define TRACEVAR_MAXVALUELENGTH 128
 
 class Application;
@@ -103,6 +107,15 @@
 	void set_pkttype(packet_t pkttype) { type_ = pkttype; }
 	inline packet_t get_pkttype() { return type_; }
 
+// ->
+        virtual void notifyPos(nsaddr_t) { return; }
+        virtual int hdr_size(Packet*) { return 0; }
+        friend class LocationService;
+	friend class ReaLocService;
+	friend class GridLocService;
+	friend class HLS;
+// insterted - to
+
  protected:
 	int command(int argc, const char*const* argv);
 	virtual void delay_bind_init_all();
diff -u -r --new-file ./common/ip.h ../../ns-2.33-hls_working/ns-2.33/common/ip.h
--- ./common/ip.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/common/ip.h	2006-04-05 15:14:18.000000000 +0200
@@ -64,7 +64,14 @@
 	/* Monarch extn */
 // 	u_int16_t	sport_;
 // 	u_int16_t	dport_;
-	
+
+	// ->
+        double          dx_, dy_, dz_;
+        double& dx() { return dx_; }
+        double& dy() { return dy_; }
+        double& dz() { return dz_; }
+        // inserted - to
+
 	/* IPv6 */
 	int		fid_;	/* flow id */
 	int		prio_;
diff -u -r --new-file ./common/mobilenode.h ../../ns-2.33-hls_working/ns-2.33/common/mobilenode.h
--- ./common/mobilenode.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/common/mobilenode.h	2006-04-05 15:14:18.000000000 +0200
@@ -162,7 +162,14 @@
 	/* For list-keeper */
 	MobileNode* nextX_;
 	MobileNode* prevX_;
-	
+
+// ->
+	/*
+	 * The topography over which the mobile node moves.
+	 */
+	Topography *T_;
+// inserted - public - to
+
 protected:
 	/*
 	 * Last time the position of this node was updated.
@@ -225,10 +232,6 @@
 
 
 	/*
-	 * The topography over which the mobile node moves.
-	 */
-	Topography *T_;
-	/*
 	 * Trace Target
 	 */
 	Trace* log_target_;
diff -u -r --new-file ./common/packet.h ../../ns-2.33-hls_working/ns-2.33/common/packet.h
--- ./common/packet.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/common/packet.h	2006-04-05 15:14:18.000000000 +0200
@@ -70,6 +70,13 @@
 //#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
 #define HDR_LMS(p)		(hdr_lms::access(p))
 
+// ->
+#define HDR_LOCS(p)	(hdr_locs::access(p))
+
+// GPSR
+#define HDR_GPSR(p)     (hdr_gpsr::access(p))
+// inserted - to
+
 /* --------------------------------------------------------------------*/
 
 /*
@@ -180,7 +187,12 @@
 static const packet_t PT_BLTRACE = 60;
 
         // insert new packet types here
-static packet_t       PT_NTYPE = 61; // This MUST be the LAST one
+// ->
+static const packet_t PT_LOCS = 61;
+static const packet_t PT_GPSR = 62; // GPSR
+static const packet_t PT_HLS = 63; // HLS - wk
+static packet_t       PT_NTYPE = 64; // This MUST be the LAST one
+// insterted - to
 
 enum packetClass
 {
@@ -376,6 +388,16 @@
 
 		// Bell Labs (PackMime OL)
 		name_[PT_BLTRACE]="BellLabsTrace";
+
+// ->
+		name_[PT_LOCS]="LOCS";
+
+		// HLS - wk
+		name_[PT_HLS]= "HLS";
+
+		// GPSR
+		name_[PT_GPSR]= "GPSR";
+// insterted - to
 		
 		name_[PT_NTYPE]= "undefined";
 	}
diff -u -r --new-file ./gpsr/gpsr.cc ../../ns-2.33-hls_working/ns-2.33/gpsr/gpsr.cc
--- ./gpsr/gpsr.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/gpsr/gpsr.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,2591 @@
+/* -*-	Mode:C++; c-basic-offset:4; tab-width:4; indent-tabs-mode:t -*- */
+/*
+  
+  Copyright (C) 2000 President and Fellows of Harvard College
+
+  All rights reserved.
+
+  NOTICE: This software is provided "as is", without any warranty,
+  including any implied warranty for merchantability or fitness for a
+  particular purpose.  Under no circumstances shall Harvard University
+  or its faculty, staff, students or agents be liable for any use of,
+  misuse of, or inability to use this software, including incidental
+  and consequential damages.
+
+  License is hereby given to use, modify, and redistribute this
+  software, in whole or in part, for any commercial or non-commercial
+  purpose, provided that the user agrees to the terms of this
+  copyright notice, including disclaimer of warranty, and provided
+  that this copyright notice, including disclaimer of warranty, is
+  preserved in the source code and documentation of anything derived
+  from this software.  Any redistributor of this software or anything
+  derived from this software assumes responsibility for ensuring that
+  any parties to whom such a redistribution is made are fully aware of
+  the terms of this license and disclaimer.
+
+  Author: Brad Karp, Harvard University EECS, May, 1999
+
+  $Id: gpsr.cc,v 1.92 2003/01/24 11:01:07 lochert Exp $
+*/
+
+// GPSR for ns2 w/wireless extensions
+
+#include <math.h>
+#include <stdlib.h>
+#include <string>
+#include <assert.h>
+#include <stdarg.h>
+
+#include "cmu-trace.h"
+#include "random.h"
+#include "mobilenode.h"
+#include "gpsr.h"
+
+// Location Services
+#include "../locservices/hdr_locs.h"
+#include "../locservices/omnilocservice.h"
+#include "../locservices/realocservice.h"
+#include "../locservices/gridlocservice.h"
+#include "../hls/hls.h"
+
+
+#include "god.h"
+
+// Formerly defined global in this file
+#include "geo_util.h"
+
+#define KARP_PERI               // Karp's Perimeter mode in his PhD paper
+#ifndef PING_TTL
+#define PING_TTL 128 /* 10240; Why must this be 10240 ? Interferes evaluation */
+#endif
+
+#define MAX_COORD 10
+
+#define BEACON_RESCHED                                                     \
+           beacon_timer_->resched(bint_ + Random::uniform(2*bdesync_* bint_) - \
+			          bdesync_ * bint_)
+
+
+/** Cmp-Operator for binsearch */
+static int NeighbEntCmp(const void *a, const void *b)
+{
+	nsaddr_t ia = ((const NeighbEnt *) a)->dst;
+	nsaddr_t ib = (*(const NeighbEnt **) b)->dst;
+	if (ia > ib) return 1;
+	if (ib > ia) return -1;
+	return 0;
+}
+
+static int coordcmp(const void *c, const void *d){
+	nsaddr_t ic = *(const nsaddr_t *) c;
+	nsaddr_t id = *(const nsaddr_t *) d;
+	if (ic > id) return 1;
+	if (id > ic) return -1;
+	return 0;
+}
+
+NeighbTable::NeighbTable(GPSR_Agent *mya)
+{
+	int i;
+
+	counter_clock = true;
+
+	nents = 0;
+	maxents = 100;
+	tab = new NeighbEnt *[100];
+	a = mya;
+	for (i = 0; i < 100; i++)
+		tab[i] = new NeighbEnt(a);
+  
+	val_item = new DHeapEntry[God::instance()->nodes()];
+	valid = new DHeap(God::instance()->nodes());
+}
+
+NeighbTable::~NeighbTable()
+{
+	int i;
+
+	// cancel timers
+	for (i = 0; i < nents; i++) {
+		tab[i]->dnt.force_cancel();
+		tab[i]->ppt.force_cancel();
+		delete tab[i];
+	}
+	delete[] tab;
+}
+
+NeighbTableIter NeighbTable::InitLoop() {
+	return (NeighbTableIter) 0;
+}
+
+NeighbEnt *
+NeighbTable::NextLoop(NeighbTableIter *it) {
+	if (((unsigned int) *it) >= (unsigned int) nents)
+		return 0;
+
+	return tab[(*it)++];
+}
+
+NeighbEnt *
+NeighbTable::ent_findshortest(MobileNode *mn, double x, double y, double z)
+{
+	NeighbEnt *ne = 0;
+	double shortest, t, myx, myy, myz;
+	int i;
+
+	mn->getLoc(&myx, &myy, &myz);
+	// warning, this might be false
+	shortest = distance(myx, myy, myz, x, y, z);
+	for (i = 0; i < nents; i++){
+		if ((t = distance(tab[i]->x, tab[i]->y, tab[i]->z, x, y, z)) < shortest) {
+			shortest = t;
+			ne = tab[i];
+		}
+	}
+	return ne;
+}
+
+NeighbEnt *
+NeighbTable::ent_findshortest_cc(MobileNode *mn, double x, double y, double z, double alpha)
+{
+	NeighbEnt *ne = 0;
+	double dist, t, myx, myy, myz, new_dist, best = 1;
+	int i;
+
+	mn->getLoc(&myx, &myy, &myz);
+	dist = distance(myx, myy, myz, x, y, z);
+
+	for (i = 0; i < nents; i++) {
+		new_dist = distance(tab[i]->x, tab[i]->y, tab[i]->z, x, y, z);
+
+		if (new_dist < dist &&
+			(t = alpha * tab[i]->load / 100 + (1 - alpha) * (new_dist / dist)) < best) {
+			best = t;
+			ne = tab[i];
+		}
+	}
+
+	return ne;
+}
+
+NeighbEnt *
+NeighbTable::ent_findshortestXcptLH(MobileNode *mn, 
+									nsaddr_t lastHopId,
+									double x, double y, double z)
+{
+	NeighbEnt *ne = 0;
+	double shortest, t, myx, myy, myz;
+	int i;
+
+	mn->getLoc(&myx, &myy, &myz);
+	shortest = distance(myx, myy, myz, x, y, z);
+	for (i = 0; i < nents; i++)
+		if (((t = distance(tab[i]->x, tab[i]->y, tab[i]->z, x, y, z)) 
+			 < shortest) && 
+			(tab[i]->dst != lastHopId)) {
+			shortest = t;
+			ne = tab[i];
+		}
+	return ne;
+}
+
+NeighbEnt * 
+NeighbTable::ent_findnext_onperi(MobileNode *mn, int node, double dx, double dy, double dz, int plan){
+	double myx, myy, myz;
+	double brg, brg_tmp, brg_tmp2, minbrg = 3*M_PI;
+
+#ifndef KARP_PERI
+	if(counter_clock )
+		minbrg = -3*M_PI;
+#endif
+	double mindist = 0.0;
+
+	NeighbEnt *ne, *minne = NULL;
+
+	mn->getLoc(&myx, &myy, &myz);
+	brg = bearing(myx, myy, dx, dy);
+
+#ifdef KARP_PERI
+	brg = norm(atan2(myy-dy, myx-dx));
+#endif
+
+	int counter = 0;
+	NeighbTableIter niloo = InitLoop();
+	while((bool)(ne = NextLoop(&niloo))){
+#ifdef KARP_PERI
+		if(ne->dst == node){
+			ne->x = dx; ne->y = dy; ne->z = dz;
+		}
+		//continue;
+		counter++;
+		if(counter>100) {
+			printf("nents %d in node %d\n", nents, mn->address());
+			for(int i=0;i<nents;i++)
+				{
+					printf("nr %d dst %d\n", i, tab[i]->dst);
+				}
+			exit(-1);
+		}
+		struct DHeapEntry tmp;
+		tmp.id = ne->dst; tmp.cost = 0; tmp.pred = NULL;
+		itedge = valid->find(&tmp);
+		if(plan && itedge == 0)
+			continue;
+		
+		brg_tmp2 = norm(atan2(myy-ne->y, myx-ne->x));
+		brg_tmp = norm(brg_tmp2 - brg);
+		if(brg_tmp < 0)
+			exit(1);
+		if (brg_tmp < minbrg) {
+			mindist = distance(myx, myy, myz, ne->x, ne->y, ne->z);
+			minbrg = brg_tmp;
+			minne = ne;
+		}else{
+			if(brg_tmp == minbrg){
+				if(distance(myx, myy, myz, ne->x, ne->y, ne->z) < mindist){
+					mindist = distance(myx, myy, myz, ne->x, ne->y, ne->z);
+					minne = ne;
+				}
+			}
+		}
+#else //karp_peri
+		if(distance(myx, myy, myz, ne->x, ne->y, ne->z) > God::instance()->getRadioRange())
+			continue;    
+    
+		if(ne->dst == node){
+			minne = ne;
+			break;      
+		}
+
+		brg_tmp2 = bearing(myx, myy, ne->x, ne->y);
+		brg_tmp = brg_tmp2 - brg;
+		if(counter_clock){
+			while(brg_tmp > 0)
+				brg_tmp -= 2*M_PI;
+
+			if (brg_tmp > minbrg) {
+				mindist = distance(myx, myy, myz, ne->x, ne->y, ne->z);
+				minbrg = brg_tmp;
+				minne = ne;
+			}
+		}else{
+			while(brg_tmp < 0)
+				brg_tmp += 2*M_PI;
+
+			if (brg_tmp < minbrg) {
+				mindist = distance(myx, myy, myz, ne->x, ne->y, ne->z);
+				minbrg = brg_tmp;
+				minne = ne;
+			}
+		}      
+#endif //karp_peri
+	} //end while((bool)
+
+	if(minne)
+		minne->perilen++;
+	return minne;
+}
+
+NeighbEnt * 
+NeighbTable::ent_findnextcloser_onperi(MobileNode *mn, double dx, double dy, double dz){
+	double myx, myy, myz;
+	double mydist;
+	NeighbEnt *ne, *minne = NULL;
+
+	mn->getLoc(&myx, &myy, &myz);
+	mydist = distance(myx, myy, myz, dx, dy, dz);
+  
+	NeighbTableIter ni = InitLoop();
+	while((bool)(ne = NextLoop(&ni))){
+		if(distance(dx, dy, dz, ne->x, ne->y, ne->z) < mydist){
+			minne = ne;
+			break;
+		}
+	}
+	minne->perilen++;
+	return minne;
+}
+
+NeighbEnt *
+NeighbTable::ent_findcloser_onperi(MobileNode *mn, double x, double y,
+								   double z, int *perihop)
+{
+	double mydist, t, myx, myy, myz;
+	int i, j;
+
+	mn->getLoc(&myx, &myy, &myz);
+	mydist = distance(myx, myy, myz, x, y, z);
+	for (i = 0; i < nents; i++)
+		for (j = 0; j < tab[i]->perilen; j++)
+			if ((t = distance(tab[i]->peri[j].x, tab[i]->peri[j].y,
+							  tab[i]->peri[j].z, x, y, z)) < mydist) {
+				*perihop = j;
+				return tab[i];
+			}
+	return 0;
+}
+
+int
+NeighbEnt::closer_pt(nsaddr_t myip, double myx, double myy, double myz, // me
+						 double ptx, double pty, // perimeter startpoint
+						 nsaddr_t ptipa, nsaddr_t ptipb, // me?, prev?
+						 double dstx, double dsty, // dst
+						 double *closerx, double *closery)
+{
+	if ((min(dst, myip) == min(ptipa, ptipb)) &&
+		(max(dst, myip) == max(ptipa, ptipb)))
+		// this edge is the same edge where (ptx, pty) lies; nope??
+		return 0;
+	if (!live)
+		// this edge is not part of the planarized graph
+		return 0;
+	if (cross_segment(ptx, pty, dstx, dsty, myx, myy, x, y,
+					  closerx, closery)) {
+		if (distance(*closerx, *closery, 0.0, dstx, dsty, 0.0) <
+			distance(ptx, pty, 0.0, dstx, dsty, 0.0)) {
+			// edge has point closer than (ptx, pty)
+			return 1;
+		}
+	}
+	return 0;
+}
+
+NeighbEnt *
+NeighbTable::ent_findcloser_edgept(MobileNode *mn, double ptx, double pty,
+								   nsaddr_t ptipa, nsaddr_t ptipb,
+								   double dstx, double dsty,
+								   double *closerx, double *closery)
+{
+	NeighbTableIter ni;
+	NeighbEnt *minne = NULL, *ne;
+	double myx, myy, myz;
+
+	mn->getLoc(&myx, &myy, &myz);
+	ni = InitLoop();
+	while ((ne = NextLoop(&ni))) {
+		if (ne->closer_pt(mn->address(), myx, myy, myz, ptx, pty, ptipa, ptipb,
+						  dstx, dsty, closerx, closery)) {
+			// found an edge with a point closer than (ptx, pty)
+			minne = ne;
+			ptx = *closerx;
+			pty = *closery;
+			ptipa = mn->address();
+			ptipb = ne->dst;
+		}
+	}
+	return minne;
+}
+
+NeighbEnt *
+NeighbTable::ent_findface(MobileNode *mn, double x, double y, double z, int p)
+{
+	double myx, myy, myz;
+	double brg;
+
+	// find bearing to dst
+	mn->getLoc(&myx, &myy, &myz);
+	brg = bearing(myx, myy, x, y);
+	// find neighbor with greatest bearing <= brg
+	return ent_next_ccw(brg, myx, myy, p);
+}
+
+NeighbEnt *
+NeighbTable::ent_next_ccw(double basebrg, double x, double y, int p,
+						  NeighbEnt *inne /*= 0*/)
+{
+	NeighbEnt *minne = NULL, *ne;
+	NeighbTableIter nil;
+	double brg, minbrg = 3*M_PI;
+
+	nil = InitLoop();
+	while ((ne = NextLoop(&nil))) {
+		if (inne && (ne == inne))
+			continue;
+		if (p && !ne->live)
+			continue;
+		brg = bearing(x, y, ne->x, ne->y) - basebrg;
+		if (brg < 0)
+			brg += 2*M_PI;
+		if (brg < 0)
+			brg += 2*M_PI;
+		if (brg < minbrg) {
+			minbrg = brg;
+			minne = ne;
+		}
+	}
+	return minne;
+}
+
+NeighbEnt *
+NeighbTable::ent_next_ccw(MobileNode *mn, NeighbEnt *inne, int p)
+{
+	double myx, myy, myz;
+	double brg;
+	NeighbEnt *ne;
+
+	// find bearing from mn to (x, y, z)
+	mn->getLoc(&myx, &myy, &myz);
+	brg = bearing(myx, myy, inne->x, inne->y);
+	ne = ent_next_ccw(brg, myx, myy, p, inne);
+	if (!ne)
+		return inne;
+	else
+		return ne;
+}
+
+NeighbEnt *NeighbTable::ent_finddst(nsaddr_t dst)
+{
+	NeighbEnt ne(NULL), **pne;
+
+	ne.dst = dst;
+	pne = ((NeighbEnt **) bsearch(&ne, tab, nents,
+								  sizeof(NeighbEnt *), NeighbEntCmp));
+	if (pne)
+		return *pne;
+	else
+		return NULL;
+}
+
+void
+NeighbTable::ent_delete(const NeighbEnt *ent)
+{
+	NeighbEnt **pne;
+	NeighbEnt *owslot=NULL;
+	int i, j;
+
+	if ((pne = (NeighbEnt **) bsearch(ent, tab, nents,
+									  sizeof(NeighbEnt *), NeighbEntCmp))) {
+		i = pne - tab;
+		// make sure no timers scheduled for this neighbor
+		(*pne)->dnt.force_cancel();
+		(*pne)->ppt.force_cancel();
+		// slide any subsequent table entries backward
+		if (i < (nents - 1))
+			owslot = tab[i];
+		for (j = i; j < nents - 1; j++)
+			tab[j] = tab[j+1];
+		if (i < (nents - 1))
+			tab[nents-1] = owslot;
+		nents--;
+	}
+}
+
+NeighbEnt *
+NeighbTable::ent_add(const NeighbEnt *ent)
+{
+	NeighbEnt **pne;
+	NeighbEnt *owslot = NULL;
+	int i, j, r, l;
+
+	if ((pne = (NeighbEnt **) bsearch(ent, tab, nents,
+									  sizeof(NeighbEnt *), NeighbEntCmp))) {
+		// already in table; overwrite
+		// make sure there is no pending timer
+		i = pne - tab;
+		(*pne)->dnt.force_cancel();
+		/* XXX overwriting table entry shouldn't affect when to probe this
+		   perimeter */
+		// careful not to overwrite timers!
+		(*pne)->dst = ent->dst;
+		(*pne)->x = ent->x;
+		(*pne)->y = ent->y;
+		(*pne)->z = ent->z;
+		(*pne)->load = ent->load;
+
+		return *pne;
+	}
+
+	// may have to grow table
+	if (nents == maxents) {
+		NeighbEnt **tmp = tab;
+		maxents *= 2;
+		tab = new NeighbEnt *[maxents];
+		bcopy(tmp, tab, nents*sizeof(NeighbEnt *));
+		for (i = nents; i < maxents; i++)
+			tab[i] = new NeighbEnt(a);
+		delete[] tmp;
+	}
+
+	// binary search for insertion point
+	if (nents == 0)
+		i = 0;
+	else {
+		l = 0;
+		r = nents - 1;
+		while ((r - l) > 0) {
+			if (ent->dst < tab[l + ((r-l) / 2)]->dst)
+				r = l + ((r - l) / 2) - 1;
+			else
+				l += (r - l) / 2 + 1;
+		}
+		if (r < l)
+			i = r+1;
+		else
+			// r == l
+			if (ent->dst < tab[r]->dst)
+				i = r;
+			else
+				i = r+1;
+	}
+
+	// slide subsequent entries forward
+	if (i <= (nents - 1))
+		owslot = tab[nents];
+	j = nents-1;
+	while (j >= i)
+		tab[j+1] = tab[j--];
+	// slam into table, without overwriting timers
+	if (i <= (nents - 1))
+		tab[i] = owslot;
+	tab[i]->dst = ent->dst;
+	tab[i]->x = ent->x;
+	tab[i]->y = ent->y;
+	tab[i]->z = ent->z;
+	tab[i]->load = ent->load;
+	// invalidate the perimeter that may be cached by this neighbor entry
+	tab[i]->perilen = 0;
+	// XXX gross way to indicate entry is *new* entry, graph needs planarizing
+	tab[i]->live = -1;
+	nents++;
+
+	return tab[i];
+}
+
+int
+NeighbTable::meanLoad() {
+    int i;
+    int sum = 0;
+      
+    for (i = 0; i < nents; i++)
+		sum += tab[i]->load;
+
+    if (nents > 0)
+		return sum / nents;
+    else
+		return 0;
+}
+
+void
+NeighbEnt::planarize(NeighbTable *nt, int algo,
+						  double x, double y, double z) {
+	NeighbEnt *ne;
+	NeighbTableIter niplent;
+	double uvdist, canddist, midx=0.0, midy=0.0;
+
+	uvdist = distance(x, y, z, this->x, this->y, this->z);
+	switch(algo) {
+	case PLANARIZE_RNG:
+		break;
+	case PLANARIZE_GABRIEL:
+		// find midpt of segment me (u) <-> this (v)
+		midx = (x + this->x) / 2.0;
+		midy = (y + this->y) / 2.0;
+		uvdist /= 2.0;
+		break;
+	default:
+		fprintf(stderr, "Unknown graph planarization algorithm %d\n", algo);
+		abort();
+		break;
+	}
+	niplent = nt->InitLoop();
+	while ((ne = nt->NextLoop(&niplent))) {
+		if (ne == this)
+			// w and v identical node--w not a witness
+			continue;
+
+		struct DHeapEntry tmp, *tmp2; 
+		tmp.id = dst; tmp.cost = 0; tmp.pred = NULL;
+
+		switch(algo) {
+		case PLANARIZE_RNG:
+			// find max dist. from me (u) to ne (w) vs. this (v) to ne (w)
+			canddist = max(distance(x, y, z, ne->x, ne->y, ne->z),
+						   distance(this->x, this->y, this->z, ne->x, ne->y, ne->z));
+			// is max < dist from me (u) to this (v)?
+			if (canddist < uvdist) {
+				this->live = 0;
+				nt->itedge = 0;
+
+				nt->itedge = nt->valid->find(&tmp);
+				if(nt->itedge != 0){
+					tmp2 = nt->valid->remove(&tmp);
+					delete tmp2;
+				}
+				return;
+			}
+			break;
+		case PLANARIZE_GABRIEL:
+			// is ne (w) inside circle of radius uvdist?
+			if (distance(midx, midy, 0.0, ne->x, ne->y, 0.0) < uvdist) {
+				this->live = 0;
+				nt->itedge = 0;
+
+				nt->itedge = nt->valid->find(&tmp);
+				if(nt->itedge != 0){
+					tmp2 = nt->valid->remove(&tmp);
+					delete tmp2;
+				}
+				return;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	this->live = 1;
+}
+
+
+void
+NeighbTable::planarize(int algo, int addr, double x, double y, double z)
+{
+	NeighbEnt *ne;
+	NeighbTableIter nipl;
+
+	valid->clean();
+	nipl = InitLoop();
+	struct DHeapEntry *tmp;
+	while((ne = NextLoop(&nipl))){
+		tmp = new struct DHeapEntry;
+		tmp->id = ne->dst; tmp->cost = 0; tmp->pred = NULL;
+		valid->insert(tmp);
+	}
+
+	nipl = InitLoop();
+	while ((ne = NextLoop(&nipl))) {
+		ne->planarize(this, algo, x, y, z);
+	}
+	assert(!valid->empty());
+}
+
+int hdr_gpsr::offset_;
+
+class GPSRHeaderClass : public PacketHeaderClass {
+public: 
+	GPSRHeaderClass() : PacketHeaderClass("PacketHeader/GPSR", sizeof(hdr_gpsr)) {
+		bind_offset(&hdr_gpsr::offset_);
+	}
+} class_gpsrhdr;
+
+static class GPSRClass:public TclClass
+{
+public:
+	GPSRClass():TclClass ("Agent/GPSR")
+	{
+	}
+	TclObject *create (int, const char *const *)
+	{
+		return (new GPSR_Agent ());
+	}
+} class_gpsr;
+
+GPSR_Agent::GPSR_Agent(void) : Agent(PT_GPSR), use_mac_(0),
+							   use_peri_(0), verbose_(1), active_(1), drop_debug_(0), peri_proact_(1),
+							   use_implicit_beacon_(0), use_planar_(0), use_loop_detect_(0),
+							   use_timed_plnrz_(0), use_beacon_(0), use_congestion_control_(0), 
+							   use_reactive_beacon_(0), locservice_type_(0), use_span_(1), 
+							   bint_(GPSR_ALIVE_INT), bdesync_(GPSR_ALIVE_DESYNC),
+							   bexp_(GPSR_ALIVE_EXP), pint_(GPSR_PPROBE_INT), pdesync_(GPSR_PPROBE_DESYNC),
+							   lpexp_(GPSR_PPROBE_EXP), /*ldb_(0),*/ mn_(0), 
+							   ifq_(0), locservice_(0), 
+				
+			   beacon_timer_(0), lastperi_timer_(0), send_buf_timer(this)
+{
+    ntab_ = new NeighbTable(this);
+
+    ifq_ = 0;
+
+    // Init SendBuffer
+    for (int i=0;i<SEND_BUF_SIZE;i++) {
+		send_buf[i].p = NULL;
+		send_buf[i].t = -999.0;
+    }
+
+    // Init SendPermissions
+    for (unsigned int i=0;i<GPSR_PKT_TYPES;i++) {
+		send_allowed[i] = true;
+    }
+
+    bind_time("bint_", &bint_);
+    bind_time("bexp_", &bexp_);
+    bind_time("bdesync_", &bdesync_);
+    bind_time("pint_", &pint_);
+    bind_time("pdesync_", &pdesync_);
+    bind_time("lpexp_", &lpexp_);
+    bind("verbose_", &verbose_);
+    bind("drop_debug_", &drop_debug_);
+    bind("peri_proact_", &peri_proact_);
+    bind("use_mac_", &use_mac_);
+    bind("use_peri_", &use_peri_);
+    bind("use_implicit_beacon_", &use_implicit_beacon_);
+    bind("use_planar_", &use_planar_);
+    bind("use_loop_detect_", &use_loop_detect_);
+    bind("use_timed_plnrz_", &use_timed_plnrz_);
+
+    bind("use_beacon_", &use_beacon_);
+    bind("use_reactive_beacon_", &use_reactive_beacon_);
+    bind("use_congestion_control_", &use_congestion_control_);
+    bind("cc_alpha_", &cc_alpha_);
+
+    bind("locservice_type_", &locservice_type_);
+
+    // Timer
+    if ((use_beacon_)&&(!use_reactive_beacon_)) {
+		beacon_timer_ = new GPSR_BeaconTimer(this);
+    }
+    if (!peri_proact_) { 
+		lastperi_timer_ = new GPSR_LastPeriTimer(this);
+    }
+    if (use_timed_plnrz_) {
+		planar_timer_ = new GPSR_PlanarTimer(this);
+    }
+    pd_timer = new PacketDelayTimer(this,16);
+
+    if (use_reactive_beacon_) {
+		beacon_delay_ = new GPSRBeaconDelayTimer(this);
+		beaconreq_delay_ = new GPSRBeaconReqDelayTimer(this);
+    }
+    
+    // What LocationService to use
+    switch (locservice_type_) { // dynamic
+	case _OMNI_: locservice_ = new OmniLocService(this); break;
+	case _REACTIVE_: locservice_ = new ReaLocService(this); break;
+	case _GRID_: locservice_ = new GridLocService(this); break;
+	case _CELL_: locservice_ = new HLS(this); break;
+	default: locservice_ = new OmniLocService(this); break;
+    }
+}
+
+void
+GPSR_Agent::trace(char *fmt,...)
+{
+    va_list ap;
+
+    if (!tracetarget)
+		return;
+
+    va_start(ap, fmt);
+    vsprintf(tracetarget->pt_->buffer(), fmt, ap);
+    tracetarget->pt_->dump();
+    va_end(ap);
+}
+
+void
+GPSR_Agent::tracepkt(Packet *p, double now, int me, const char *type)
+{
+	char buf[1024];
+
+	struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+	snprintf (buf, 1024, "V%s %.5f _%d_:", type, now, me);
+
+	if (gpsrh->mode_ == GPSRH_BEACON) {
+		snprintf (buf, 1024, "%s (%f,%f,%f)", buf, gpsrh->hops_[0].x,
+				  gpsrh->hops_[0].y, gpsrh->hops_[0].z);
+		if (verbose_)
+			trace("%s", buf);
+	}
+}
+
+// don't drop or modify the packet--it's not a copy!
+void
+GPSR_Agent::tap(const Packet *p)
+{
+    if(!active_){ return; }
+
+    hdr_cmn *hdrc = HDR_CMN(p);
+
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+    
+    /* ignore non-IP packets.
+       ignore beacons; we process those on regular receive.
+       assumes the MAC tap includes all unicast packets bound for us.
+       process those here, and avoid calls to beacon_proc() elsewhere. */
+    if (use_implicit_beacon_ &&
+		(hdrc->addr_type_ == NS_AF_INET) &&
+		(hdrc->next_hop_ != (nsaddr_t) IP_BROADCAST)) {
+		// snoop it as proof of its sender's existence.
+		switch (gpsrh->mode_) {
+	    case GPSRH_DATA_GREEDY:
+			// prev hop position lives in hops_[0]
+			beacon_proc(gpsrh->hops_[0].ip, gpsrh->hops_[0].x, gpsrh->hops_[0].y,
+						gpsrh->hops_[0].z, gpsrh->load);
+			break;
+	    case GPSRH_PPROBE:
+			// prev hop position lives in hops_[nhops_-1]
+			beacon_proc(gpsrh->hops_[gpsrh->nhops_-1].ip,
+						gpsrh->hops_[gpsrh->nhops_-1].x,
+						gpsrh->hops_[gpsrh->nhops_-1].y,
+						gpsrh->hops_[gpsrh->nhops_-1].z,
+						gpsrh->load);
+			break;
+	    case GPSRH_DATA_PERI:
+			// XXX was hops_[gpsrh->currhop_-1]
+			// prev hop position lives in hops_[0]
+			beacon_proc(gpsrh->hops_[0].ip,
+						gpsrh->hops_[0].x,
+						gpsrh->hops_[0].y,
+						gpsrh->hops_[0].z,
+						gpsrh->load);
+			break;
+	    default:
+			fprintf(stderr, "Yow! tap got packet of unk type %d!\n", gpsrh->mode_);
+			abort();
+			break;
+		}
+    }
+
+    // Reactive Beaconing needs to take a look at pkts
+    if (use_reactive_beacon_) {
+		checkGreedyCondition(p);
+    }
+
+    /*
+      LocService Tap for Evaluation
+    */
+
+    if (locservice_type_ == _GRID_) {
+		locservice_->evaluatePacket(p);
+    }
+    
+    if (locservice_type_ == _REACTIVE_) {
+		// Use LocSRequest Packets for implicit beaconing
+		// ReaLocService Requests are Broadcast Pakets, thus needing
+		//  extra handling. Unicast Pakets are covered by GPSR
+		struct hdr_locs *locsh = HDR_LOCS(p);
+		if (use_implicit_beacon_ && locsh->valid_ && (locsh->type_ == LOCS_REQUEST)) {
+			beacon_proc(locsh->lasthop.id,
+						locsh->lasthop.loc.x,
+						locsh->lasthop.loc.y,
+						locsh->lasthop.loc.z);
+		}
+	
+		// Let LocService take a look at pkts passing by
+		locservice_->evaluatePacket(p);
+    } 
+
+	if (locservice_type_ == _CELL_) {
+		locservice_->evaluatePacket(p);
+	}
+    
+#if GPSR_ROUTE_VERBOSE >= 1
+    // Each DATA arrival has to trigger a connectivity
+    // trace for evaluation
+	struct hdr_ip *iph = HDR_IP(p);
+	bool arrival = ( ((gpsrh->mode_ == GPSRH_DATA_GREEDY) ||
+					  (gpsrh->mode_ == GPSRH_DATA_PERI)) &&
+					 (gpsrh->port_ == hdr_gpsr::GPSR) &&
+					 (iph->daddr() == addr()) );
+    if (arrival) {
+      int analysis = God::instance()->path_analysis_;
+      God::instance()->path_analysis_ = 1;
+
+      int shortest = God::instance()->shortestPathLength(addr(),iph->saddr());
+      if (shortest == UNREACHABLE) { shortest = 0; } 
+	  int taken = 128 - iph->ttl() + 1;
+#ifdef PING_TTL
+	  taken = PING_TTL - iph->ttl() + 1;
+#endif
+	  trace("RTE: %.12f _%d_: RouteInfo %d (%d->%d) : %d %d",
+			Scheduler::instance().clock(),addr(),
+			HDR_CMN(p)->uid(), iph->saddr(), iph->daddr(), 
+			taken, shortest);
+	  
+      God::instance()->path_analysis_ = analysis;
+    }
+#endif    
+
+}
+
+void
+GPSR_Agent::lost_link(Packet *p)
+{
+    // Give Locservice the chance to evaluate callbacks
+    locservice_->callback(p);
+    if (p==NULL) { return; }
+
+    struct hdr_cmn *hdrc = HDR_CMN(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+    NeighbEnt *ne;
+    
+    if (use_mac_ == 0) {
+		drop(p, DROP_RTR_MAC_CALLBACK);
+		return;
+    }
+
+    trace ("VLL %.8f _%d_ %d (%d->%d->%d) [%d]",
+		   Scheduler::instance().clock(),
+		   mn_->address(),
+		   hdrc->uid(),
+		   HDR_IP(p)->saddr(),
+		   hdrc->next_hop(),
+		   HDR_IP(p)->daddr(),
+		   hdrc->xmit_reason_);
+    
+    if (hdrc->addr_type_ == NS_AF_INET) {
+		ne = ntab_->ent_finddst(hdrc->next_hop_);
+		if (verbose_)
+			trace ("VLP %.5f %d:%d->%d:%d lost at %d [hop %d]",
+				   Scheduler::instance().clock(),
+				   HDR_IP(p)->saddr(),
+				   HDR_IP(p)->sport(),
+				   HDR_IP(p)->daddr(),
+				   HDR_IP(p)->dport(),
+				   mn_->address(), 
+				   hdrc->next_hop_);
+      
+		if (ne) {
+			ne->dnt.force_cancel();
+			deadneighb_callback(ne);
+		}
+    }
+    
+    // grab packets in the ifq bound for the same next hop
+    Packet *r, *rh, *rt;
+    rh = rt = p;
+    // rh ist list head, initialize to 0
+    rh->next_ = 0;
+    // How many packets to be rerouted? (at least 1 (p))
+    unsigned int pCount = 1;
+
+#if 0
+    PacketQueue * pq;
+    Packet *pt, *pp;
+    hdr_cmn *ch = HDR_CMN(p);
+    char outBuf[4096];
+    char uid[16];
+    sprintf(outBuf, "VLLQE %.5f _%d_ ->%d [ ", 
+			Scheduler::instance().clock(),
+			mn_->address(),
+			hdrc->next_hop_);
+    if (ifq_ != NULL) {
+      
+		// get encapsulated Queue (OMG, this ist dirty!)
+		pq = ifq_->q();
+
+		for(pt = pq->head(); pt; pt = pt->next_) {
+	
+			ch = HDR_CMN(pt);
+			if (ch->next_hop() == hdrc->next_hop_){
+				sprintf(uid, "%d ", ch->uid());
+				strcat(outBuf, uid);
+			}
+			pp = pt;
+		}
+      
+		strcat(outBuf, "]");
+		if (verbose_)
+			trace(outBuf);
+      
+#endif
+
+		if (ifq_ != NULL) {
+			while ((r = ifq_->filter((nsaddr_t) hdrc->next_hop_))) {
+				rt->next_ = r;
+				r->next_ = 0;
+				rt = r;
+				++pCount;
+			}
+		}
+
+#if 0     
+    }else {
+		// ifq_ invalid;
+		trace ("VLLIV %.5f _%d_", 
+			   Scheduler::instance().clock(),
+			   mn_->address());
+    }
+#endif
+    if (verbose_)
+		trace ("VLLPC %.5f _%d_ %d", 
+			   Scheduler::instance().clock(),
+			   mn_->address(),
+			   pCount);
+
+    // retarget all packets we got to a new next hop
+    while (rh) {
+		rt = rh;
+		rh = rh->next_;
+      
+		hdrc = HDR_CMN(rt);
+
+		if (verbose_) {
+			struct hdr_ip* iphdr = HDR_IP(rt);
+			trace("VLLR: %.8f _%d_ %d (%d->%d->%d) [%d]",
+				  Scheduler::instance().clock(),
+				  mn_->address(),
+				  hdrc->uid(),
+				  iphdr->saddr(),
+				  hdrc->next_hop(),
+				  iphdr->daddr(),
+				  hdrc->xmit_reason_);
+		}
+		gpsrh = HDR_GPSR(rt);
+      
+		if (hdrc->addr_type_ != NS_AF_INET) {
+			drop(rt, DROP_RTR_MAC_CALLBACK);
+			continue;
+		}
+      
+		/*
+		  Unfortunately we have no choice but to handle LocService Packets with
+		  this extra code, because we have to use the Routing Port but don't
+		  want GPSR to handle the (and discard) the Packets
+		*/
+		if (gpsrh->port_ == hdr_gpsr::LOCS) {
+			int tmp = use_planar_;
+			switch (gpsrh->mode_) {
+			case GPSRH_DATA_GREEDY: { forwardPacket(rt); break; }
+			case GPSRH_DATA_PERI:
+				use_planar_ = 1;
+				if (use_planar_) { forwardPacket(rt, 1); }
+				else { drop(rt, DROP_RTR_NEXT_SRCRT_HOP); }
+				use_planar_ = tmp;
+				break;
+			default: 
+				fprintf(stderr, "yow! locs packet bounced by MAC and not handled !\n");
+				abort();
+				break;
+			}
+			continue;
+		}
+
+		// for GPSR perimeter probes, chop off our own perimeter entry before
+		// passing the probe back into the agent for reforwarding
+		if (HDR_IP(rt)->dport() == RT_PORT) {
+			if (gpsrh->mode_ == GPSRH_PPROBE) {
+				if (gpsrh->nhops_ == 1) {
+					/* we originated it. the neighbor is gone, according to the MAC
+					   layer. drop the probe--it was *only* meant for that neighbor. */
+					drop(rt, DROP_RTR_NEXT_SRCRT_HOP);
+					continue;
+				}
+				/* we were forwarding the probe, so instead try to recover by
+				   forwarding it to a remaining appropriate next hop */
+				gpsrh->nhops_--;
+				periIn(rt, gpsrh, GPSR_PPROBE_RTX);
+			}
+		} else {
+			int tmp = use_planar_;
+			switch (gpsrh->mode_) {
+			case GPSRH_DATA_GREEDY:
+				// give the packet another chance--exercise greedy's good recovery
+				forwardPacket(rt);
+				break;
+			case GPSRH_DATA_PERI:
+				use_planar_ = 1;
+				if (use_planar_)
+					// not src-routed; give it another chance via another neighbor
+					forwardPacket(rt, 1);
+				else
+					// punt the packet; its chosen src-routed next hop is gone
+					drop(rt, DROP_RTR_NEXT_SRCRT_HOP);
+				use_planar_ = tmp;
+				break;
+			default:
+				fprintf(stderr,
+						"yow! non-data packet for non-GPSR port bounced by MAC!\n");
+				abort();
+				break;
+			}
+		}
+	  
+    }   
+}
+
+static void
+mac_callback(Packet * p, void *arg)
+{
+	((GPSR_Agent *) arg)->lost_link(p);
+}
+
+void
+GPSR_Agent::planar_callback(void)
+{
+	// re-planarize graph
+	if (use_planar_) {
+		double myx, myy, myz;
+
+		mn_->getLoc(&myx, &myy, &myz);
+		ntab_->planarize(PLANARIZE_GABRIEL, mn_->address(), myx, myy, myz);
+	}
+	// reschedule us
+	// XXX should make interval tunable!!!
+	planar_timer_->resched(1.0);
+}
+
+void
+GPSR_Agent::lastperi_callback(void)
+{
+	NeighbEnt *ne;
+	NeighbTableIter ni;
+
+	// don't probe perimeters proactively anymore
+	peri_proact_ = 0;
+	// cancel all perimeter probe timers
+	ni = ntab_->InitLoop();
+	while ((ne = ntab_->NextLoop(&ni)))
+		ne->ppt.force_cancel();
+}
+
+void
+GPSR_Agent::beacon_callback(void)
+{
+    
+    sendBeacon();
+
+    // schedule the next beacon generation event
+    if ((use_beacon_)&&(!use_reactive_beacon_)) { BEACON_RESCHED; }
+}
+
+void
+GPSR_Agent::deadneighb_callback(NeighbEnt *ne)
+{
+	Scheduler &s = Scheduler::instance();
+	double now = s.clock ();
+
+	if (verbose_)
+		trace ("VTO %.5f _%d_ %d->%d", now, mn_->address(), mn_->address(),
+			   ne->dst);
+	// remove the neighbor entry from the table!
+	ntab_->ent_delete(ne);
+	// need to re-planarize, if option dictates
+	if (use_planar_) {
+		double myx, myy, myz;
+
+		mn_->getLoc(&myx, &myy, &myz);
+		ntab_->planarize(PLANARIZE_GABRIEL, mn_->address(), myx, myy, myz);
+	}
+}
+
+void
+GPSR_Agent::periprobe_callback(NeighbEnt *ne)
+{
+	Packet *p = allocpkt();
+	struct hdr_ip *iph = HDR_IP(p);
+	struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+	struct hdr_cmn *ch = HDR_CMN(p);
+
+	ch->next_hop_ = ne->dst;
+	ch->addr_type_ = NS_AF_INET;
+	iph->daddr() = Address::instance().create_ipaddr(ne->dst, RT_PORT);
+	iph->dport() = RT_PORT;
+	ch->ptype_ = PT_GPSR;
+	iph->ttl() = 128;
+#ifdef PING_TTL
+	iph->ttl() = PING_TTL;
+#endif
+	gpsrh->hops_[0].ip = Address::instance().get_nodeaddr(addr());
+	gpsrh->nhops_ = 1;
+	gpsrh->mode_ = GPSRH_PPROBE;
+	if (use_congestion_control_)
+		gpsrh->load = getLoad();
+	ch->size() = hdr_size(p);
+	mn_->getLoc(&gpsrh->hops_[0].x, &gpsrh->hops_[0].y, &gpsrh->hops_[0].z);
+
+	// schedule probe transmission
+	ch->xmit_failure_ = mac_callback;
+	ch->xmit_failure_data_ = this;
+	Scheduler::instance().schedule(target_, p, 0);
+	if ((use_beacon_)&&(!use_reactive_beacon_)) {
+		BEACON_RESCHED;
+	}
+
+	// schedule next probe timer
+	ne->ppt.resched(pint_ +
+					Random::uniform(2 * pdesync_ * pint_) - pdesync_ * pint_);
+}
+
+inline int
+cross_segment(double x1, double y1, double x2, double y2,
+						 double x3, double y3, double x4, double y4,
+						 double *xi /*= 0*/, double *yi /*= 0*/)
+{
+	double dy[2], dx[2], m[2], b[2];
+	double xint, yint;
+	
+	dy[0] = y2 - y1; // dsty - pty
+	dx[0] = x2 - x1; // dstx - ptx
+	dy[1] = y4 - y3; // ne->y - myy
+	dx[1] = x4 - x3; // ne->x - myx
+	m[0] = dy[0] / dx[0];
+	m[1] = dy[1] / dx[1];
+	b[0] = y1 - m[0] * x1;
+	b[1] = y3 - m[1] * x3;
+	if (m[0] != m[1]) {
+		// slopes not equal, compute intercept
+		xint = (b[0] - b[1]) / (m[1] - m[0]);
+		yint = m[1] * xint + b[1];
+		// is intercept in both line segments?
+		if ((xint <= max(x1, x2)) && (xint >= min(x1, x2)) &&
+			(yint <= max(y1, y2)) && (yint >= min(y1, y2)) &&
+			(xint <= max(x3, x4)) && (xint >= min(x3, x4)) &&
+			(yint <= max(y3, y4)) && (yint >= min(y3, y4))) {
+			if (xi && yi) {
+				*xi = xint;
+				*yi = yint;
+			}
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int
+GPSR_Agent::crosses(NeighbEnt *ne, hdr_gpsr *gpsrh)
+{
+	int i;
+
+	// check all neighboring hops in perimeter thus far (through self)
+	for (i = 0; i < (gpsrh->nhops_ - 1); i++) {
+		if ((gpsrh->hops_[i].ip != ne->dst) &&
+			(gpsrh->hops_[i+1].ip != ne->dst) &&
+			(gpsrh->hops_[i].ip != gpsrh->hops_[gpsrh->nhops_-1].ip) &&
+			(gpsrh->hops_[i+1].ip != gpsrh->hops_[gpsrh->nhops_-1].ip) &&
+			cross_segment(gpsrh->hops_[i].x, gpsrh->hops_[i].y,
+						  gpsrh->hops_[i+1].x, gpsrh->hops_[i+1].y,
+						  gpsrh->hops_[gpsrh->nhops_-1].x,
+						  gpsrh->hops_[gpsrh->nhops_-1].y,
+						  ne->x, ne->y))
+			return 1;
+	}
+	return 0;
+}
+
+void
+GPSR_Agent::periIn(Packet *p, hdr_gpsr *gpsrh, int rtxflag /*= 0*/)
+{
+	double myx, myy, myz;
+	NeighbEnt *ne, *inne;
+
+	// update neighbor record for previous hop
+  
+	// did I originate it?
+	if (gpsrh->hops_[0].ip == Address::instance().get_nodeaddr(addr())) {
+		// cache the perimeter
+		ne = ntab_->ent_finddst(gpsrh->hops_[1].ip);
+		if (!ne) {
+			// apparently, neighbor we launched probe via is now gone
+			Packet::free(p);
+			return;
+		}
+#ifdef HDR_GPSR_DYNAMIC
+		if (ne->peri && (ne->maxlen < gpsrh->maxhops_)) {
+			// need to allocate more PeriEnt slots in ne
+			delete[] ne->peri;
+			ne->maxlen = ne->perilen = 0;
+			ne->peri = NULL;
+		}
+#endif
+		if (!ne->peri) {
+#ifdef HDR_GPSR_DYNAMIC
+			ne->peri = new struct PeriEnt[gpsrh->maxhops_];
+			ne->maxlen = gpsrh->maxhops_;
+#else
+			ne->peri = new struct PeriEnt[MAX_PERI_HOPS_STATIC];
+			ne->maxlen = MAX_PERI_HOPS_STATIC;
+#endif
+		}
+		bcopy(&gpsrh->hops_[1], ne->peri,
+			  (gpsrh->nhops_ - 1) * sizeof(struct PeriEnt));
+		ne->perilen = gpsrh->nhops_ - 1;
+		/* no timer work to do--perimeter probe timer is governed by
+		   beacons/absence of beacons from a neighbor */
+		// we consumed the packet; free it!
+		Packet::free(p);
+		return;
+	}
+	// add self to GPSR header perimeter
+	mn_->getLoc(&myx, &myy, &myz);
+	gpsrh->add_hop(Address::instance().get_nodeaddr(addr()), myx, myy, myz);
+	if (use_congestion_control_)
+		gpsrh->load = getLoad();
+	// compute candidate next hop: sweep ccw about self from ingress hop
+	ne = inne = ntab_->ent_finddst(gpsrh->hops_[gpsrh->nhops_-2].ip);
+	/* in theory, a perimeter probe received from an unknown neighbor should
+	   serve as a beacon from that neighbor... */
+	/* BUT, don't add the previous hop more than once when we retransmit a
+	   peri probe--the prev hop information is stale in that case */
+	if (!rtxflag && (ne == NULL)) {
+		NeighbEnt nne(this);
+
+		nne.dst = gpsrh->hops_[gpsrh->nhops_-2].ip;
+		nne.x = gpsrh->hops_[gpsrh->nhops_-2].x;
+		nne.y = gpsrh->hops_[gpsrh->nhops_-2].y;
+		nne.z = gpsrh->hops_[gpsrh->nhops_-2].z;
+
+		if (use_congestion_control_)
+			nne.load = gpsrh->load;
+		inne = ne = ntab_->ent_add(&nne);
+
+		ne->dnt.sched(bexp_);
+		// no perimeter probe is pending; launch one
+		if (peri_proact_)
+			ne->ppt.sched(pint_ +
+						  Random::uniform(2 * pdesync_ * pint_) - pdesync_ * pint_);
+	}
+	else if (ne == NULL) {
+		/* we're trying to retransmit a peri probe, but the ingress hop is gone.
+		   drop it. */
+		drop(p, DROP_RTR_MAC_CALLBACK);
+		return;
+	}
+#ifndef KARP_PERI
+	while ((ne = ntab_->ent_next_ccw(mn_, ne, use_planar_)) != inne) {
+#else
+		double fromx, fromy, fromz;
+	while((ne = ntab_->ent_findnext_onperi(mn_, gpsrh->hops_[0].ip,
+										   gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z,
+										   use_planar_)) != inne){
+		printf("ne->dst %d\n", ne->dst);
+		
+#endif
+			// verify no crossing
+			if (!crosses(ne, gpsrh))
+				break;			
+	}
+	// forward probe to ne
+
+	struct hdr_cmn *cmh = HDR_CMN(p);
+	struct hdr_ip *iph = HDR_IP(p);
+	cmh->addr_type_ = NS_AF_INET;
+	iph->daddr() = Address::instance().create_ipaddr(ne->dst, RT_PORT);
+	cmh->size() += sizeof(struct PeriEnt);
+	printf("Warning: This Packet Size change has not been modified, yet!\n");
+	cmh->xmit_failure_ = mac_callback;
+	cmh->xmit_failure_data_ = this;
+	cmh->next_hop_ = ne->dst;
+	cmh->direction() = hdr_cmn::DOWN;
+	target_->recv(p, (Handler *)0);
+	if ((use_beacon_)&&(!use_reactive_beacon_)) {
+		BEACON_RESCHED;
+	}
+}
+
+int
+GPSR_Agent::getLoad() {
+	return (2 * ((Mac802_11 *)m)->getLoad() + ntab_->meanLoad()) / 3;
+}
+
+/***************************************************/
+/* Forwarding Packet Function (or is it Monster ?) */
+/***************************************************/
+
+void
+GPSR_Agent::forwardPacket(Packet *p, int rtxflag /*= 0*/) {
+
+	struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_cmn *cmh = HDR_CMN(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+    
+    NeighbEnt *ne=NULL;
+    NeighbEnt *logne;
+    Scheduler &s = Scheduler::instance();
+    double now = s.clock();
+
+    switch(gpsrh->mode_) {
+	case GPSRH_DATA_GREEDY: 
+    
+	    // first of all, look if we're neighbor to dst
+	    if ( (ne = ntab_->ent_finddst(iph->daddr())) != NULL) {
+			cmh->next_hop_ = ne->dst;
+			break;
+	    }
+	    
+	    // try to find the next best neighbor
+	    if (use_congestion_control_)
+			ne = ntab_->ent_findshortest_cc(mn_, iph->dx_, iph->dy_, iph->dz_, cc_alpha_);
+	    else
+			ne = ntab_->ent_findshortest(mn_, iph->dx_, iph->dy_, iph->dz_);
+
+	    if (ne != NULL){
+
+			// warn about possible ping-pong
+ 			// (wk: possibly problematic because if a newly born packet with next hop 0
+			// arrives here, a possible ping-pong will be detected (ne->dst == 0 and ..hops[0]
+			// is initialized with 0)
+			if (ne->dst == gpsrh->hops_[0].ip)			
+					trace("VPPP %f _%d_ %d [%d -> %d]", now, mn_->address(), cmh->uid(), mn_->address(), ne->dst);
+
+			// set next hop to best neighbor
+			cmh->next_hop_ = ne->dst;
+			break;
+
+	    }else{
+			// there seems to be no greedy neighbor
+			// we send a beacon request and delay the pkt the first time
+			// should the new info be of no use, we'll process it further
+			if (use_reactive_beacon_) {
+				if (gpsrh->retry < GPSR_RBEACON_RETRIES) {
+					gpsrh->retry++;
+					sendBeaconRequest();
+					double delay = 2*GPSR_RBEACON_JITTER;
+					pd_timer->add(cmh->uid(), delay, (void*)p);
+					return;
+				}else{
+					pd_timer->remove(cmh->uid()); // precaution
+					gpsrh->retry = 0;
+				}
+			}
+
+			// try perimeter mode
+			if ((use_peri_) && 
+				// no perimeter mode for updates and handovers to avoid excessive traffic
+				!((cmh->ptype() == PT_HLS) && // if NOT(HLS update or HLS handover)
+				  ((HDR_HLS(p)->type_ == HLS_UPDATE)||
+				   (HDR_HLS(p)->type_ == HLS_HANDOVER))))
+			{
+		
+				if (verbose_) {
+					double myx, myy, myz;
+					mn_->getLoc(&myx, &myy, &myz);
+					trace("VEPM %f _%d_ [%d -> %d] [%.2f/%.2f]",
+						  now, mn_->address(), iph->saddr(), iph->daddr(),
+						  myx, myy);
+				}
+
+				if (use_planar_) {
+					// no proactive probes, so no peri_proact_ to worry about
+					ne = ntab_->ent_findnext_onperi(mn_, iph->daddr(), iph->dx_, iph->dy_, iph->dz_, use_planar_);
+					if (!ne) { // no face toward the destination
+						if(gpsrh->geoanycast)
+							{
+								// wk: forwardPacket: no better neigbhor on peri
+								locservice_->dropPacketCallback(p);
+								if (p==NULL) { return; }
+							}
+						
+						TRACE_CONN(p,addr(),addr(),HDR_IP(p)->daddr());
+
+						drop(p, DROP_RTR_NO_ROUTE);
+						return;
+					}
+			  
+					// put packet in peri data mode, forward
+					cmh->size() -= hdr_size(p); // strip data header
+					gpsrh->mode_ = GPSRH_DATA_PERI;
+					cmh->size() += hdr_size(p); // add peri header
+			
+					// mark point of entry into peri data mode
+					mn_->getLoc(&gpsrh->peript_.x, &gpsrh->peript_.y, &gpsrh->peript_.z);
+					gpsrh->perips_.x = gpsrh->peript_.x;
+					gpsrh->perips_.y = gpsrh->peript_.y;
+					gpsrh->perips_.z = gpsrh->peript_.z;
+
+					// mark ips of edge endpoints
+					gpsrh->periptip_[0] = gpsrh->hops_[0].ip;        // prev edge on peri
+					gpsrh->periptip_[1] = mn_->address(); // myself
+					gpsrh->periptip_[2] = ne->dst;        // next edge on peri
+
+					// N.B. first dst hop is hops_[1]
+					// (leave room for hop-by-hop ip, position in hops_[0])!!
+					gpsrh->nhops_ = 1;
+					gpsrh->currhop_ = 1;
+					gpsrh->add_hop(mn_->address(), gpsrh->peript_.x, gpsrh->peript_.y, gpsrh->peript_.z);
+					cmh->next_hop_ = ne->dst;
+					break;
+				}
+
+				if (peri_proact_) {
+
+					// record we had a data packet that needed a perimeter
+					if (lastperi_timer_) { lastperi_timer_->resched(lpexp_); }
+
+					double fromx, fromy, fromz;
+					ne = ntab_->ent_findnext_onperi(mn_,
+													gpsrh->hops_[0].ip, gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z,
+													use_planar_);
+
+					if (!ne) {
+
+						// we're well and truly hung; nothing closer on a peri, either
+						if (drop_debug_ && (cmh->opt_num_forwards_ != 16777215)) {
+							NeighbTableIter ni;
+							ni = ntab_->InitLoop();
+							while ((logne = ntab_->NextLoop(&ni))) {
+								trace("VPER _%d_ (%.5f, %.5f):", logne->dst, logne->x, logne->y);
+								for (int j = 0; j < logne->perilen; j++) {
+									trace("VPER\t\t_%d_ (%.5f, %.5f)",
+										  logne->peri[j].ip, logne->peri[j].x, logne->peri[j].y);
+								}
+							}
+						}
+ 						if(gpsrh->geoanycast)
+							{
+								// wk forwardPacket: we're hung
+								locservice_->dropPacketCallback(p);
+								if (p==NULL) { return; }
+							}
+
+						TRACE_CONN(p,addr(),addr(),HDR_IP(p)->daddr());
+						drop(p, DROP_RTR_NO_ROUTE);
+						return;
+
+					}else{
+			    
+						cmh->size() -= hdr_size(p); // strip data header 
+						gpsrh->mode_ = GPSRH_DATA_PERI; // put packet in peri mode
+						cmh->size() += hdr_size(p); // add peri header
+
+						// N.B. first dst hop is hops_[1]
+						// (leave room for hop-by-hop ip, position in hops_[0])!! 
+						gpsrh->nhops_ = 1;
+						gpsrh->currhop_ = 1;
+						gpsrh->hops_[1].ip = ne->dst;
+						cmh->next_hop_ = gpsrh->hops_[1].ip;
+						trace("VSM->P %f _%d_ [%d -> %d]", now, mn_->address(), iph->saddr(), iph->daddr());
+						break;
+					}
+				} // if(peri_proact)
+			} // if(use_peri)
+			
+			// no closer neighbor ! unforwardable; drop it.
+
+			/* 
+			   someday, we may want to queue up packets for 
+			   currently unforwardable destinations 
+			*/
+		
+			// record we had a data packet that needed a perimeter
+			if (lastperi_timer_) { lastperi_timer_->resched(lpexp_); }
+			// we could have used a perimeter here--turn them on
+			peri_proact_ = 1;
+
+			if(gpsrh->geoanycast)
+				{
+					// wk forwardPacket no closer  neighbor
+					locservice_->dropPacketCallback(p);
+					if (p==NULL) { return; }
+				}
+
+			TRACE_CONN(p,addr(),addr(),HDR_IP(p)->daddr());
+			drop(p, DROP_RTR_NO_ROUTE);
+			return;
+	    }
+	    break;
+	    /********************************************
+	     *end greedy
+	     *******************************************/
+
+	case GPSRH_DATA_PERI:
+
+	    // first of all, look if we're neighbor to dst
+	    if ( (ne = ntab_->ent_finddst(iph->daddr())) != NULL) {
+			cmh->size() -= hdr_size(p); // strip data peri header
+			gpsrh->mode_ = GPSRH_DATA_GREEDY;
+			cmh->size() += hdr_size(p); // strip data greedy header
+			gpsrh->nhops_ = 1;
+			gpsrh->currhop_ = 1;
+			gpsrh->hops_[1].ip = ne->dst;
+			cmh->next_hop_ = ne->dst;
+			break;
+	    }
+
+	    if (use_peri_) {
+	      
+			double myx, myy, myz, closerx, closery;
+		    closerx = gpsrh->perips_.x;
+			closery = gpsrh->perips_.y;
+
+			// non-source-routed perimeter forwarding rule
+			/** to resume greedy forwarding, this *node* must be closer than
+				the point where the packet entered peri mode. */
+			mn_->getLoc(&myx, &myy, &myz);
+			double difference = distance(gpsrh->peript_.x, gpsrh->peript_.y, gpsrh->peript_.z,
+										 iph->dx_, iph->dy_, iph->dz_) - 
+				distance(myx, myy, myz, iph->dx_, iph->dy_, iph->dz_);
+
+			if ((distance(myx, myy, myz, iph->dx_, iph->dy_, iph->dz_) <
+				distance(gpsrh->peript_.x, gpsrh->peript_.y, gpsrh->peript_.z,
+						 iph->dx_, iph->dy_, iph->dz_)) && difference > 0.5) 
+				{
+				cmh->size() -= hdr_size(p); // strip data peri header
+				gpsrh->mode_ = GPSRH_DATA_GREEDY;
+				cmh->size() += hdr_size(p); // add data greedy header
+				/* always add back (- - is +) 12 bytes: if use_implicit_beacon_,
+				   src added 12 to size, don't re-add hops_[0]; otherwise,
+				   still don't want to count hops_[0]. */
+				gpsrh->currhop_ = 0;
+				gpsrh->nhops_ = 0;
+				// recursive, but must call target_->recv in callee frame
+				trace("VSM->G %f _%d_ [%d -> %d]", now, mn_->address(), iph->saddr(), iph->daddr());
+		
+				forwardPacket(p);
+				return;
+			}
+
+			if(use_planar_){
+				// forward along current face, or change faces where appropriate
+				/* don't choose *any* edge--only consider edges on the
+				   face we're forwarding on at the moment. */
+				for(int i=0; i<gpsrh->nhops_; i++)
+					trace("Vne %.8f _%d_ <- %d", CURRTIME, mn_->address(), gpsrh->hops_[i].ip);
+
+				ne = ntab_->ent_finddst(gpsrh->hops_[gpsrh->nhops_-1].ip);
+				if(ne){
+					double fromx, fromy, fromz;
+					ne = ntab_->ent_findnext_onperi(mn_,
+													gpsrh->hops_[0].ip, gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z,
+													use_planar_);
+
+					/** drop if we've looped on this perimeter:
+						are about to revisit the first edge we took on it */
+					if ((gpsrh->periptip_[1] == mn_->address()) &&
+						(gpsrh->periptip_[2] == ne->dst)) {
+
+						if(gpsrh->geoanycast)
+							{
+								// wk forwardPacket, finished perimeter 
+								// without finding target
+								locservice_->dropPacketCallback(p);
+								if (p==NULL) { return; }
+							}
+
+						TRACE_CONN(p,addr(),addr(),HDR_IP(p)->daddr());
+						drop(p, DROP_RTR_NO_ROUTE);
+						return;
+					}
+			
+					// does the candidate next edge have a closer pt?
+					if (!ne) {
+						// no face toward the destination
+						if(gpsrh->geoanycast)
+							{
+								// wk forwardPaket
+								locservice_->dropPacketCallback(p);
+								if (p==NULL) { return; }
+							}
+
+						drop(p, DROP_RTR_NO_ROUTE);
+						return;
+					}
+
+					/** face-change(p,t) */
+					if (ne->closer_pt(mn_->address(), myx, myy, myz,
+									  gpsrh->peript_.x, gpsrh->peript_.y,
+									  gpsrh->periptip_[1], gpsrh->periptip_[0],
+									  iph->dx_, iph->dy_, &closerx, &closery)) {
+						/* yes. choose a new next hop on the peri pierced by the line
+						   to the destination. */
+						/* several neighboring edges may be cut by line to destination;
+						   choose that cut at the point closest to destination */
+						int counter = 0;
+						while (ne->closer_pt(mn_->address(), myx, myy, myz,
+											 gpsrh->peript_.x, gpsrh->peript_.y,
+											 gpsrh->periptip_[1], gpsrh->periptip_[0],
+											 iph->dx_, iph->dy_, &closerx, &closery)) {
+							// fake that ingress edge was edge from ne
+							
+							
+							// re-use single-hop history
+							gpsrh->hops_[gpsrh->nhops_-1].ip = ne->dst;
+							gpsrh->hops_[gpsrh->nhops_-1].x = ne->x;
+							gpsrh->hops_[gpsrh->nhops_-1].y = ne->y;
+							gpsrh->hops_[gpsrh->nhops_-1].z = ne->z;
+							
+							// record closest point on edge to ne
+							gpsrh->perips_.x = closerx;
+							gpsrh->perips_.y = closery;
+							gpsrh->perips_.z = 0.0;
+							
+							NeighbEnt *ne_temp = ntab_->ent_findnext_onperi(mn_, ne->dst, ne->x, ne->y, ne->z, use_planar_);
+							if((ne_temp == NULL) || (ne_temp->dst == ne->dst))
+								break;
+							ne = ne_temp;
+							counter++;
+						}
+
+						// record edge endpt ips
+						gpsrh->periptip_[0] = ne->dst; // prev hop
+						gpsrh->periptip_[1] = mn_->address(); // self
+						gpsrh->periptip_[2] = ne->dst; // next hop
+
+						cmh->next_hop_ = ne->dst;
+						goto finish_pkt;
+					} /* end if(ne->...) */
+				} /*end of if(ne): incoming node isn't in the neighbor-table!!! */
+	    		  
+				// forward to next ccw neighbor from ingress edge
+				/* in theory, a data peri packet received from an unknown neighbor
+				   should serve as a beacon from that neighbor... */
+				/* BUT, don't add the previous hop more than once when we retransmit a
+				   packet--the prev hop information is stale in that case */
+
+				if (ne == NULL) {
+					// XXX might we now be able to forward anyway?? know loc of prev hop.
+					/* we're trying to retransmit a packet, but the ingress hop is
+					   gone. drop it. */
+					// a drop due to MAC_CALLBACK. For the moment, inform it
+					if(gpsrh->geoanycast)
+						{
+							// wk forwardPaket
+							locservice_->dropPacketCallback(p);
+							if (p==NULL) { return; }
+						}
+					// a drop due to MAC_CALLBACK. For the moment,don't inform it
+					trace("VneNULL %.8f _%d_ <- %d", CURRTIME, mn_->address(), gpsrh->hops_[gpsrh->nhops_-1].ip);
+					drop(p, DROP_RTR_MAC_CALLBACK);
+					return;
+				}
+				cmh->next_hop_ = ne->dst;
+				if (use_loop_detect_) {
+					gpsrh->add_hop(mn_->address(), myx, myy, myz);
+					printf("Warning: This size change has not been modified, yet!\n");
+					cmh->size() += 12;
+				}
+				else {
+					gpsrh->hops_[gpsrh->nhops_-1].ip = mn_->address();
+					gpsrh->hops_[gpsrh->nhops_-1].x = myx;
+					gpsrh->hops_[gpsrh->nhops_-1].y = myy;
+					gpsrh->hops_[gpsrh->nhops_-1].z = myz;
+				}
+			} // end if(use_planar_)
+			else {
+		
+				// am I the right waypoint?
+				if (gpsrh->hops_[gpsrh->currhop_].ip == mn_->address()) {
+					// am I the final waypoint?
+					if (gpsrh->currhop_ == (gpsrh->nhops_-1)) {
+						// yes! return packet to greedy mode
+						ntab_->counter_clock = true; // next peri -> route counterclockwise
+						cmh->size() -= hdr_size(p); // strip data peri header
+						gpsrh->mode_ = GPSRH_DATA_GREEDY;
+						cmh->size() += hdr_size(p); // strip data greedy header
+						gpsrh->currhop_ = 0;
+						gpsrh->nhops_ = 0;
+						forwardPacket(p);
+						return;
+					}
+					else {
+						// forward using source route...
+						double fromx, fromy, fromz;
+						ne = ntab_->ent_findnext_onperi(mn_,
+														gpsrh->hops_[0].ip, gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z,
+														use_planar_);
+
+						if(!ne){
+							if(gpsrh->geoanycast)
+							{
+								// wk forwardPacket 
+								locservice_->dropPacketCallback(p);
+								if (p==NULL) { return; }
+							}
+
+							drop(p, DROP_RTR_NO_ROUTE);
+							return;
+						}
+
+						gpsrh->currhop_++;
+						gpsrh->hops_[gpsrh->currhop_].ip = ne->dst;
+						cmh->next_hop_ = gpsrh->hops_[gpsrh->currhop_].ip;
+			    
+					}
+				}
+				else {
+					if(gpsrh->geoanycast)
+							{
+								// wk forwardPacket
+								locservice_->dropPacketCallback(p);
+								if (p==NULL) { return; }
+							}
+
+					// topology must have changed; I'm not the right hop
+					TRACE_CONN(p,addr(),addr(),HDR_IP(p)->daddr());
+
+					drop(p, DROP_RTR_NO_ROUTE);
+					return;
+				}
+			}
+	    } // end if(use_peri_)
+	    else {
+			fprintf(stderr,
+					"yow! got peri mode packet when not using perimeters!\n");
+			abort();
+	    }
+	    break;
+	default:
+	    fprintf(stderr, "yow! got non-data packet in forward_packet()!\n");
+	    abort();
+	    break;
+    }
+    
+ finish_pkt:
+
+    // pass along
+    cmh->addr_type_ = NS_AF_INET;
+    cmh->xmit_failure_ = mac_callback;
+    cmh->xmit_failure_data_ = this;
+    
+    // point the packet *down* the stack
+    cmh->direction() = hdr_cmn::DOWN;
+
+    // data packet can serve as implicit beacon; put self in hops_[0]
+    double myx, myy, myz;
+    mn_->getLoc(&myx, &myy, &myz);
+    /* the packet may *already* have hops stored; don't allocate with
+       add_hop()! */
+    gpsrh->hops_[0].ip = mn_->address();
+    gpsrh->hops_[0].x = myx;
+    gpsrh->hops_[0].y = myy;
+    gpsrh->hops_[0].z = myz;
+
+    // reactive beaconing requires, that a retried pkt
+    // is marked as clean again, so it can be retried
+    // at the next node
+    if (use_reactive_beacon_) { gpsrh->retry = 0; }
+    
+    if (use_congestion_control_)
+		gpsrh->load = getLoad();
+
+    if (verbose_)
+		trace ("VFP %.5f _%d -> %d_ %d:%d -> %d:%d", now, mn_->address(),
+			   ne->dst,
+			   Address::instance().get_nodeaddr(iph->saddr()),
+			   iph->sport(),
+			   Address::instance().get_nodeaddr(iph->daddr()),
+			   iph->dport() );
+    target_->recv(p, (Handler *)0);
+ 
+    if (use_beacon_) {
+		if ((use_implicit_beacon_)&&(!use_reactive_beacon_))
+			BEACON_RESCHED;
+    }
+}
+
+/***********/
+/* Receive */
+/***********/
+
+void
+GPSR_Agent::recv(Packet *p, Handler *) {
+
+    // Check if this node is awake
+    if (!active_) {
+		Packet::free(p);
+		p = NULL;
+		return;
+    }
+
+    // Check if Locservice is interested in this pkt
+    locservice_->recv(p);
+    if (p==NULL) { return; }
+    /*
+      Check if GPSR is interested in this pkt
+    */
+
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_cmn *cmh = HDR_CMN(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+    int src = Address::instance().get_nodeaddr(iph->saddr());
+
+    // Filter pkts I originated
+    if (src == mn_->address()) {
+
+		if (cmh->num_forwards() == 0) {
+	    
+            // Fresh pkt that needs setting up
+			if (iph->dport() != RT_PORT) { 
+				gpsrh->mode_ = GPSRH_DATA_GREEDY; 
+			} // non-route pkts
+			gpsrh->geoanycast = true;
+			if (gpsrh->port_ != hdr_gpsr::LOCS) { cmh->size() += IP_HDR_LEN; }   // non-ls pkts
+			cmh->size() += hdr_size(p);
+			// HLS packets do their own TTL management
+			if(cmh->ptype() != PT_HLS)
+				{
+					iph->ttl_ = 128;
+#ifdef PING_TTL
+					iph->ttl_ = PING_TTL;
+#endif
+				}
+
+			// Lookup Position Information
+			if (!locservice_->poslookup(p)){
+				stickPacketInSendBuffer(p);
+				return;
+			}
+
+		}else{
+
+			if ((gpsrh->port_ != hdr_gpsr::LOCS) && (gpsrh->mode_ == GPSRH_DATA_GREEDY)) {
+				// No real data pkt should visit its source twice 
+				drop(p, DROP_RTR_ROUTE_LOOP);
+				return;
+			}
+		}
+    }
+    
+	// Check for expired TTL
+    if ((src == mn_->address()) && (cmh->num_forwards() == 0)) {
+		// Originating Packets should have their TTL
+		// decreased for the first hop
+    } else {
+		if (--iph->ttl_ <= 0) {
+			
+			// only Requests and replies are routed in peri mode (where TTL
+			// expiration is likely to occur) we can assume that there 
+			// exists no route.
+			
+			if(gpsrh->geoanycast)
+				{
+					// if there is a TTL problem, we treat at least the
+					// requests 
+					locservice_->dropPacketCallback(p);
+					//printf("drop packet due to TTL\n");
+					if (p==NULL) { return; }
+				}
+			
+			drop(p, DROP_RTR_TTL);
+			return;
+		}
+    }
+
+    /*
+      Forwarding Packet
+    */
+    
+    // LOCS Packets
+    if (gpsrh->port_ == hdr_gpsr::LOCS) {
+		forwardPacket(p); 
+		return; 
+    }
+    
+    // GPSR Packets (Routing Packets)
+    if (iph->dport() == RT_PORT) {
+		char *as;
+
+		switch (gpsrh->mode_) {
+	    case GPSRH_BEACON:
+			if (src != mn_->address()) { recvBeacon(p); }
+			break;
+	    case GPSRH_BEACON_REQ:
+			if (src != mn_->address()) { recvBeaconReq(p); }
+			break;
+	    case GPSRH_PPROBE:
+			periIn(p, gpsrh);
+			break;
+	    case GPSRH_DATA_GREEDY:
+			as = Address::instance().print_nodeaddr(addr());
+			fprintf(stderr, "greedy data pkt @ %s:RT_PORT!\n",as); fflush(stderr);
+			delete[] as;
+			break;
+	    case GPSRH_DATA_PERI:
+			as = Address::instance().print_nodeaddr(addr());
+			fprintf(stderr, "peri data pkt @ %s:RT_PORT!\n",as); fflush(stderr);
+			delete[] as;
+			break;
+	    default:
+			as = Address::instance().print_nodeaddr(addr());
+			fprintf(stderr, "unk pkt type %d @ %s:RT_PORT!\n", gpsrh->mode_,as); fflush(stderr);
+			delete[] as;
+			break;
+		}
+		return;
+    }
+
+    // Everything else
+    forwardPacket(p);
+}
+
+/****************************/
+/* Startup/Setup Functions  */
+/****************************/
+
+int
+GPSR_Agent::command(int argc, const char *const *argv) {
+    
+    if (argc == 2) {
+		if (strcmp(argv[1], "start-gpsr") == 0) {
+			init();
+			return TCL_OK;
+		}
+		/* -> [HMF] */
+		if (strcasecmp(argv[1], "resetSB") == 0) {
+			Terminate();
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "sleep") == 0){
+			if (active_) { sleep(); }
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "wake") == 0){
+			if (!active_) { wake(); }
+			return TCL_OK;
+		}
+		/* <- */
+    }  
+    if (argc == 3) {
+
+		if (strcasecmp(argv[1], "test-query") == 0) {
+			int dst = atoi(argv[2]);
+
+			// Generate Dummy Packet
+			Packet* pkt = allocpkt();
+			struct hdr_ip* iph = HDR_IP(pkt);
+			struct hdr_cmn* cmnh = HDR_CMN(pkt);
+
+			iph->saddr() = addr();
+			iph->daddr() = dst;
+			iph->ttl() = 1;
+			cmnh->ptype() = PT_PING;
+			cmnh->addr_type_ = NS_AF_INET;
+			cmnh->num_forwards() = 0;
+			cmnh->next_hop_ = NO_NODE;
+			cmnh->size() = size_;
+			cmnh->xmit_failure_ = 0;
+			cmnh->direction() = hdr_cmn::DOWN;
+
+			double srcPosX, srcPosY, srcPosZ, dstPosX, dstPosY, dstPosZ;
+			God::instance()->getPosition(addr(), &srcPosX, &srcPosY, &srcPosZ);
+			God::instance()->getPosition(dst, &dstPosX, &dstPosY, &dstPosZ);			
+			trace("TESTQ %.12f %d (%.2f %.2f) %d (%.2f %.2f)", 
+				  Scheduler::instance().clock(), // timestamp
+				  addr(), // source of the query
+				  srcPosX,// source position x
+				  srcPosY,// source position y
+				  dst,    // target of the query
+				  dstPosX,// destination position x 
+				  dstPosY);// destination position y
+			// Query Target
+			locservice_->poslookup(pkt);
+
+			// Delete Dummy Packet
+			Packet::free(pkt);
+			return TCL_OK;
+		}
+
+		TclObject *obj;
+		if (strcasecmp(argv[1], "tracetarget") == 0) {
+			if ((obj = TclObject::lookup(argv[2])) == 0) {
+				fprintf(stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1], argv[2]);
+				return TCL_ERROR;
+			}
+			tracetarget = (Trace *) obj;
+			locservice_->setTraceTarget((Trace *)obj);
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "install-tap") == 0) {
+			if ((obj = TclObject::lookup(argv[2])) == 0) {
+				fprintf(stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1], argv[2]);
+				return TCL_ERROR;
+			}
+			m = (Mac *) obj;
+			m->installTap(this);
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "node") == 0) {
+			if ((obj = TclObject::lookup(argv[2])) == 0) { return TCL_ERROR; }
+			mn_ = (MobileNode *) obj;
+			locservice_->setMobileNode((MobileNode *)obj);
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "ldb") == 0) {
+			if ((obj = TclObject::lookup(argv[2])) == 0) { return TCL_ERROR; }
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "if-queue") == 0) {
+			ifq_ = (PriQueue*) TclObject::lookup(argv[2]);
+			if(ifq_ == 0) { return TCL_ERROR; }
+			return TCL_OK;
+		}
+    }
+    return (Agent::command (argc, argv));
+}
+
+void
+GPSR_Agent::init(void) {
+
+    // Init LocService
+    locservice_->init();
+    locservice_->setTarget(target_);
+  
+    if (active_) {
+		God::instance()->signOn(addr());
+#ifdef GPSR_TRACE_WAKESLEEP
+		trace("VGI: %f %d", Scheduler::instance().clock(), mn_->address());
+#endif
+
+		if ((use_beacon_)&&(!use_reactive_beacon_)) {
+			beacon_timer_->sched(Random::uniform(bint_)); 
+		}
+		if (!peri_proact_)    { lastperi_timer_->sched(lpexp_); }
+		if (use_timed_plnrz_) { planar_timer_->sched(1.0); }
+    
+		// Init SendPermissions
+		for (unsigned int i=0;i<GPSR_PKT_TYPES;i++) {
+			send_allowed[i] = true;
+		}
+	
+		send_buf_timer.sched(sendbuf_interval());
+    }
+}
+
+void
+GPSR_Agent::sleep() {
+    
+    assert(active_);
+    
+    // Lowlevel
+    m->sleep();
+    if (ifq_) { ((PriQueue *)ifq_)->clear(); }
+    
+#ifdef GPSR_TRACE_WAKESLEEP
+    trace("VGSLEEP %f _%d_ ", Scheduler::instance().clock(), mn_->address());
+#endif
+
+    // Stop SendPermissions
+    for (unsigned int i=0;i<GPSR_PKT_TYPES;i++) {
+		send_allowed[i] = false;
+    } 
+
+    // Clean SendBuffer
+    send_buf_timer.force_cancel();
+    for (int c=0; c < SEND_BUF_SIZE; c++) {
+		if (send_buf[c].p != NULL) {
+			// wk sleep, not necessary to inform locservice, I cant receive the packet
+			// due to sleep
+			drop(send_buf[c].p, DROP_RTR_SLEEP);
+			send_buf[c].p = NULL;
+		}
+    }
+
+    if ((use_beacon_)&&(!use_reactive_beacon_)) { 
+		beacon_timer_->force_cancel(); 
+    }
+
+    if (!peri_proact_)    { lastperi_timer_->force_cancel(); }
+    if (use_timed_plnrz_) { planar_timer_->force_cancel(); }
+    
+    // Shutdown LocService
+    locservice_->sleep();
+
+    God::instance()->signOff(addr());
+    active_ = false;
+}
+
+void
+GPSR_Agent::wake() {
+
+    assert(!active_);
+
+
+    active_ = true;
+    God::instance()->signOn(addr());
+
+    // Wakeup LocService
+    locservice_->wake();
+
+    // Setup SendBuffer
+    send_buf_timer.sched(sendbuf_interval());
+
+    // Init SendPermissions
+    for (unsigned int i=0;i<GPSR_PKT_TYPES;i++) {
+		send_allowed[i] = true;
+    }
+
+#ifdef GPSR_TRACE_WAKESLEEP    
+    trace("VGWAKE %f _%d_", Scheduler::instance().clock(), mn_->address());
+#endif
+
+    if ((use_beacon_)&&(!use_reactive_beacon_)) {  
+		beacon_timer_->sched(Random::uniform(bint_)); 
+    }
+    if (!peri_proact_)    { lastperi_timer_->sched(lpexp_); }
+    if (use_timed_plnrz_) { planar_timer_->sched(1.0); }
+
+    // LowLevel
+    m->wakeup();
+} 
+
+/***********************/
+/* Beaconing Functions */
+/***********************/
+
+void
+GPSR_Agent::beacon_proc(int src, double x, double y, double z, int load)
+{
+	NeighbEnt *ne;
+	NeighbEnt nne(this);
+
+	double now = Scheduler::instance().clock();
+	nne.dst = src;
+	nne.x = x; nne.y = y; nne.z = z;
+	nne.ts = now;
+	nne.load = load;
+
+	ne = ntab_->ent_add(&nne);
+
+	if (false) { trace("VBP %f _%d_ [%d/%.2f/%.2f]", now, mn_->address(), src, x, y); }
+	{
+		// entry wasn't in table before. need to planarize, if option dictates.
+		ne->live = 1;
+		if (use_planar_) {
+			double myx, myy, myz;
+
+			mn_->getLoc(&myx, &myy, &myz);
+			
+			if((bool)Random::uniform(1))
+				ntab_->planarize(PLANARIZE_GABRIEL, mn_->address(), myx, myy, myz);
+			
+		}
+	}
+	ne->dnt.resched(bexp_);
+}
+
+void
+GPSR_Agent::recvBeacon(Packet *p) {
+
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+    int src = Address::instance().get_nodeaddr(iph->saddr());
+
+    beacon_proc(src, gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z, gpsrh->load);
+    Packet::free(p);
+}
+
+void
+GPSR_Agent::recvBeaconReq(Packet *p) {
+
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+    // Evaluate Beacon Req Information
+    int src = Address::instance().get_nodeaddr(iph->saddr());
+    beacon_proc(src, gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z, gpsrh->load);
+
+    // Answer Request with a Beacon
+    double delay = Random::uniform(GPSR_RBEACON_JITTER);
+    sendBeacon(delay);
+
+    // Discard Request
+    Packet::free(p);
+}
+
+void
+GPSR_Agent::sendBeaconRequest() {
+    
+    assert(active_);
+
+    if (!allowedToSend(GPSRH_BEACON_REQ)) { return; }
+
+    Packet *p = allocpkt();
+
+    struct hdr_cmn *hdrc = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+  
+    // Set up Beacon Headers
+    gpsrh->mode_ = GPSRH_BEACON_REQ;
+    gpsrh->nhops_ = 1;
+    mn_->getLoc(&gpsrh->hops_[0].x, &gpsrh->hops_[0].y, &gpsrh->hops_[0].z);
+
+    hdrc->ptype_ = PT_GPSR;
+    hdrc->next_hop_ = IP_BROADCAST;
+    hdrc->addr_type_ = NS_AF_INET;
+    hdrc->size() = hdr_size(p);
+
+    iph->daddr() = IP_BROADCAST << Address::instance().nodeshift();
+    iph->dport() = RT_PORT;
+
+    if (use_congestion_control_) {
+		gpsrh->load = getLoad();
+    }
+    
+    beaconreq_delay_->resched(GPSR_BEACON_REQ_DELAY);
+    block(GPSRH_BEACON_REQ);
+
+    Scheduler::instance().schedule(target_, p, 0.0);
+}
+
+void
+GPSR_Agent::checkGreedyCondition(const Packet *p) {
+
+    // If we announced ourselves not long ago, we
+    //  don't need to do it again
+    if (!allowedToSend(GPSRH_BEACON)) { return; }
+
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+    // Data Greedy Packets should be checked, to see
+    //  if i'm on their greedy path. if so, we'll 
+    //  send a beacon to announce our position
+
+    if (gpsrh->mode_ == GPSRH_DATA_GREEDY) {
+	
+		double mydist, shortest, myx, myy, myz;
+
+		mn_->getLoc(&myx, &myy, &myz);
+		shortest = distance(gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z, 
+							iph->dx_, iph->dy_, iph->dz_);
+		mydist   = distance(gpsrh->hops_[0].x, gpsrh->hops_[0].y, gpsrh->hops_[0].z, 
+							myx, myy, myz);
+		if (mydist < shortest) {
+			double delay = Random::uniform(GPSR_RBEACON_JITTER);
+			sendBeacon(delay);
+			beacon_delay_->resched(GPSR_BEACON_DELAY);
+			block(GPSRH_BEACON);
+		}
+    }
+}
+
+void
+GPSR_Agent::sendBeacon(double delay) {
+
+	assert(active_);
+
+	Packet *p = allocpkt();
+
+	struct hdr_cmn *hdrc = HDR_CMN(p);
+	struct hdr_ip *iph = HDR_IP(p);
+	struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+	// Set up Beacon Headers
+	gpsrh->mode_ = GPSRH_BEACON;
+	gpsrh->nhops_ = 1;
+	mn_->getLoc(&gpsrh->hops_[0].x, &gpsrh->hops_[0].y, &gpsrh->hops_[0].z);
+
+	hdrc->ptype_ = PT_GPSR;
+	hdrc->next_hop_ = IP_BROADCAST;
+	hdrc->addr_type_ = NS_AF_INET;
+	hdrc->size() = hdr_size(p);
+
+	iph->daddr() = IP_BROADCAST << Address::instance().nodeshift();
+	iph->dport() = RT_PORT;
+
+	if (use_congestion_control_) {
+		gpsrh->load = getLoad();
+	}
+
+	Scheduler::instance().schedule(target_, p, delay);
+}
+
+/********************/
+/* PacketDelayTimer */
+/********************/
+
+void
+PacketDelayTimer::handle() {
+    a->forwardPacket((Packet*)local_info);
+}
+
+void
+PacketDelayTimer::deleteInfo(void* info) {
+    Packet::free((Packet*)info);
+}
+
+/**************************************/
+/* Location Service Related Functions */
+/**************************************/
+
+void
+GPSR_Agent::Terminate()
+{
+    for (int c=0; c<SEND_BUF_SIZE; c++) {
+		if (send_buf[c].p) {
+			drop(send_buf[c].p, DROP_END_OF_SIMULATION);
+			send_buf[c].p = NULL;
+		}
+    }
+}
+
+void
+GPSR_Agent::notifyPos(nsaddr_t id)
+{
+    struct hdr_ip *iph;
+    struct hdr_cmn *cmnh;
+    struct hdr_locs *locsh;
+    
+    for (int c=0; c<SEND_BUF_SIZE; c++) {
+		if (send_buf[c].p == NULL) continue;
+		iph = HDR_IP(send_buf[c].p); 
+		if (iph->daddr() == id) {   
+			if (locservice_->poslookup(send_buf[c].p)){
+				if ((false)&&(iph->daddr()==id)) {
+					cmnh = HDR_CMN(send_buf[c].p);
+					locsh = HDR_LOCS(send_buf[c].p);
+		    
+					double dstx, dsty, dstz;
+					God::instance()->getPosition(iph->daddr(), &dstx, &dsty, &dstz);
+		    
+					trace("SB %.5f _%d_ %d unusual send [%d %.4f %.2f %.2f] (%.2f %.2f)", 
+						  Scheduler::instance().clock(), 
+						  mn_->address(),
+						  cmnh->uid(),
+						  locsh->dst.id, locsh->dst.ts, locsh->dst.loc.x, locsh->dst.loc.y,
+						  dstx, dsty);
+				}
+				// Maybe we shouldn't send all the Pakets at once, 
+				// but rather schedule them one by one... ?
+				forwardPacket(send_buf[c].p);
+				send_buf[c].p = NULL;
+			}
+		}
+    }
+}
+
+void
+GPSR_Agent::stickPacketInSendBuffer(Packet *p)
+{
+	double min = 99999.0; //initialize min to some big enough number
+	int min_index = 0;
+
+	struct hdr_ip *iph = HDR_IP(p); 
+
+	if (verbose_)
+		trace("SB %.5f _%d_ stuck into send buff %d -> %d", 
+			  Scheduler::instance().clock(), 
+			  mn_->address(), 
+			  iph->saddr(),
+			  iph->daddr());
+  
+	for (int c=0; c < SEND_BUF_SIZE; c++)
+		if (send_buf[c].p == NULL) {
+			send_buf[c].t = Scheduler::instance().clock();
+			send_buf[c].p = p;
+			return;
+		}else if (send_buf[c].t < min) {
+			min = send_buf[c].t;
+			min_index = c;
+		}
+  
+	// kill somebody
+	if (verbose_) 
+		trace("SB %.5f _%d_ dropped %d -> %d", 
+			  Scheduler::instance().clock(), 
+			  mn_->address(), 
+			  iph->saddr(), 
+			  iph->daddr());
+	dropSendBuff(send_buf[min_index].p,DROP_SB_FULL);
+	assert(send_buf[min_index].p == NULL);
+	send_buf[min_index].t = Scheduler::instance().clock();
+	send_buf[min_index].p = p;
+}
+
+void
+GPSR_Agent::dropSendBuff(Packet *&p, const char* reason)
+{
+    struct hdr_ip *iph = HDR_IP(p);
+
+    if (verbose_) 
+		trace("SB %.5f _%d_ dropped %d -> %d for %s", 
+			  Scheduler::instance().clock(), 
+			  mn_->address(),  
+			  iph->saddr(), 
+			  iph->daddr(),
+			  reason);
+    
+    drop(p,reason);
+    p = NULL;
+}
+
+void
+GPSR_Agent::sendBufferCheck()
+{
+
+    for (int c=0; c <SEND_BUF_SIZE; c++) {
+		if (send_buf[c].p == NULL) continue;
+		double elapsed = Scheduler::instance().clock() - send_buf[c].t;
+		if (elapsed > SEND_TIMEOUT) {	
+			dropSendBuff(send_buf[c].p,DROP_SB_TOUT);
+			send_buf[c].p = NULL;
+			continue;
+		}
+	
+		// Retry Sending
+		if (locservice_->poslookup(send_buf[c].p)){
+			forwardPacket(send_buf[c].p);
+			send_buf[c].p = NULL;
+		}
+    }
+}
+
+void
+GPSRSendBufferTimer::expire(Event *e)
+{
+	a_->sendBufferCheck();
+	resched(a_->sendbuf_interval());
+}
+
+/*********************************************/
+/* One more try to get a clean size handling */
+/*********************************************/
+
+int
+GPSR_Agent::hdr_size(Packet* p)
+{
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+    unsigned int size = 0;
+
+    // Defining Base Field Types in Bytes
+    const unsigned int packetType = 1;
+    const unsigned int id         = 4;
+    const unsigned int locCoord   = 3;
+    const unsigned int congestion = 1;
+    const unsigned int position   = locCoord + locCoord;
+    unsigned int imp_beacon =  id + position;
+
+    if (use_congestion_control_)
+		imp_beacon += congestion;
+    
+    if (!use_implicit_beacon_)
+		imp_beacon = 0;
+
+    if (cmnh->ptype() == PT_GPSR) { // GPSR Packet
+
+		switch (gpsrh->mode_) {
+	    case GPSRH_PPROBE:
+			return (packetType + 2*id + 2*position + position + imp_beacon);
+	    case GPSRH_BEACON:
+			return (packetType + imp_beacon); 
+	    case GPSRH_BEACON_REQ:
+			return (packetType + imp_beacon); 
+	    default:
+			printf("Invalid GPSR Packet wants to know it's size !\n");
+			abort();
+		}
+    }
+
+	// don't add the size for the geo-anycast flag here because at the
+	// moment it is just used in the HLS. If it should be used by any 
+	// other service, the bit used for it must be considered
+    if (cmnh->ptype() == PT_LOCS) { // LOCS Packet
+		size = packetType + imp_beacon;
+    }
+    
+    if ((cmnh->ptype() != PT_GPSR) && (cmnh->ptype() != PT_LOCS)) { // Data Packet
+
+		switch (gpsrh->mode_) {
+	    case GPSRH_DATA_GREEDY: 
+			size = (packetType + position + imp_beacon);
+			break;
+	    case GPSRH_DATA_PERI:
+			size = (packetType + position + 2*id + 2*position + position + imp_beacon); // last position for intersecting line
+			break;
+	    default:
+			printf("Invalid DATA Packet wants to know it's size !\n");
+			abort();
+		}
+    }
+
+    size += locservice_->hdr_size(p);
+    return size;
+}
+
+/*******************/
+/* Timer Functions */
+/*******************/
+
+void GPSR_DeadNeighbTimer::expire(Event *) { if (a->isActive()) a->deadneighb_callback(ne); }
+void GPSR_PeriProbeTimer::expire(Event *) { if (a->isActive()) a->periprobe_callback(ne); }
+void GPSR_BeaconTimer::expire(Event *) { if (a->isActive()) a->beacon_callback(); }
+void GPSR_LastPeriTimer::expire(Event *) { if (a->isActive()) a->lastperi_callback(); }
+void GPSR_PlanarTimer::expire(Event *) { if (a->isActive()) a->planar_callback(); }
+
+void GPSRBeaconReqDelayTimer::expire(Event *) { if (a->isActive()) a->allow(GPSRH_BEACON_REQ); }
+void GPSRBeaconDelayTimer::expire(Event *) { if (a->isActive()) a->allow(GPSRH_BEACON); }
+
diff -u -r --new-file ./gpsr/gpsr.h ../../ns-2.33-hls_working/ns-2.33/gpsr/gpsr.h
--- ./gpsr/gpsr.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/gpsr/gpsr.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,500 @@
+#ifndef _GPSR_h
+#define _GPSR_h
+
+/*
+
+  Copyright (C) 2000 President and Fellows of Harvard College
+
+  All rights reserved.
+
+  NOTICE: This software is provided "as is", without any warranty,
+  including any implied warranty for merchantability or fitness for a
+  particular purpose.  Under no circumstances shall Harvard University
+  or its faculty, staff, students or agents be liable for any use of,
+  misuse of, or inability to use this software, including incidental
+  and consequential damages.
+
+  License is hereby given to use, modify, and redistribute this
+  software, in whole or in part, for any commercial or non-commercial
+  purpose, provided that the user agrees to the terms of this
+  copyright notice, including disclaimer of warranty, and provided
+  that this copyright notice, including disclaimer of warranty, is
+  preserved in the source code and documentation of anything derived
+  from this software.  Any redistributor of this software or anything
+  derived from this software assumes responsibility for ensuring that
+  any parties to whom such a redistribution is made are fully aware of
+  the terms of this license and disclaimer.
+
+  Author: Brad Karp, Harvard University EECS, May, 1999
+  $Id: gpsr.h,v 1.1 2004/05/10 16:38:26 schenke Exp $
+*/
+using namespace std;
+
+// GPSR for ns2 w/wireless extensions
+
+#include "agent.h"
+#include "ip.h"
+#include "delay.h"
+#include "scheduler.h"
+#include "queue.h"
+#include "trace.h"
+#include "arp.h"
+#include "ll.h"
+#include "mac.h"
+#include "mac-802_11.h"
+#include "priqueue.h"
+#include "node.h"
+#include "timer-handler.h"
+#include <random.h>
+#include "god.h"
+
+
+#include "../locservices/ls_queued_timer.h"
+
+
+/***********/
+/* Defines */
+/***********/
+
+// Location Services
+#define _OMNI_     0
+#define _REACTIVE_ 1 
+#define _GRID_     2 
+#define _CELL_     3
+
+// GPSR Defaults - Karp
+#define GPSR_ALIVE_DESYNC  0.5	/* desynchronizing term for alive beacons */
+#define GPSR_ALIVE_INT     0.5	/* interval between alive beacons */
+#define GPSR_ALIVE_EXP     (3*(GPSR_ALIVE_INT+GPSR_ALIVE_DESYNC*GPSR_ALIVE_INT))
+				/* timeout for expiring rx'd beacons */
+#define GPSR_PPROBE_INT    1.5	/* interval between perimeter probes */
+#define GPSR_PPROBE_DESYNC 0.5	/* desynchronizing term for perimeter probes */
+#define GPSR_PPROBE_EXP    8.0	/* how often must use a perimeter to keep probing them */
+#define GPSR_PPROBE_RTX    1
+
+#define PERI_DEFAULT_HOPS 32	/* default max number of hops in peri header */
+#define MAX_PERI_HOPS_STATIC 128
+#define PLANARIZE_RNG 0
+#define PLANARIZE_GABRIEL 1
+
+// SendBuffer
+#define BUFFER_CHECK    0.05
+#define SEND_BUF_SIZE   64   /* As in DSR */
+#define SEND_TIMEOUT    30   /* As in DSR */
+#define JITTER_VAR      0.3
+
+// Reactive Beaconing
+#define GPSR_RBEACON_JITTER   0.015
+#define GPSR_RBEACON_RETRIES  1
+#define GPSR_BEACON_REQ_DELAY bexp_
+#define GPSR_BEACON_DELAY     bexp_
+
+// Packet Types
+#define GPSR_PKT_TYPES    6     /* how many pkt types are defined */
+
+#define GPSRH_DATA_GREEDY 0	/* greedy mode data packet */
+#define GPSRH_DATA_PERI   1	/* perimeter mode data packet */
+#define GPSRH_PPROBE      2	/* perimeter probe packet */
+#define GPSRH_BEACON      3     /* liveness beacon packet */
+#define GPSRH_BEACON_REQ  4     /* neighbor request */
+
+#define GPSR_ROUTE_VERBOSE 1   /* should shortest route be aquired and */
+
+
+#ifndef CURRTIME
+#define CURRTIME Scheduler::instance().clock()
+#endif
+
+
+// opaque type: returned by NeighbTable iterator, holds place in table
+typedef unsigned int NeighbTableIter;
+
+
+class GPSR_Agent;
+class NeighbEnt;
+class NeighbTable;
+
+
+/**************/
+/* Structures */
+/**************/
+
+struct GPSRSendBufEntry{
+    double t;
+    Packet *p;
+};
+
+struct PeriEnt {
+    double x;
+    double y;
+    double z;
+    nsaddr_t ip;
+};
+
+struct hdr_gpsr {
+    
+    struct PeriEnt hops_[MAX_PERI_HOPS_STATIC];
+    struct PeriEnt peript_; // starting point
+    struct PeriEnt perips_; // intersection point
+    nsaddr_t periptip_[3];
+    int nhops_;
+    int currhop_;
+    int mode_;
+
+    // Additions
+    int load;
+    int retry;
+
+    // for geo-anycast - wk
+     bool geoanycast;
+  
+
+
+    enum port_t { GPSR=0, LOCS=1 };
+    int port_;
+
+    int size() { return 0; }
+    
+    // NS-2 requirements
+    static int offset_;
+    inline static int& offset() { return offset_; } 
+    inline static hdr_gpsr* access(const Packet* p) {
+	return (hdr_gpsr*) p->access(offset_);
+    }
+  
+    void add_hop(nsaddr_t addip, double addx, double addy, double addz) {
+	if (nhops_ == MAX_PERI_HOPS_STATIC) {
+	    fprintf(stderr, "hdr_gpsr::add_hop: out of slots!\n");
+	    abort();
+	}
+	hops_[nhops_].x = addx; hops_[nhops_].y = addy; hops_[nhops_].z = addz;
+	hops_[nhops_].ip = addip;
+	nhops_++;
+    }
+};  
+
+
+/*****************/
+/* Timer Classes */
+/*****************/
+
+class PacketDelayTimer : public QueuedTimer {
+    
+ public:
+    PacketDelayTimer(GPSR_Agent *a_, int size) : QueuedTimer(size) 
+	{ a = a_; }
+    void handle();
+    void deleteInfo(void* info);
+
+ private:
+    GPSR_Agent *a; 
+    
+};
+
+class GPSRSendBufferTimer : public TimerHandler {
+
+ public:
+    GPSRSendBufferTimer(GPSR_Agent *a): TimerHandler() { a_ = a; }
+    void expire(Event *e);
+
+ protected:
+    GPSR_Agent *a_;
+
+};
+
+class GPSR_BeaconTimer : public TimerHandler {
+
+ public:
+    GPSR_BeaconTimer(GPSR_Agent *a_) { a = a_; }
+    virtual void expire(Event *);
+
+ protected:
+    GPSR_Agent *a;
+};
+
+class GPSR_LastPeriTimer : public TimerHandler {
+
+ public:
+    GPSR_LastPeriTimer(GPSR_Agent *a_) { a = a_; }
+    virtual void expire(Event *);
+    
+ protected:
+    GPSR_Agent *a;
+};
+
+class GPSR_PlanarTimer : public TimerHandler {
+
+ public:
+    GPSR_PlanarTimer(GPSR_Agent *a_) { a = a_; }
+    virtual void expire(Event *);
+
+ protected:
+    GPSR_Agent *a;
+};
+
+
+class GPSR_DeadNeighbTimer : public TimerHandler {
+
+ public:
+    GPSR_DeadNeighbTimer(GPSR_Agent *a_, NeighbEnt *ne_) 
+	{ a = a_; ne = ne_; }
+    virtual void expire(Event *);
+    
+ protected:
+    GPSR_Agent *a;
+    NeighbEnt *ne;
+};
+
+class GPSR_PeriProbeTimer : public TimerHandler {
+
+ public:
+    GPSR_PeriProbeTimer(GPSR_Agent *a_, NeighbEnt *ne_)
+	{ a = a_; ne = ne_; }
+    virtual void expire(Event *);
+    
+ protected:
+    GPSR_Agent *a;
+    NeighbEnt *ne;
+};
+
+class GPSRBeaconDelayTimer : public TimerHandler {
+
+ public:
+    GPSRBeaconDelayTimer(GPSR_Agent *a_) { a = a_; }
+    virtual void expire(Event *);
+
+ protected:
+    GPSR_Agent *a;
+};
+
+class GPSRBeaconReqDelayTimer : public TimerHandler {
+
+ public:
+    GPSRBeaconReqDelayTimer(GPSR_Agent *a_) { a = a_; }
+    virtual void expire(Event *);
+
+ protected:
+    GPSR_Agent *a;
+};
+
+/******************/
+/* Neighbor Entry */
+/******************/
+
+class NeighbEnt {
+
+ public:
+     NeighbEnt(GPSR_Agent *ina) :
+	 peri(NULL), perilen(0), maxlen(0), dnt(ina, this), ppt(ina, this)
+       {
+       };
+	
+     void planarize(class NeighbTable *, int, double, double, double); /** [HMF] Screen this edge */
+
+     int closer_pt(nsaddr_t myip, double myx, double myy, double myz,
+		   double ptx, double pty, nsaddr_t ptipa, nsaddr_t ptipb,
+		   double dstx, double dsty, double *closerx, double *closery);
+     
+     
+     nsaddr_t dst;	   //**< [HMF] IP of neighbor
+     double x, y, z;       //**< [HMF] location of neighbor last heard
+     double ts;            //**< [HMF] timestamp of location information
+     struct PeriEnt *peri; //**< [HMF] Perimeter via this neighbor
+     int perilen;	   //**< [HMF] length of perimeter
+     int maxlen;	   //**< [HMF] allocated slots in peri
+     int live;	           //**< [HMF] when planarizing, whether edge should be used
+     int load;	           //**< [MT] Load on MAC layer (802.11) at this neighbor (= 0..100)
+     GPSR_DeadNeighbTimer dnt; //**< [HMF] timer for expiration of neighbor
+     GPSR_PeriProbeTimer ppt;  //**< [HMF] Timer for generation of perimeter probe to neighbor
+};
+
+/******************/
+/* Neighbor Table */
+/******************/
+/** Array that is ordered by destination addr and holds the NeighbEnts */
+
+class NeighbTable {
+
+ public:
+     NeighbTable(GPSR_Agent *mya);
+     ~NeighbTable();
+    
+     void ent_delete(const NeighbEnt *ent);          //** Delete an entry
+     void planarize(int, int, double, double, double);          //** Remove all crossing edges
+
+     inline double norm(double tmp_bear){
+       double to_norm = tmp_bear;
+       while(to_norm <= 0)
+	 to_norm += 2*M_PI;
+       return to_norm;
+     }
+
+     inline double norm_rev(double tmp_bear){
+       double to_norm = tmp_bear;
+       while(to_norm >= 0)
+	 to_norm -= 2*M_PI;
+       return to_norm;
+     }
+	    
+     NeighbEnt *ent_add(const NeighbEnt *ent); //** [HMF] Add an entry
+     NeighbEnt *ent_finddst(nsaddr_t dst);           //** [HMF] Find an entry by his destination address
+
+     // Neighbor Functions
+     class NeighbEnt *ent_findshortest       //** Find Closest
+	 (MobileNode *mn, double x, double y, double z);
+     class NeighbEnt *ent_findshortest_cc    //** Find Closest with congestion control 
+	 (MobileNode *mn, double x, double y, double z, double alpha);
+     class NeighbEnt *ent_findshortestXcptLH //** Find Closest that is not the LastHop
+	 (MobileNode *mn, nsaddr_t lastHopId, double x, double y, double z);
+
+     //** [HMF] Iterating through every table on peri and return the first
+     //*  hop on the perimeter that is close to the destination than
+     //*  itself 
+     class NeighbEnt *ent_findcloser_onperi
+	 (MobileNode *mn, double x, double y, double z, int *perihop);
+     class NeighbEnt *ent_findcloser_edgept
+	 (MobileNode *, double, double, nsaddr_t, nsaddr_t, double, double, double *, double *);
+     class NeighbEnt *ent_next_ccw(MobileNode *, NeighbEnt *, int);
+     class NeighbEnt *ent_next_ccw(double, double, double, int, NeighbEnt * = 0);
+     class NeighbEnt *ent_findface(MobileNode *, double, double, double, int);
+     NeighbTableIter InitLoop(); 
+     class NeighbEnt *NextLoop(NeighbTableIter *);
+     class NeighbEnt *ent_findnext_onperi(MobileNode *, int, double, double, double, int);
+     class NeighbEnt *ent_findnextcloser_onperi(MobileNode *mn, double dx, double dy, double dz);
+     int meanLoad();         //**< calculates the mean load of all neighbors in this table
+     inline int noEntries() {return nents;}
+     
+     /**set for planarization, entries are valid edges*/
+     bool counter_clock;
+     
+     DHeapEntry *val_item;
+     DHeap *valid;
+     int itedge;
+ protected:
+  friend class NeighbEnt;
+
+ private:
+
+     int nents;		     //** Entries currently in use
+     int maxents;	     
+     GPSR_Agent *a;    
+     NeighbEnt **tab;
+};
+
+/**************/
+/* GPSR Agent */
+/**************/
+
+class GPSR_Agent : public Tap, public Agent {
+
+ public:
+    GPSR_Agent(void);
+    
+    // Timer called Functions
+    void beacon_callback(void);	                   // generate a beacon (timer-triggered)
+    void deadneighb_callback(class NeighbEnt *ne); // neighbor gone (timer/MAC-trig)
+    void periprobe_callback(class NeighbEnt *ne);  // gen perimeter probe (timer-trig)
+    void lastperi_callback(void);	           // turn off peri probes when unused for timeout
+    void planar_callback(void);	                   // planarization callback
+#ifdef SPAN
+    void span_callback(void);                      // SPAN callback
+#endif
+
+    virtual int command(int argc, const char * const * argv);
+    void lost_link(Packet *p);
+    void tap(const Packet *p);
+
+    // Additions
+    const inline int isActive() { return(active_); } 
+    void sleep();  /** [HMF] This functions lays the Agent to rest */
+    void wake();   /** [HMF] This functions wakes the Agent up and reinits its times  */
+
+    void allow(unsigned int pktType) { send_allowed[pktType] = true; }
+    void block(unsigned int pktType) { send_allowed[pktType] = false; }
+    bool allowedToSend(unsigned int pktType) { return (send_allowed[pktType]); }
+
+ protected:
+
+    bool send_allowed[GPSR_PKT_TYPES]; //**< array with permission value to send pkttype
+
+    int off_gpsr_;		 //**< offset of the GPSR packet header in pkt 
+    int use_mac_;		 //**< whether or not to simulate full MAC level 
+    int use_peri_;		 //**< whether or not to use perimeters 
+    int verbose_;		 //**< verbosity (binary) 
+    int active_;                 //**< specifies if node is active [HMF] 
+    int drop_debug_;		 //**< whether or not to be verbose on NRTE events 
+    int peri_proact_;		 //**< whether or not to pro-actively send pprobes 
+    int use_implicit_beacon_;	 //**< whether or not all data packetsare beacons 
+    int use_planar_;		 //**< whether or not to planarize graph 
+    int use_loop_detect_;	 //**< whether or not to fix loops in peridata pkts 
+    int use_timed_plnrz_;	 //**< whether or not to replanarize w/timer 
+    int use_beacon_;             //**< whether or not to do beacons at all [MK]
+    int use_congestion_control_; //**< whether or not to ship load information with beacons [MT] 
+    int use_reactive_beacon_;    //**< whether or not to use reactive beaconing [MK]
+    int locservice_type_;        //**< which Location Service should be used [MK]
+    double bint_;		 //**< beacon interval 
+    double bdesync_;		 //**< beacon desync random component range 
+    double bexp_;		 //**< beacon expiration interval 
+    double pint_;		 //**< perimeter probe interval 
+    double pdesync_;		 //**< perimeter probe desync random cpt. range 
+    double lpexp_;		 //**< perimeter probe generation timeout
+    double cc_alpha_;		 //**< parameter for congestion control [MT]
+    int use_span_;               //**< whether or not to use span services [CL]
+
+    friend class NeighbEnt;
+    class MobileNode *mn_;	        //**< MobileNode 
+    class PriQueue *ifq_;	        //**< InterfaceQueue [MK]
+    class Mac *m;                       //**< MAC
+    class Trace *tracetarget;		//**< Trace Target
+    class LocationService *locservice_; //**< LocationService [MK]
+    class NeighbTable *ntab_;           //**< Neighbor Table
+
+    class GPSR_BeaconTimer   *beacon_timer_;   //**< Alive Beacon Timer
+    class GPSR_LastPeriTimer *lastperi_timer_; //**< Last Perimeter Used Timer
+    class GPSR_PlanarTimer   *planar_timer_;   //**< Inter-Planarization Timer
+    class PacketDelayTimer   *pd_timer;        //**< Packet Delay Timer [MK]
+
+    GPSRSendBufferTimer send_buf_timer;
+    GPSRSendBufEntry send_buf[SEND_BUF_SIZE];
+    
+    // Reactive Beaconing
+    class GPSRBeaconDelayTimer    *beacon_delay_;    //**< Min Delay between two Beacons
+    class GPSRBeaconReqDelayTimer *beaconreq_delay_; //**< Min Delay between two Beacon Reqs
+
+    friend class PacketDelayTimer;
+    friend class GPSRSendBufferTimer;
+
+    friend class NeighbTable;
+
+    virtual void recv(Packet *, Handler *);
+    void trace(char *fmt, ...);
+    void tracepkt(Packet *, double, int, const char *);
+    void init();
+
+    void forwardPacket(Packet *, int = 0);      //**< Forwarding Packets (Way too big for one function :( )
+    void periIn(Packet *, hdr_gpsr *, int = 0);
+    int hdr_size(Packet* p);                    //**< [MK] Handles everything size related  
+    int crosses(class NeighbEnt *, hdr_gpsr *);
+    int getLoad();				//**< [MT] recalculate my own load (using neighbors')
+    
+    // Beaconing Functions
+    void beacon_proc(int, double, double, double, int = -1);
+    void recvBeacon(Packet*);                   //**< [MK] receive and evaluate Beacon
+    void recvBeaconReq(Packet*);                //**< [MK] receive Beacon Request
+    void sendBeacon(double = 0.0);        //**< [MK] send Beacon
+    void sendBeaconRequest();                   //**< [MK] send Beacon request
+    void checkGreedyCondition(const Packet*);   //**< [MK] check if node is a Greedy Neighbor to src
+
+    // SendBuffer Functions
+    void notifyPos(nsaddr_t);
+    void stickPacketInSendBuffer(Packet *p);
+    void dropSendBuff(Packet *& p, const char*);
+    void sendBufferCheck();
+    void Terminate();
+    double sendbuf_interval() {
+      return BUFFER_CHECK;
+    }
+
+};
+
+#endif //_GPSR_h
diff -u -r --new-file ./hls/cellbuilder.h ../../ns-2.33-hls_working/ns-2.33/hls/cellbuilder.h
--- ./hls/cellbuilder.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/cellbuilder.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,46 @@
+#ifndef Cellbuilder_h
+#define Cellbuilder_h
+
+#ifdef VISUALIZER
+#include "datastructures.h"
+#else
+
+#include "../locservices/hdr_locs.h"
+#endif
+#define NO_VALID_LEVEL -1
+/* this is the basic class for building the cells
+   it should never be instatiated, it just gives the 
+   prototypes of the methods
+*/
+
+class Cellbuilder 
+{
+  public:
+
+  Cellbuilder(double radiorange, double fieldsize_x, double fieldsize_y)
+    {
+      this->radiorange = radiorange;
+      this->x = fieldsize_x;
+      this->y = fieldsize_y;
+    }
+  
+  virtual int getCellID (position position){return -1;};
+  
+  virtual int getRegion (position position, int level){return -1;};
+  
+  virtual int getRC (int nodeid, int level, position position){return -1;};
+  
+  virtual position getPosition (int cellid){return position();};
+
+  virtual int getMaxLevel(){return -1;}
+
+  virtual void getNeighborCells(int cellid, int* number, int** result)
+    {return;};
+  
+ private:
+  double radiorange;
+  double x;
+  double y; 
+};
+#endif
+
diff -u -r --new-file ./hls/.directory ../../ns-2.33-hls_working/ns-2.33/hls/.directory
--- ./hls/.directory	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/.directory	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,2 @@
+[URL properties]
+ViewMode=konq_textview
diff -u -r --new-file ./hls/hls_advanced.cc ../../ns-2.33-hls_working/ns-2.33/hls/hls_advanced.cc
--- ./hls/hls_advanced.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/hls_advanced.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,319 @@
+#include "hls_basic.h"
+#include "../gpsr/gpsr.h"
+
+
+// AHM AdvancedHandoverManager //////////////////////////////////////
+AdvancedHandoverManager::AdvancedHandoverManager(HLSLocationCache* activeEntries, 
+					   HLSLocationCache* passiveEntries,
+					   HLSLocationCache* outOfCellEntries,
+					   HLS* hls,
+					   Cellbuilder* cellbuilder)
+  : HandoverManager(activeEntries, passiveEntries, outOfCellEntries, 
+		    hls, cellbuilder)
+{}
+
+// will be called whenever HLS receives a handover packet.
+// (also if we are not in the correct cell!)
+// if the forceActiveSave flag is set, it means that we MUST put the
+// information in the packet in the activeEntries (normally because
+// there is no better node for the routing than our node and the
+// packet will otherwise be dropped)
+void AdvancedHandoverManager::recv(Packet* &p, bool forceActiveSave)
+{
+  hdr_hls* hlsh = HDR_HLS(p);
+
+  position destPos;
+  position myPos;
+  // getting my actual position
+  hls_->mn_->getLoc(&myPos.x, &myPos.y, &myPos.z);
+  // getting the destination of the update package
+  destPos = hlsh->cell.pos;
+
+  if(sameCell(&destPos, &myPos, hls_->cellbuilder_))
+    {
+      if(hls_trace_handovers)
+	{
+	  int myCell = hls_->cellbuilder_->getCellID(myPos);
+	  // HLS Handover real receive
+	  hls_->trace("HLS_H_rr  %.12f %d<-%d [%.2f %.2f <%d>] <%d %.2f %.2f> %d", 
+		      Scheduler::instance().clock(), // timestamp
+		      hls_->addr(),                  // address of update receiver
+		      HDR_IP(p)->saddr(),            // address of the previous info owner
+		      myPos.x,                       // my...
+		      myPos.y,                       // coordinates
+		      myCell,                        // my cell
+		      hlsh->cell.id,                 // target cell
+		      destPos.x,                     // center...
+		      destPos.y,                     // of the target cell	   
+		      hlsh->numberOfNodeinfosToHandover);
+	}
+
+      nodeposition* data = (nodeposition*) p->accessdata();
+      for(int i=0;i<hlsh->numberOfNodeinfosToHandover;i++) {      
+	activeEntries_->add(&data[i]);
+	//	printf("targetcell %d sendingnode %d\n", data[i].targetcell, data[i].id);
+      }
+      // we have been in the cell, thus we can free the packet.
+      // this will tell gpsr that the packet arrived
+      Packet::free(p);
+      p = NULL;
+      return;
+    }
+  
+  if(forceActiveSave)
+    {
+      if(hls_trace_handovers)
+	{
+	  int myCell = hls_->cellbuilder_->getCellID(myPos);
+	  // HLS Handover forced receive
+	  hls_->trace("HLS_H_fr  %.12f %d<-%d [%.2f %.2f <%d>] <%d %.2f %.2f> %d", 
+		      Scheduler::instance().clock(), // timestamp
+		      hls_->addr(),                  // address of update receiver
+		      HDR_IP(p)->saddr(),            // address of the previous info owner
+		      myPos.x,                       // my...
+		      myPos.y,                       // coordinates
+		      myCell,                        // my cell
+		      hlsh->cell.id,                 // target cell
+		      destPos.x,                     // center...
+		      destPos.y,                     // of the target cell	      
+		      hlsh->numberOfNodeinfosToHandover);
+	}
+      nodeposition* data = (nodeposition*) p->accessdata();
+      for(int i=0;i<hlsh->numberOfNodeinfosToHandover;i++) {      
+	outOfCellEntries_->add(&data[i]);
+     
+      }      
+      // we have been in the cell, thus we can free the packet.
+      // this will tell gpsr that the packet arrived
+      Packet::free(p);
+      p = NULL;
+      return;
+    }
+
+#ifdef AGGRESSIVE_CACHING
+  // we are not in the same cell and no forced 
+  // saving, thus just store in the passive entries
+  passiveEntries_->add(&hlsh->src);
+#endif
+} // end of AHM::recv(..)
+
+void AdvancedHandoverManager::timerCallback()
+{
+  int actualCell = hls_->getCell();
+  if(actualCell != lastCell)
+    {
+      // the entries in activeEntries will only be checked if
+      // we really changed our cell since the last timerCallback
+      checkCacheAndTransmit(activeEntries_, actualCell);
+    }		
+  // the entries of which we know that they aren't in the correct cell
+  // must be checked
+  checkCacheAndTransmit(outOfCellEntries_, actualCell);
+
+  lastCell = actualCell;
+}
+
+
+// gets the table of the cache, checks if the entries belong to the 
+// cell actualCell and if not, construct a packet and try to 
+// send it to the destination cell
+void AdvancedHandoverManager::checkCacheAndTransmit(HLSLocationCache* cache, int actualCell)
+{
+  // we have changed the cell, thus we must search the activeEntries
+  // for information which must be handed over to our old cell
+  unsigned int size;
+  CHCEntry** table = cache->getTable(&size);
+
+  int arraysize = 20;
+  int index = 0;
+  nodeposition *tmparray 
+    = (nodeposition *)calloc(arraysize, sizeof(nodeposition));
+  if(tmparray == NULL)
+    {
+      printf("out of memory in AdvancedHandoverManager::checkCacheAndTransmit\n");
+      exit(-1);
+    }
+				  // = new nodeposition[arraysize];
+  // end workaround declaration (more code inloop)
+  // activeEntries nach eintren durchsuchen, die nicht in actualCell
+  // gehen.
+  // Walk through Table
+  for (unsigned int i=0; i<size; i++) {
+    if (table[i] != NULL) {
+      CHCEntry* tmp = table[i];
+      while (tmp != NULL) 
+	{	  
+	  nodeposition* tmpinfo = (nodeposition*)tmp->info;
+	  
+	  if(tmpinfo->targetcell != actualCell)
+	    {
+	      // we have to copy the info to a tmp variable:
+	      // if we would handover the info and can't find a better node
+	      // than our one, the routing will hand the packet pack to 
+	      // the locservice to put it in activeEntries. There, it
+	      // will be stored, an afterwards deleted from us because
+	      // we thought to have successfully handed over the info ...
+	      // to avoid this, copy the info, delete it from activeEntries
+	      // and then hand it over (possibly to ourself)
+
+	      // deletion will be done after the for-loop
+	      tmparray[index].copyFrom(tmpinfo);
+	      index++;
+	      if(index >= arraysize)
+		{
+		  // we have to resize the array
+		  arraysize = arraysize*2;
+		  nodeposition *tmp
+		    = (nodeposition *)realloc(tmparray, 
+					      sizeof(nodeposition)*arraysize);
+		    if(tmp == NULL)
+		      {
+			printf("out of memory in AHM:checkCacheAndTransmit\n");
+			exit(-1);
+		      }
+		    tmparray = tmp;
+		  printf("### resize tmparray in checkCacheAndTransmit node %d new size %d\n", hls_->addr(), arraysize);
+		}
+	    }		
+	  tmp = tmp->next;
+	}
+    } // end of while
+  } // end of for
+
+
+  if(index > 0)
+    {
+      bubblesort(tmparray, index);
+      int targetcell = tmparray[0].targetcell;
+      int startindex = 0;
+      int counter = 0;
+      for(int i=0;i<index;i++)
+	{
+	  // we delete the information here from the cache to avoid
+	  // conflicts in the loop over the table of the cache
+	  cache->remove(tmparray[i].id);
+
+	  if(tmparray[i].targetcell == targetcell)
+	    {
+	      // count how much entries with the same target cell exist
+	      counter++;
+	    }
+	  else
+	    {
+	      // the target cell has changed, thus transmit the information
+	      // with the same target cell in one big packet and go on
+	      handoverInformation(&tmparray[startindex], counter);
+	      targetcell = tmparray[i].targetcell;
+	      counter = 1;
+	      startindex = i;	      
+	    }
+	}
+      // also the last one needs to be handed over
+      handoverInformation(&tmparray[startindex], counter);
+    }
+  free(tmparray);
+} // end of AHM::checkCacheAndTransmit
+
+// this function is responsible for handing over the information
+// it constructs a packet and sends it to the target cell
+// (to the cell where the information should be)
+void AdvancedHandoverManager::handoverInformation(nodeposition* info, int numberOfInfos)
+{  
+  int numberOfInformationBytes = sizeof(nodeposition)*numberOfInfos;
+  Packet *pkt = hls_->allocpkt();
+  pkt->allocdata(numberOfInformationBytes);
+
+  struct hdr_ip *iph = HDR_IP(pkt);
+  struct hdr_cmn *cmnh = HDR_CMN(pkt);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+  struct hdr_hls *hlsh = HDR_HLS(pkt);
+
+  
+  iph->sport() = RT_PORT;
+  iph->dport() = RT_PORT;
+  iph->saddr() = hls_->parent->addr();
+  iph->daddr() = NO_NODE;
+
+  position cellPosition = cellbuilder_->getPosition(info->targetcell);
+  // Let GPSR route this pkt to the center of the responsible cell
+  // (or to the closest position possible)
+  iph->dx_ = cellPosition.x;
+  iph->dy_ = cellPosition.y;
+  iph->dz_ = cellPosition.z;
+
+  cmnh->ptype() = PT_HLS;
+  cmnh->addr_type_ = NS_AF_INET;
+  cmnh->num_forwards() = 0;
+  cmnh->next_hop_ = NO_NODE;
+  cmnh->direction() = hdr_cmn::DOWN;
+  cmnh->xmit_failure_ = 0;
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+
+  // init my own header
+  hlsh->init();
+  // now we have to put the actual position information into the
+  // packet (together with a timestamp)
+  nodeposition* data = (nodeposition*) pkt->accessdata();
+  memcpy(data, info, numberOfInformationBytes);
+  hlsh->numberOfNodeinfosToHandover = numberOfInfos;
+
+  hlsh->type_ = HLS_HANDOVER;
+
+  // set the cell field
+  hlsh->cell.id    = info->targetcell;
+  hlsh->cell.level = -1; //don't know the level in  the handover
+  hlsh->cell.pos.x = cellPosition.x;
+  hlsh->cell.pos.y = cellPosition.y;
+  hlsh->cell.pos.z = cellPosition.z;
+
+  if(hls_trace_handovers)
+    {
+      int myCell = hls_->getCell();
+      position cellPos = cellbuilder_->getPosition(myCell);
+
+      // HLS Handover send
+      hls_->trace("HLS_H_s   %.12f %d <%d %.2f %.2f> -> <%d %.2f %.2f> %d", 
+		  Scheduler::instance().clock(), // timestamp
+		  hls_->addr(),                  // address of handover sender
+		  myCell,                        // my cell
+		  cellPos.x,                     // my cell's position x ...
+		  cellPos.y,                     // and y
+		  info->targetcell,              // target cell
+		  cellPosition.x,                // the  
+		  cellPosition.y,                // coordinates of the cell      
+		  hlsh->numberOfNodeinfosToHandover);
+    }
+
+  hls_->parent->recv(pkt, NULL);  
+} // end of AHM::handoverInformation(...)
+
+
+
+
+
+
+
+
+void AdvancedHandoverManager::bubblesort(nodeposition* A, int size) {
+  if(size==1)
+    {
+      return;
+    }
+  for(int i=size;i>0;i--) {
+    for(int j=0;j<i-1;j++) {
+      if (A[j].targetcell > A[j+1].targetcell) {
+        exchange(&A[j], &A[j+1]);
+      }
+    }
+  }
+}
+
+void AdvancedHandoverManager::exchange(nodeposition* a, nodeposition* b)
+{
+  nodeposition tmp = *a;
+  *a = *b;
+  *b = tmp;
+}
diff -u -r --new-file ./hls/hls_basic.cc ../../ns-2.33-hls_working/ns-2.33/hls/hls_basic.cc
--- ./hls/hls_basic.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/hls_basic.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,2123 @@
+#include "hls_basic.h"
+#include "../gpsr/gpsr.h"
+
+// Header ////////////////////////////////////////////////
+ 
+class HLSHeaderClass : public PacketHeaderClass {
+public:
+    HLSHeaderClass() : PacketHeaderClass("PacketHeader/HLS",sizeof(hdr_hls)) {
+	bind_offset(&hdr_hls::offset_);
+    }
+} class_hlsheader;
+ 
+
+
+// UpdateSender ////////////////////////////////////////////
+UpdateSender::UpdateSender(Cellbuilder* cellbuilder, HLS* hls)
+{
+  cellbuilder_ = cellbuilder;
+  hls_ = hls; 
+}
+void UpdateSender::start(){}
+
+
+// UpdateReceiver //////////////////////////////////////////
+UpdateReceiver::UpdateReceiver(HLSLocationCache* activeEntries, 
+			       HLSLocationCache* passiveEntries, 
+			       HLSLocationCache* outOfCellEntries, 
+			       HLS* hls)
+{
+  this->activeEntries_ = activeEntries;
+  this->passiveEntries_ = passiveEntries;
+  this->outOfCellEntries_ = outOfCellEntries;
+  this->hls_ = hls;
+}
+
+void UpdateReceiver::recv(Packet* &p, bool forceActiveSave)
+{}
+
+// RequestProcessor ////////////////////////////////////////
+RequestProcessor::RequestProcessor(HLSLocationCache* passiveEntries, HLS* hls)
+{
+  this->passiveEntries_ = passiveEntries;
+  this->hls_ = hls;
+}
+
+void RequestProcessor::recv(Packet* &p)
+{}
+
+void RequestProcessor::processRequestUnreachableCell(Packet* &p)
+{}
+
+// this method is called when a request for location information
+// is flooded in the cell
+// 
+void RequestProcessor::recvCellcastRequest(Packet* &p)
+{}
+
+void RequestProcessor::cellcastReplyOnMacReceived(const Packet* p)
+{}
+void RequestProcessor::recvCirclecastRequest(Packet* &p, 
+					     bool fromDropCallback)
+{}
+
+void RequestProcessor::circlecastRequestOnMacReceived(const Packet* p)
+{}
+
+void RequestProcessor::recvCellcastReply(Packet* &p)
+{}
+// produces a reply packet to a location query
+// when A wants to know the location of B and the request 
+// reaches B after the routing, this is the answer packet
+Packet* RequestProcessor::newReply(Packet* req, struct nodeposition* infosrc) {
+
+    Packet *pkt = hls_->allocpkt();
+	
+    struct hdr_ip *req_iph = HDR_IP(req);
+    struct hdr_hls *req_hlsh = HDR_HLS(req);
+
+    struct hdr_hls *hlsh = HDR_HLS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+
+    hlsh->init();
+    hlsh->type_ = HLS_REPLY;
+
+    hlsh->src.id = infosrc->id;
+    hlsh->src.ts = infosrc->ts;
+    hlsh->src.pos = infosrc->pos;
+ 
+    hlsh->dst.id = req_hlsh->src.id;
+    hlsh->dst.ts = req_hlsh->src.ts;
+    hlsh->dst.pos = req_hlsh->src.pos;
+
+    // request id
+    hlsh->reqid.set(req_hlsh->reqid);
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = hls_->addr();
+    // the destination is not the ip-source of the packet
+    // (because this can also be someone who sent a request to
+    // a higher level cell) but the request source of the packet
+    iph->daddr() = req_hlsh->src.id;// req_iph->saddr();
+    iph->ttl() = 128;
+
+    iph->dx_ = req_hlsh->src.pos.x;
+    iph->dy_ = req_hlsh->src.pos.y;
+    iph->dz_ = req_hlsh->src.pos.z;
+
+    cmnh->ptype() = PT_HLS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Requests need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    gpsrh->geoanycast = false;
+    
+    return pkt;
+} // end of RequestProcessor::newReply(...)
+
+
+// this produces a reply to a cellcast request
+// it means that the sender of the reply is the src in the req packet
+// and the information is in info
+void RequestProcessor::sendCellcastReply(const Packet* req, 
+					 struct nodeposition* info)
+{
+    Packet *pkt = hls_->allocpkt();
+	
+    struct hdr_ip *req_iph = HDR_IP(req);
+    struct hdr_hls *req_hlsh = HDR_HLS(req);
+
+    struct hdr_hls *hlsh = HDR_HLS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+
+    hlsh->init();
+    hlsh->type_ = HLS_CELLCAST_REPLY;
+
+    // enter my position (the infos of the node who answers the
+    // request)
+    hlsh->src.id = hls_->addr();
+    hlsh->src.ts = Scheduler::instance().clock();
+    position pos;
+    hls_->mn_->getLoc(&pos.x, &pos.y, &pos.z);
+    hlsh->src.pos = pos;
+    // request id
+    hlsh->reqid = req_hlsh->reqid;
+
+    // enter the position of the node about which we had information
+    // (stored in info)
+    hlsh->dst.copyFrom(info);
+
+    // write the id of the node who send the cellcast request
+    hlsh->cellcastRequestSender = req_hlsh->cellcastRequestSender;
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = hls_->addr();
+    // the destination of the reply packet is the node who sent the
+    // CELLCAST_REQUEST
+    iph->daddr() = req_iph->saddr();
+    
+    iph->ttl() = HLS_TTL;
+
+    iph->dx_ = req_hlsh->src.pos.x;
+    iph->dy_ = req_hlsh->src.pos.y;
+    iph->dz_ = req_hlsh->src.pos.z;
+
+    cmnh->ptype() = PT_HLS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Requests need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    gpsrh->geoanycast = false;
+    
+    if(hls_verbose)
+      {
+	struct hdr_hls* hlsh = HDR_HLS(pkt);
+	// HLS CELLCAST send (answer)
+	hls_->trace("HLS_CC_sa %.12f (%d_%d) %d -> %d [%d %.5f %.2f %.2f]", 
+		    Scheduler::instance().clock(), // timestamp
+		    hlsh->reqid.node,        // the unique...
+		    hlsh->reqid.nr,          // id of the request
+		    hls_->addr(),                  // my address 
+		    hlsh->cellcastRequestSender,// the one who asked
+		    hlsh->dst.id,            // the info we got
+		    hlsh->dst.ts,            // info timestamp
+		    hlsh->dst.pos.x,         // the position ...		  
+		    hlsh->dst.pos.y);        // of the node
+      } 
+    hls_->parent->recv(pkt, NULL);
+}
+
+
+
+// HandoverTimer
+// responsible for periodically calling the timerCallback function
+// in the HandoverManager which will check if we have left
+// a cell a must therefore handover the information belonging to
+// that cell
+HandoverTimer::HandoverTimer(HandoverManager* manager, 
+			     double intervall)
+{
+  this->manager_ = manager;
+  this->intervall_ = intervall;
+}
+
+void HandoverTimer::expire(Event* e)
+{
+  manager_->timerCallback();
+  double delay = Random::uniform(HLS_HANDOVER_JITTER);
+  resched(intervall_ + delay); // reschedule the timer after the intervall
+}
+// end of HandoverTimer
+
+// Handovermanager
+HandoverManager::HandoverManager(HLSLocationCache* activeEntries, 
+				 HLSLocationCache* passiveEntries,
+				 HLSLocationCache* outOfCellEntries,
+				 HLS* hls,
+				 Cellbuilder* cellbuilder)
+{
+  this->hls_ = hls;
+  this->activeEntries_ = activeEntries;
+  this->passiveEntries_ = passiveEntries;
+  this->outOfCellEntries_ = outOfCellEntries;
+  this->cellbuilder_ = cellbuilder;
+  this->timer_ = new HandoverTimer(this, HLS_HANDOVER_INTERVALL);
+  double delay = Random::uniform(2*HLS_HANDOVER_JITTER);
+  timer_->sched(HLS_HANDOVER_INTERVALL+delay);
+  lastCell = -1;
+}
+
+HandoverManager::~HandoverManager()
+  {
+    delete timer_;
+  }
+// end of HandoverManager
+
+// BUS /////////////////////////////////////////////////////
+BasicUpdateSender::BasicUpdateSender(Cellbuilder* cellbuilder, HLS* hls)
+  : UpdateSender(cellbuilder, hls)
+{
+  updateIntervall_ =  HLS_UPDATE_CHECK_INTERVALL; // seconds
+  timer_ = new BUSTimer(this, updateIntervall_);
+  lastUpdatePosition_ = new nodeposition[cellbuilder->getMaxLevel()];
+
+  for(int i=0;i<cellbuilder->getMaxLevel();i++)
+    {
+      lastUpdatePosition_[i].pos.x = -999;
+      lastUpdatePosition_[i].pos.y = -999;
+      lastUpdatePosition_[i].pos.z = -999;
+      lastUpdatePosition_[i].ts = -1;
+      lastUpdatePosition_[i].targetcell = -1;
+    }
+
+  upd_reason = "";
+}
+
+BasicUpdateSender::~BasicUpdateSender()
+{
+  delete timer_;
+  delete lastUpdatePosition_;
+}
+
+void BasicUpdateSender::start()
+{
+  double delay = Random::uniform(HLS_UPDATE_STARTUP_MAX_JITTER);
+  timer_->sched(HLS_UPDATE_STARTUP+delay); 
+}
+
+void BasicUpdateSender::timerExpired()
+{
+  int level = 1;
+  position pos = position();
+  hls_->mn_->getLoc(&pos.x, &pos.y, &pos.z); // writes the correct posinfos
+  // to pos
+  
+  int address = hls_->addr();
+  int responsibleCell = cellbuilder_->getRC(address, level, pos);
+
+  while(responsibleCell != NO_VALID_LEVEL)
+    {
+      double dx = (pos.x - lastUpdatePosition_[level-1].pos.x); dx *= dx;
+      double dy = (pos.y - lastUpdatePosition_[level-1].pos.y); dy *= dy; 
+      double distance = sqrt(dx+dy);// contains the distance between the actual point and
+      // the last sending point to the given level;
+      
+      // level-1 as index because indexing starts at 0, the levels start at 1
+      if(lastUpdatePosition_[level-1].targetcell != responsibleCell)
+	{
+	  // we have on the actual level another RC, thus tell this RC
+	  // that we exist
+	  upd_reason = "NWRC"; // new RC
+	  lastUpdatePosition_[level-1] = sendUpdatePacketToCell(responsibleCell, level);
+	}
+      else if(distance >= HLS_UPDATE_DISTANCE)
+	{
+	  upd_reason = "DIST"; // distance
+	  lastUpdatePosition_[level-1] = sendUpdatePacketToCell(responsibleCell, level);
+	}
+#ifdef TIME_TRIGGERED_UPDATES_FOR_SECOND_HIGHEST_LEVEL
+      // time triggerd for cell on second highest level
+      else if((level == (cellbuilder_->getMaxLevel()-1)) &&
+	      (lastUpdatePosition_[level-1].ts + (2*HLS_MAX_UPDATE_INTERVALL)) 
+	      < Scheduler::instance().clock())
+	{	  
+	  // send a time triggerd update to the cell on the second highest level     
+	  upd_reason = "TIME";
+	  lastUpdatePosition_[level-1] = sendUpdatePacketToCell(responsibleCell, level);
+	}
+#endif
+      // time triggered for top level cell
+      else if((level == cellbuilder_->getMaxLevel()) &&
+	      (lastUpdatePosition_[level-1].ts + HLS_MAX_UPDATE_INTERVALL) 
+	      < Scheduler::instance().clock())
+	{
+	  // we are on the highest level and it was long ago that we've send an update to the
+	  // top level cell
+	  upd_reason = "TIME";
+	  lastUpdatePosition_[level-1] = sendUpdatePacketToCell(responsibleCell, level);	  
+	}
+
+      level++;
+      responsibleCell = cellbuilder_->getRC(hls_->addr(), level, pos); 
+    }
+}
+
+// produces an update packet with the destination of the given cell
+nodeposition BasicUpdateSender::sendUpdatePacketToCell(int cellid, int level)
+{
+  Packet *pkt = hls_->allocpkt();
+
+  //////////////////////////////////////////
+  // produce the packet
+  /////////////////////////////////////////
+
+  struct hdr_ip *iph = HDR_IP(pkt);
+  struct hdr_cmn *cmnh = HDR_CMN(pkt);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+  struct hdr_hls *hlsh = HDR_HLS(pkt);
+
+  
+  iph->sport() = RT_PORT;
+  iph->dport() = RT_PORT;
+  iph->saddr() = hls_->parent->addr();
+  iph->daddr() = NO_NODE;
+
+  position cellPosition = cellbuilder_->getPosition(cellid);
+  // Let GPSR route this pkt to the center of the responsible cell
+  // (or to the closest position possible)
+  iph->dx_ = cellPosition.x;
+  iph->dy_ = cellPosition.y;
+  iph->dz_ = cellPosition.z;
+  iph->ttl() = HLS_UPDATE_TTL_PER_LEVEL * level;
+
+  cmnh->ptype() = PT_HLS;
+  cmnh->addr_type_ = NS_AF_INET;
+  cmnh->num_forwards() = 0;
+  cmnh->next_hop_ = NO_NODE;
+  cmnh->direction() = hdr_cmn::DOWN;
+  cmnh->xmit_failure_ = 0;
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+
+  // init my own header
+  hlsh->init();
+  // now we have to put the actual position information into the
+  // packet (together with a timestamp)
+  nodeposition actualNodepos = hls_->getNodeInfo();
+  actualNodepos.targetcell = cellid;
+  hlsh->src.copyFrom(&actualNodepos);
+
+  hlsh->type_ = HLS_UPDATE;
+
+  // set the cell field
+  hlsh->cell.id    = cellid;
+  hlsh->cell.level = level;
+  hlsh->cell.pos.x = cellPosition.x;
+  hlsh->cell.pos.y = cellPosition.y;
+  hlsh->cell.pos.z = cellPosition.z;
+
+  // the reason
+  hlsh->updreason_ = upd_reason;
+
+  //////////////////////////////////////////////////////////
+  // end of packet production
+  //////////////////////////////////////////////////////////
+  if(hls_trace_updates)
+    {
+      position pos;
+      pos = cellbuilder_->getPosition(cellid);
+      // HLS Update
+      hls_->trace("HLS_UPD_s %.12f %d <%d %.2f %.2f (%d)> %s", 
+		  Scheduler::instance().clock(), // timestamp
+		  hls_->addr(),                  // address of update sender
+		  cellid,                        // target cell
+		  pos.x,                         // the  
+		  pos.y,                         // coordinates of the cell
+		  level,                         // level of the cell      
+		  upd_reason);                   // the reason for the update
+      
+    }
+
+  //////////////////////////////////////////////////////////////////////
+  // send the packet
+  /////////////////////////////////////////////////////////////////////
+
+  hls_->parent->recv(pkt, NULL);
+
+  return actualNodepos;
+}
+
+//BUR //////////////////////////////////////////////////////
+BasicUpdateReceiver::BasicUpdateReceiver(HLSLocationCache* activeEntries, 
+					 HLSLocationCache* passiveEntries, 
+					 HLSLocationCache* outOfCellEntries,
+					 HLS* hls)
+  : UpdateReceiver(activeEntries, passiveEntries, outOfCellEntries, hls){};
+
+
+// this method is called whenever an update message is received at
+// this node. If the forceActiveSave flag is set, this means that 
+// the packet must be put in the active store. This is necessary
+// when the correct cell for the update packet can't be reached.
+// (then, this recv-method will be called from the callback method
+// in HLS). During the next round of active store checks (when it is
+// checked if we are still in the correct cell or if we have to 
+// give the entries to a neighbour), the routing tries to sent the 
+// update to a node which is closer to (or in) the destination cell.
+void BasicUpdateReceiver::recv(Packet* &p, bool forceActiveSave)
+{
+  hdr_hls* hlsh = HDR_HLS(p);
+
+#ifdef AGGRESSIVE_CACHING
+  passiveEntries_->add(&hlsh->src);
+#endif
+
+  position destPos;
+  position myPos;
+  // getting my actual position
+  hls_->mn_->getLoc(&myPos.x, &myPos.y, &myPos.z);
+  // getting the destination of the update package
+  destPos = hlsh->cell.pos;
+  // test
+  if(hlsh->src.targetcell == hls_->getCell() && 
+     !sameCell(&destPos, &myPos, hls_->cellbuilder_))
+    {
+      printf("### holy shit!error in sameCell calculation\n");
+      exit(-1);
+    }
+  // endtest
+  if(sameCell(&destPos, &myPos, hls_->cellbuilder_))
+    {
+      if(hls_trace_updates)
+	{
+	  int myCell = hls_->cellbuilder_->getCellID(myPos);
+	  if(hlsh->type_ == HLS_UPDATE)
+	    {
+	      // HLS Update receive
+	      hls_->trace("HLS_UD_r  %.12f %d<-%d [%.2f %.2f <%d>] <%d %.2f %.2f (%d)>", 
+			  Scheduler::instance().clock(), // timestamp
+			  hls_->addr(),                  // address of update receiver
+			  hlsh->src.id,                  // address of update sender
+			  myPos.x,                       // my...
+			  myPos.y,                       // coordinates
+			  myCell,                        // my cell
+			  hlsh->cell.id,                 // target cell
+			  destPos.x,                     // center...
+			  destPos.y,                     // of the target cell
+			  hlsh->cell.level);             // the level of that cell
+	    }
+	}
+
+      activeEntries_->add(&hlsh->src);
+      // we have been in the cell, thus we can free the packet.
+      // this will tell gpsr that the packet arrived
+      Packet::free(p);
+      p = NULL;
+      return;
+    }
+  
+  if(forceActiveSave)
+    {
+      if(hls_trace_updates)
+	{
+	  int myCell = hls_->cellbuilder_->getCellID(myPos);
+	  if(hlsh->type_ == HLS_UPDATE)
+	    {
+	      // HLS Update forced receive
+	      hls_->trace("HLS_UD_fr %.12f %d<-%d [%.2f %.2f <%d>] <%d %.2f %.2f (%d)>", 
+			  Scheduler::instance().clock(), // timestamp
+			  hls_->addr(),                  // address of update receiver
+			  hlsh->src.id,                  // address of update sender
+			  myPos.x,                       // my...
+			  myPos.y,                       // coordinates
+			  myCell,                        // my cell
+			  hlsh->cell.id,                 // target cell
+			  destPos.x,                     // center...
+			  destPos.y,                     // of the target cell
+			  hlsh->cell.level);             // the level of that cell
+	    }
+	}
+
+
+      outOfCellEntries_->add(&hlsh->src);
+      // we have been in the cell, thus we can free the packet.
+      // this will tell gpsr that the packet arrived
+      Packet::free(p);
+      p = NULL;
+      return;
+    }  
+}// end of BUR::recv(..)
+
+// BRP /////////////////////////////////////////////////////
+BasicRequestProcessor::BasicRequestProcessor( HLSLocationCache* passiveEntries, HLS* hls)
+  : RequestProcessor(passiveEntries, hls)
+{
+  cellcastRequestCache_ = new CellcastRequestCache(10, this);
+  circlecastRequestCache_ = new CirclecastRequestCache(5, this);
+  answerTimerList_ = NULL;
+}
+
+BasicRequestProcessor::~BasicRequestProcessor()
+{
+
+  delete cellcastRequestCache_;
+  delete circlecastRequestCache_;
+  AnswerTimer* tmp1 = answerTimerList_;
+  AnswerTimer* tmp2;
+  while(tmp1 != NULL)
+    {
+      tmp2 = tmp1;
+      tmp1 = tmp1->next;
+      delete(tmp2);
+    }
+}
+
+// this method is called when we receive a request packet
+void BasicRequestProcessor::recv(Packet* &p)
+{
+  
+    struct hdr_hls *hlsh = HDR_HLS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+     
+    // Don't process my own requests
+    if ((iph->saddr() == hls_->parent->addr()) && (cmnh->num_forwards() == 0)) { return; }
+
+    // checking for correct cell is done later
+    // (so, the answer can also be given from the cache)
+    // first check if we know the answer, if yes, => reply
+    // if we don't know the answer, check if it's the correct cell
+    
+    
+    // Request query is for me, answer it
+    if (hlsh->dst.id == hls_->parent->addr()) {
+      
+      struct nodeposition info;
+      info.id = hls_->parent->addr();
+      info.ts = Scheduler::instance().clock();
+      hls_->mn_->getLoc(&info.pos.x, &info.pos.y, &info.pos.z);
+
+      if(hls_verbose)
+	{
+	  // HLS Request answer
+	  hls_->trace("HLS_REQ_a %.12f (%d_%d) %d -> %d", 
+		      Scheduler::instance().clock(), // timestamp
+		      hlsh->reqid.node,              // the unique...
+		      hlsh->reqid.nr,                // id of the request
+		      hls_->addr(),                  // my address 
+		      hlsh->src.id);                 // address of request sender
+	}
+      
+      Packet *pkt = newReply(p,&info);
+      Packet::free(p);
+      // schedule the answer
+      hls_->parent->recv(pkt, NULL);      
+      p = NULL;
+                  
+      return;
+    }
+    
+
+    // in the destination cell, there are different possibilities:
+    // - I know the info and can forward the request to the node
+    // - I have to broadcast the request in the cell and wait for a reply
+    //     * positive reply: send it to the node
+    //     * negative reply: send it to the next RC or drop the reqeust
+    //       if I'm the home cell on the highest level
+
+    nodeposition* nodepos = hls_->findEntry(hlsh->dst.id);
+
+    if(nodepos != NULL)
+      {
+	// this means we have information about the position
+	// of the requested node
+	// forward the request to the position of that node
+	if(nodepos->ts < hlsh->dst.ts)
+	  {
+	    // if our info is older than the one we receive, we update
+	    // our info (implicit update)
+	    nodepos->ts    = hlsh->dst.ts;
+	    nodepos->pos.x = hlsh->dst.pos.x;
+	    nodepos->pos.y = hlsh->dst.pos.y;
+	    nodepos->pos.z = hlsh->dst.pos.z;
+	    return;
+	  }
+	else
+	  {
+	    if(hls_verbose)
+	      { 
+		position myPos;
+		hls_->mn_->getLoc(&myPos.x, &myPos.y, &myPos.z);
+		int myCell = hls_->cellbuilder_->getCellID(myPos);
+		// HLS Request located (we have found a posinfo for the node)
+		hls_->trace("HLS_REQ_l %.12f (%d_%d) %d ->%d [%.5f %.2f %.2f] <%d %d (%d)>", 
+			    Scheduler::instance().clock(), // timestamp
+			    hlsh->reqid.node,              // the unique...
+			    hlsh->reqid.nr,                // id of the request
+			    hls_->addr(),                  // my address 
+			    hlsh->dst.id,                  // address of target
+			    nodepos->ts,                   // timestamp of entry
+			    nodepos->pos.x,                // coordinates...
+			    nodepos->pos.y,                // of the entry
+			    myCell,                        // my cell id
+			    hlsh->cell.id,                 // the target cell of the request
+			    hlsh->cell.level);             // the target level
+	      }	
+	    // write the target position to the ip-header for the routing
+	    iph->dx_ = nodepos->pos.x;
+	    iph->dy_ = nodepos->pos.y;
+	    iph->dz_ = nodepos->pos.z;
+	    
+	    // write the information to the hls-header to enable relocation
+	    // (that means when a packet passes a node with newer location 
+	    // info, the info in the packet will be updated)
+	    hlsh->dst.ts = nodepos->ts;
+	    hlsh->dst.pos.x = nodepos->pos.x;
+	    hlsh->dst.pos.y = nodepos->pos.y;
+	    hlsh->dst.pos.z = nodepos->pos.z;
+
+	    //
+	    if(hlsh->status_ != REQUEST_LOCATED)
+	      {
+		// depending on the level on which the information was
+		// located, the TTL is very low. From now on, the packet
+		// will be directed to the node which may be many hops
+		// away, thus we need to reset the TTL to enable reaching
+		// far away nodes
+		iph->ttl() = HLS_TTL;
+		hlsh->status_ = REQUEST_LOCATED;
+	      }
+	    
+	    return;
+	  }
+      }
+
+    // if we arrive here, we haven't had any information about
+    // the position of the node
+
+    // if our node isn't member of the destination cell,
+    // let the routing do it's work
+    position myPos;
+    hls_->mn_->getLoc(&myPos.x, &myPos.y, &myPos.z);
+    
+    if(!sameCell(&myPos, &hlsh->cell.pos, hls_->cellbuilder_ ))
+      {
+      if(hls_verbose)
+	{
+	  // HLS Request forward
+	  hls_->trace("HLS_REQ_f %.12f (%d_%d) %d ->...->%d", 
+		      Scheduler::instance().clock(), // timestamp
+		      hlsh->reqid.node,              // the unique...
+		      hlsh->reqid.nr,                // id of the request
+		      hls_->addr(),                  // my address 
+		      hlsh->dst.id);                 // target address
+	}
+	return;
+      }
+
+    if(hls_->cellbuilder_->getCellID(myPos) != hlsh->cell.id)
+      {
+	printf("### error during resolving cellid\n");
+      }
+
+    // if we arrive here, we are in the same cell but don't 
+    // know the position of the node. this means
+    // we have to broadcast the request to the cell (marking 
+    // it as broadcast to avoid infinite recursion) and process
+    // the reply (if there is info, sending the request to the
+    // node, if there isn't info, send the request to the
+    // cell on the next level or if we are the highest level,
+    // drop the request)
+
+    cellcastRequestCache_->store(p, CELLCAST_BUFFER_ENTRY_TIMEOUT);
+    sendCellcastRequest(hlsh->dst.id, hlsh->reqid, &hlsh->cell);
+
+    // we must set the packet to NULL because we are the destination
+    // if we'd return it to the routing, it would be dropped because
+    // of no route and the place would be freed/ reserved for another
+    // packet
+    p = NULL;
+}
+
+// sends a request for information about the given node
+// if another node in transmission range has information
+// about the location of node nodeid, it'll answer;
+// if not, no answer packet is sent
+void BasicRequestProcessor::sendCellcastRequest(int nodeid, request_id reqid, 
+						struct_cell* cell)
+{
+  if(hls_verbose)
+    {
+      // HLS CELLCAST send request
+      hls_->trace("HLS_CC_sr %.12f (%d_%d) %d -*%d", 
+		  Scheduler::instance().clock(), // timestamp
+		  reqid.node,                    // the unique...
+		  reqid.nr,                      // id of the request
+		  hls_->addr(),                  // my address 
+		  nodeid);                       // target address
+    }
+
+  Packet *p = hls_->allocpkt();
+  
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  struct hdr_ip *iph = HDR_IP(p);
+  struct hdr_cmn *cmnh = HDR_CMN(p);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+  gpsrh->nhops_ = 1;
+
+  hls_->mn_->getLoc(&gpsrh->hops_[0].x, 
+		    &gpsrh->hops_[0].y, 
+		    &gpsrh->hops_[0].z);
+  
+  cmnh->ptype_ = PT_HLS;
+  cmnh->next_hop_ = IP_BROADCAST;
+  cmnh->addr_type_ = NS_AF_INET;
+
+  iph->daddr() = IP_BROADCAST << Address::instance().nodeshift();
+  iph->dport() = RT_PORT;
+
+  hlsh->type_ = HLS_CELLCAST_REQUEST;
+
+  hls_->mn_->getLoc(&hlsh->src.pos.x, 
+		    &hlsh->src.pos.y, 
+		    &hlsh->src.pos.z);
+  hlsh->src.id = hls_->addr();
+  hlsh->src.ts = Scheduler::instance().clock();
+  hlsh->dst.id = nodeid;   // set the id of the requested node
+  // set the cell information
+  hlsh->cell.id    = cell->id;
+  hlsh->cell.level = cell->level;
+  hlsh->cell.pos.x = cell->pos.x;
+  hlsh->cell.pos.y = cell->pos.y;
+  hlsh->cell.pos.z = cell->pos.z;  
+
+  // the request id
+  hlsh->reqid = reqid;
+
+  // my node is the sender of the request
+  hlsh->cellcastRequestSender = hls_->addr();
+
+  Scheduler::instance().schedule(hls_->target_, p, 0);
+} // end of sendCellcastRequest
+
+void BasicRequestProcessor::recvCellcastRequest(Packet* &p)
+{
+  // If the node knows something, he will respond.
+  // If not, no respond is send, because we don't want to overload the network.
+  // Keep up work after the first timeout in sender of cellcastRequest
+
+  struct hdr_hls *hlsh = HDR_HLS(p);
+
+  nodeposition* nodepos = hls_->findEntry(hlsh->dst.id);
+  
+  if(nodepos != NULL)
+    {
+ 
+      double timeout;
+      if(hlsh->dst.id == hls_->addr())
+	{
+	  // optimization:
+	  // if our own node is requested, we answer directly 
+	  // without waiting
+	  sendCellcastReply(p, nodepos);	  
+	  Packet::free(p);
+	}
+      else
+	{	
+	  // make the timer also depending of the age of the information
+	  // (this means if we have a relatively new info, we 
+	  // answer earlier than if we have an old info)
+	  timeout = Random::uniform(CELLCAST_ANSWER_JITTER);
+	  // schedule the timer to send our answer if we haven't heard another
+	  // one answering in the meantime
+	  CellcastAnswerTimer* tmpTimer = new CellcastAnswerTimer(this, timeout, p,
+								  nodepos);
+	  // put the timer in the list
+	  tmpTimer->next = answerTimerList_;
+	  answerTimerList_ = tmpTimer;
+	}
+    }
+  else
+    {
+      Packet::free(p);
+    }
+
+  p = NULL;
+}
+
+// this method is called when we receive a cellcast reply on MAC, that means
+// someone send a reply. We don't know if we are the target of that reply,
+// the processing of this will be done in the function recvCellcastReply
+void BasicRequestProcessor::cellcastReplyOnMacReceived(const Packet* p)
+{
+  struct hdr_hls* hlsh = HDR_HLS(p);
+  struct hdr_ip* iph = HDR_IP(p);
+
+  if(hlsh->cellcastRequestSender != hls_->addr())
+    {
+      // I haven't sent the request, but I can try to cache the
+      // location
+#ifdef AGGRESSIVE_CACHING
+      passiveEntries_->add(&hlsh->dst);
+#endif
+
+
+      // search the answer timer list to see if we also have
+      // scheduled an answer packet. If so, we'll eliminate the
+      // packet (and the timer)
+      AnswerTimer* tmpTimer = answerTimerList_;
+      AnswerTimer* secondTmpTimer;
+      AnswerTimer* last = NULL;
+      
+      while(tmpTimer != NULL)
+	{
+
+	  if(tmpTimer->status() != TIMER_PENDING)// the timer has already expired
+	    {
+	      // this code is for freeing the memory.
+	      secondTmpTimer = tmpTimer->next;
+	      if(answerTimerList_ == tmpTimer)
+		{
+		  answerTimerList_ = tmpTimer->next;
+		} 
+	      if(last != NULL)
+		{
+		  last->next = secondTmpTimer;
+		}
+	      
+	      // we can remove the timer from our list
+	      delete(tmpTimer);
+	      tmpTimer = secondTmpTimer;
+	      continue;
+	    }
+
+
+	  if(tmpTimer->reqId_.equals(&hlsh->reqid)) // we have a pending timer
+	    {
+		if(tmpTimer->status() == TIMER_PENDING)
+		  {
+		    tmpTimer->cancel();
+		  }
+		// after canceling the timer, we can remove it
+		secondTmpTimer = tmpTimer->next;
+		if(answerTimerList_ == tmpTimer)
+		  {
+		    answerTimerList_ = tmpTimer->next;
+		  }
+		if(last != NULL)
+		  {
+		    last->next = secondTmpTimer;
+		  }
+		
+		// trace that we wanted to send but didn't do so because
+		// another node sent his answer earliere
+		if(hls_verbose)
+		  {
+		    struct hdr_hls* hlsh = tmpTimer->getHlsHeaderOfPacket();
+
+		    hls_->trace("HLS_CC_da %.12f (%d_%d) %d -> %d [%d %.5f %.2f %.2f]", 
+				Scheduler::instance().clock(), // timestamp
+				hlsh->reqid.node,        // the unique...
+				hlsh->reqid.nr,          // id of the request
+				hls_->addr(),                  // my address 
+				hlsh->cellcastRequestSender,// the one who asked
+				hlsh->dst.id,            // the info we got
+				hlsh->dst.ts,            // info timestamp
+				hlsh->dst.pos.x,         // the position ...		  
+				hlsh->dst.pos.y);        // of the node		    
+		  }
+		
+		delete(tmpTimer);
+		tmpTimer = secondTmpTimer;
+		continue;
+	      }
+	  last = tmpTimer;
+	  tmpTimer = tmpTimer->next;       
+	}
+    }
+}
+
+// we received a cellcast reply (and are the real destination of it)
+void BasicRequestProcessor::recvCellcastReply(Packet* &p)
+{
+  struct hdr_hls* hlsh = HDR_HLS(p);
+  struct hdr_ip* iph = HDR_IP(p);
+
+  if((hlsh->cellcastRequestSender != hls_->addr())) 
+    // we haven't send the request for this reply
+    {
+      return;
+    }
+
+  if(hls_verbose)
+    {
+      // HLS CELLCAST receive (answer)
+      hls_->trace("HLS_CC_ra %.12f (%d_%d) %d <-%d [%d %.5f %.2f %.2f]", 
+		  Scheduler::instance().clock(), // timestamp
+		  hlsh->reqid.node,        // the unique...
+		  hlsh->reqid.nr,          // id of the request
+		  hls_->addr(),                  // my address 
+		  hlsh->src.id,            // the one who answered
+		  hlsh->dst.id,            // the info we got
+		  hlsh->dst.ts,            // info timestamp
+		  hlsh->dst.pos.x,         // the position ...		  
+		  hlsh->dst.pos.y);        // of the node
+    }
+
+
+  // we have to get the appropriate Request from my cache and
+  // forward it to the destination address
+  Packet* requestPacket = cellcastRequestCache_->getRequest(hlsh->reqid);
+  if(requestPacket == NULL)
+    {
+      // we use the cellcast reply also for the circlecast replies
+      requestPacket = circlecastRequestCache_->getRequest(hlsh->reqid);
+    }
+
+  if(requestPacket != NULL)
+    {
+      // the result of the query is at the moment stored in "dst"
+      passiveEntries_->add(&hlsh->dst);
+      // give it to the routing to go on
+      hls_->parent->recv(requestPacket, NULL);      
+    }
+
+  // I have been the target of the packet, thus setting it to null
+  Packet::free(p);
+  p = NULL;
+}
+
+// is called by HLS when we receive a circlecast request with our
+// node as destination. This method is just responsible for 
+// the forwarding of the packet, the answers will be generated in
+// the method "circlecastRequestOnMacReceived()"
+// a) because we have been directly addressed
+// b) there is not better way and the packet should be dropped.
+// In case a), we check if we are in the correct cell, if so, we
+// send the packet to the next cell in the list, if not, we just 
+// give it back.
+// In case b) we send it directly to the next cell.
+void BasicRequestProcessor::recvCirclecastRequest(Packet* &p, 
+						  bool fromDropCallback)
+{
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  struct hdr_ip *iph = HDR_IP(p);
+ 
+  position myPos;
+  hls_->mn_->getLoc(&myPos.x, &myPos.y, &myPos.z);
+  
+  // we are in the correct cell or the cell couldn't be 
+  // reached by the routing:
+  if(sameCell(&myPos, &hlsh->cell.pos, hls_->cellbuilder_ ) ||
+     fromDropCallback ||
+     iph->ttl() <= 0)
+    // the ttl thing is necessary because we also get a dropPacketCallback
+    // from a TTL expiration: 
+    // the result would be that we do a HLS_CIC_f in the else branch,
+    // the TTL is negative (and is only dropped if TTL == 0), thus it
+    // loops until eternity...
+    {
+      // next cell
+      hlsh->neighborIndex++;  
+      int nextCell = NO_CELL;
+      if(hlsh->neighborIndex < NUMBER_OF_NEIGHBOR_CELLS)
+	{
+	  nextCell = hlsh->neighbors[hlsh->neighborIndex];
+	}
+      // there is no next cell
+      if(nextCell == -1)
+	{
+	  if(hls_verbose)
+	    {
+	      // HLS Circle cast drop
+	      hls_->trace("HLS_CIC_d %.12f (%d_%d) %d ->...->%d", 
+			  Scheduler::instance().clock(), // timestamp
+			  hlsh->reqid.node,              // the unique...
+			  hlsh->reqid.nr,                // id of the request
+			  hls_->addr(),                  // my address 
+			  hlsh->dst.id);                 // target address
+	    }
+	  Packet::free(p);
+	  p = NULL;
+	  return;
+	}
+      else
+	{
+	  position cellPosition 
+	    = hls_->cellbuilder_->getPosition(nextCell);
+
+	  iph->dx_ = cellPosition.x;
+	  iph->dy_ = cellPosition.y;
+	  iph->dz_ = cellPosition.z;
+	  iph->ttl() = 10;
+
+	  // set the cell field
+	  hlsh->cell.init();
+	  hlsh->cell.id    = nextCell;
+	  hlsh->cell.level = -1;
+	  hlsh->cell.pos.x = cellPosition.x;
+	  hlsh->cell.pos.y = cellPosition.y;
+	  hlsh->cell.pos.z = cellPosition.z;
+
+	  hls_->parent->recv(p, NULL);
+	  p = NULL;
+	}
+    }
+  else
+    {
+      if(hls_verbose)
+	{
+	  // HLS Circle cast next cell
+	  hls_->trace("HLS_CIC_f %.12f (%d_%d) %d ->...->%d <%d>", 
+		      Scheduler::instance().clock(), // timestamp
+		      hlsh->reqid.node,              // the unique...
+		      hlsh->reqid.nr,                // id of the request
+		      hls_->addr(),                  // my address 
+		      hlsh->dst.id,                  // target address
+		      hlsh->neighbors[hlsh->neighborIndex]); // traget cell
+	}
+    }
+}
+
+
+void BasicRequestProcessor::circlecastRequestOnMacReceived(const Packet* p)
+{
+ 
+  struct hdr_hls *hlsh = HDR_HLS(p);
+
+  // just look in the active entries (that means only the real 
+  // location servers will answer the request)
+  nodeposition* nodepos = hls_->findActiveEntry(hlsh->dst.id);
+  
+  if(nodepos != NULL)
+    {
+      double timeout;
+      if(hlsh->dst.id == hls_->addr())
+	{
+	  // optimization:
+	  // if our own node is requested, we answer directly 
+	  // without waiting
+	  sendCellcastReply(p, nodepos);
+	}
+      else
+	{	  
+	  // first we go through the list and check if we have already set up
+	  // a timer for this request. If so, we won't schedule another one
+	  AnswerTimer* list = answerTimerList_;
+	  while(list != NULL)
+	    {
+	      // this comparison should be based on other parameters than the 
+	      // request ID (the circlecast request does not contain this info
+	      // according to the hdr_size function). Sender of the circlecast
+	      // and target node should function with the same success (this
+	      // also identifies a request, a circlecast sender would not send
+	      // a circlecast packet twice but wait for an answer)
+	      if(list->reqId_.equals(&hlsh->reqid))
+		{
+		  // don't schedule a timer because there is already one
+		  return;
+		}
+	      list = list->next;
+	    }
+	  // we haven't had a timer, thus schedule an answer
+	  
+	  timeout = Random::uniform(CELLCAST_ANSWER_JITTER);
+	  // schedule the timer to send our answer if we haven't heard another
+	  // one answering in the meantime
+	  CirclecastAnswerTimer* tmpTimer = new CirclecastAnswerTimer(this, timeout, p,
+								  nodepos);
+	  // put the timer in the list
+	  tmpTimer->next = answerTimerList_;
+	  answerTimerList_ = tmpTimer;
+	}
+    }
+}
+
+
+// sends a request packet to the first cell in the cell list
+// When it arrives there, it will be forwarded to the next 
+// cell until it has visited all cells in the list.
+// When a node in radiorange receives the request (he listens on
+// the mac) and knows something about the position of the requested
+// node, it'll send a cellcast answer to the node which initiated
+// the circel request.
+void BasicRequestProcessor::sendCirclecastRequest(int nodeid, request_id reqID, 
+						  int* cells)
+{
+  Packet *p = hls_->allocpkt();
+  
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  struct hdr_ip *iph = HDR_IP(p);
+  struct hdr_cmn *cmnh = HDR_CMN(p);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+ 
+  iph->sport() = RT_PORT;
+  iph->dport() = RT_PORT;
+  iph->saddr() = hls_->addr(); // I am the originator of the packet
+  iph->daddr() = NO_NODE;
+  iph->ttl()   = HLS_TTL;
+
+  position cellPosition = hls_->cellbuilder_->getPosition(cells[0]);
+
+  // TRACE
+  if(hls_verbose)
+    {
+      // HLS Request circle cast send
+      hls_->trace("HLS_CIC_s %.12f (%d_%d) %d ->%d <%d,%d,%d,%d,%d,%d,%d,%d>", 
+		  Scheduler::instance().clock(), // timestamp
+		  reqID.node,                    // address of requestor
+		  reqID.nr,                      // local number of the request
+		  hls_->addr(),                  // my address
+		  nodeid,                        // target node
+		  cells[0],                      // destination cells
+		  cells[1],
+		  cells[2],
+		  cells[3],
+		  cells[4],
+		  cells[5],
+		  cells[6],
+		  cells[7]);
+    }
+
+
+  // Let GPSR route this pkt to the center of the responsible cell
+  iph->dx_ = cellPosition.x;
+  iph->dy_ = cellPosition.y;
+  iph->dz_ = cellPosition.z;
+
+  cmnh->ptype() = PT_HLS;
+  cmnh->addr_type_ = NS_AF_INET;
+  cmnh->num_forwards() = 0;
+  cmnh->next_hop_ = NO_NODE;
+  cmnh->direction() = hdr_cmn::DOWN;
+  cmnh->xmit_failure_ = 0;
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+
+  // out node is the source of the packet
+  nodeposition tmpPos = hls_->getNodeInfo();
+  hlsh->src.copyFrom(&tmpPos);
+
+  hlsh->type_ = HLS_CIRCLECAST_REQUEST;
+
+  // set the cell field
+  hlsh->cell.init();
+  hlsh->cell.id    = cells[0];
+  hlsh->cell.level = -1;
+  hlsh->cell.pos.x = cellPosition.x;
+  hlsh->cell.pos.y = cellPosition.y;
+  hlsh->cell.pos.z = cellPosition.z;
+  
+  // put the id of the requested node in the packet
+  hlsh->dst.id = nodeid;
+
+  // the unique id for the request
+  hlsh->reqid  = reqID;
+
+  // we are the sender of the circelcast request
+  hlsh->cellcastRequestSender = hls_->addr();
+
+  // put the list of cells which we have to reach in the packet
+  for(int i=0;i<NUMBER_OF_NEIGHBOR_CELLS;i++)
+    {
+      hlsh->neighbors[i] = cells[i];       
+    }
+  // the first cell in the list will be the fist target
+  hlsh->neighborIndex = 0;
+  
+  // call the recv function of the node to give it to the routing
+  hls_->parent->recv(p, NULL);  
+}
+
+
+// called when the routing hasn't been able to forward the request
+// to the responsible cell or when a cellcast failed (due to a timeout
+// of the cellcast). We have to direct the request
+// to the cell on the next level, trace the complete failure of
+// the request when we are already on the highest level or send a
+// circle cast request
+void BasicRequestProcessor::processRequestUnreachableCell(Packet* &p_old)
+{
+  struct hdr_hls *hlsh_old = HDR_HLS(p_old);
+
+  if(hls_verbose)
+    { 
+      position pos;
+      hls_->mn_->getLoc(&pos.x, &pos.y, &pos.z);
+
+      // HLS Request unreachable (cell)
+      hls_->trace("HLS_REQ_u %.12f (%d_%d) %d (%.2f %.2f) <%d %.2f %.2f (%d)>", 
+		  Scheduler::instance().clock(), // timestamp
+		  hlsh_old->reqid.node,              // the unique...
+		  hlsh_old->reqid.nr,                // id of the request	 
+		  hls_->addr(),                  // my address 
+		  pos.x,                         // my position
+		  pos.y,
+		  hlsh_old->cell.id,                 // id of target cell
+		  hlsh_old->cell.pos.x,              // position ...
+		  hlsh_old->cell.pos.y,              // of the cell
+		  hlsh_old->cell.level);             // level of the cell 
+    }
+
+  if((hlsh_old->status_ == REQUEST_LOCATED) &&
+     ((Scheduler::instance().clock() - hlsh_old->dst.ts) < HLS_MAX_CACHE_LOOKUP_AGE))
+    {
+      position pos;
+      hls_->mn_->getLoc(&pos.x, &pos.y, &pos.z);
+      struct hdr_hls *hlsh = HDR_HLS(p_old);
+      hlsh_old->status_ = REQUEST_LOCATED_AND_RETRIED;
+      // determine the distance between me and the last known location of the
+      // node
+      double deltaX = pos.x - hlsh->dst.pos.x;
+      double deltaY = pos.y - hlsh->dst.pos.y;
+      double totalDistance = sqrt((deltaX*deltaX)+(deltaY*deltaY));
+      if(totalDistance < God::instance()->getRadioRange())
+	{
+	  if(hls_verbose)
+	    {
+	      // HLS Request forced forward
+	      hls_->trace("HLS_RQ_ff %.12f (%d_%d) %d ->...->%d", 
+			  Scheduler::instance().clock(), // timestamp
+			  hlsh_old->reqid.node,              // the unique...
+			  hlsh_old->reqid.nr,                // id of the request
+			  hls_->addr(),                  // my address 
+			  hlsh_old->dst.id);                 // target address
+	    }
+	  // if we are in radiorange of the last known position, 
+	  // there is a high possibility that also
+	  // the target of the request is in our radiorange but we don't 
+	  // know it (e.g. because the beacons were lost). Thus we try to
+	  // send it "manually" without using the routing agent.
+	  struct hdr_ip *iph = HDR_IP(p_old);	  
+	  struct hdr_cmn *cmh = HDR_CMN(p_old);
+	  iph->daddr() = hlsh_old->dst.id;
+	  iph->ttl() = 1; // drop packet if we don't reach it on the next hop
+	  iph->dx_ = hlsh_old->dst.pos.x;
+	  iph->dy_ = hlsh_old->dst.pos.y;
+	  iph->dz_ = hlsh_old->dst.pos.z;
+
+	  cmh->direction() = hdr_cmn::DOWN;
+	  cmh->next_hop_ = hlsh_old->dst.id;
+	  // give the packet directly to the MAC layer
+	  hls_->target_->recv(p_old, (Handler *)0);
+	  return;
+	}
+      // if we aren't in radiorange, the packet will be dropped as LNR
+    }
+
+  if(hlsh_old->status_ == REQUEST_LOCATED_AND_RETRIED)
+    {
+      TRACE_CONN(p_old,hls_->addr(),hls_->addr(),hlsh_old->dst.id);
+      // we have already located the position and the information is young
+      // enough to be accurate
+      dropAndTraceRequestPacket(p_old, LOCATED_AND_NO_ROUTE);
+      return;
+    }
+
+  // determine the RC for the given node
+  position pos;
+  hls_->mn_->getLoc(&pos.x, &pos.y, &pos.z);
+  int level = hlsh_old->cell.level + 1;
+  int targetNode = hlsh_old->dst.id;
+
+  int responsibleCell = hls_->cellbuilder_->getRC(targetNode, level, pos);
+
+  if(responsibleCell == NO_VALID_LEVEL)
+    {
+      // prepare the circlecast request
+      int number;
+      int* neighbors;
+      if(hlsh_old->circleCastAlreadySend == true)
+	{
+	  dropAndTraceRequestPacket(p_old, CIRCELCAST_ALREADY_SEND);
+	  return;
+	}
+      hls_->cellbuilder_->getNeighborCells(hlsh_old->cell.id, &number, &neighbors);
+      
+      // we still have to put the neighbor cells in a better order
+      int myCell = hls_->cellbuilder_->getCellID(pos);
+      int index = -1;
+      for(int i=0;i<number;i++)
+	{
+	  if(neighbors[i] == myCell)
+	    {
+	      index = i;
+	      break;
+	    }
+	}
+      
+      if(index != -1)
+	{
+	  int* tmp = new int[number];
+	  int counter = 0;
+	  // copy the middle part
+	  for(int i=index;i<number;i++)
+	    {
+	      if(neighbors[i] != -1)
+		{
+		  tmp[counter] = neighbors[i];
+		  counter++;
+		}
+	    }
+	  // copy the lower part
+	  for(int i=0;i<index;i++)
+	    {
+	      tmp[counter] = neighbors[i];
+	      counter++;
+	    }
+
+	  // fill the rest with NO_CELL
+	  while(counter < number)
+	    {
+	      tmp[counter] = NO_CELL;
+	      counter++;
+	    }
+	  free(neighbors);
+	  neighbors = tmp;
+	}
+      // end of putting the neighbors in a better order
+
+      circlecastRequestCache_->store(p_old, CIRCLECAST_ENTRY_TIMEOUT);
+      sendCirclecastRequest(targetNode, hlsh_old->reqid, neighbors);
+      hlsh_old->circleCastAlreadySend = true;
+      free(neighbors);
+      return;
+    }
+
+
+  // produce a new packet which will be sent to the next-level RC
+  // no reuse of the old one because of possible problems with the packetnumber
+  // e.g. it arrives at a router where it has already been, the router 
+  // thinks it's a routing loop and throws the packet away
+  Packet *p_next_level = hls_->allocpkt();
+  
+  struct hdr_hls *hlsh = HDR_HLS(p_next_level);
+  struct hdr_ip *iph = HDR_IP(p_next_level);
+  struct hdr_cmn *cmnh = HDR_CMN(p_next_level);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(p_next_level);
+ 
+  iph->sport() = RT_PORT;
+  iph->dport() = RT_PORT;
+  iph->saddr() = hls_->addr(); // I am the originator of the packet
+  iph->daddr() = NO_NODE;
+  
+  struct request_id reqID = hlsh_old->reqid;
+
+  position cellPosition = hls_->cellbuilder_->getPosition(responsibleCell);
+
+  // TRACE
+  if(hls_verbose)
+    {
+      // HLS Request next (level)
+      hls_->trace("HLS_REQ_n %.12f (%d_%d) %d ->%d <%d %.2f %.2f (%d)>", 
+		  Scheduler::instance().clock(), // timestamp
+		  reqID.node,                    // address of requestor
+		  reqID.nr,                      // local number of the request
+		  hls_->addr(),                  // my address
+		  hlsh_old->dst.id,              // target node
+		  responsibleCell,               // destination cell
+		  cellPosition.x,                // x and y 
+		  cellPosition.y,                // of the center of the cell
+		  level);                        // level of the cell
+    }
+
+
+  // Let GPSR route this pkt to the center of the responsible cell
+  iph->dx_ = cellPosition.x;
+  iph->dy_ = cellPosition.y;
+  iph->dz_ = cellPosition.z;
+  iph->ttl() = level * HLS_REQUEST_TTL_PER_LEVEL;
+
+  cmnh->ptype() = PT_HLS;
+  cmnh->addr_type_ = NS_AF_INET;
+  cmnh->num_forwards() = 0;
+  cmnh->next_hop_ = NO_NODE;
+  cmnh->direction() = hdr_cmn::DOWN;
+  cmnh->xmit_failure_ = 0;
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+
+  // put the info from the old packet in the new one
+  hlsh->src.copyFrom(&hlsh_old->src);
+
+  hlsh->type_ = HLS_REQUEST;
+
+  // set the cell field
+  hlsh->cell.init();
+  hlsh->cell.id    = responsibleCell;
+  hlsh->cell.level = level;
+  hlsh->cell.pos.x = cellPosition.x;
+  hlsh->cell.pos.y = cellPosition.y;
+  hlsh->cell.pos.z = cellPosition.z;
+  
+  // put the id of the requested node in the packet
+  hlsh->dst.id = hlsh_old->dst.id;
+
+  // the unique id for the request
+  hlsh->reqid  = reqID;
+
+  // call the recv function of the node to give it to the routing
+  hls_->parent->recv(p_next_level, NULL);
+
+  Packet::free(p_old);
+  return;
+}
+
+void BasicRequestProcessor::cellcastTimerCallback(Packet* p)
+{
+  if(hls_verbose)
+    {
+      // HLS CELLCAST timeout
+      hls_->trace("HLS_CC_to %.12f (%d_%d) %d -*%d", 
+		  Scheduler::instance().clock(), // timestamp
+		  HDR_HLS(p)->reqid.node,        // the unique...
+		  HDR_HLS(p)->reqid.nr,          // id of the request
+		  hls_->addr(),                  // my address 
+		  HDR_HLS(p)->dst.id);           // target address
+    }
+  processRequestUnreachableCell(p);
+}
+
+// when this method is called it means that also the circlecast
+// has failed:
+// thus we drop the request and declare it to have failed
+void BasicRequestProcessor::dropAndTraceRequestPacket(Packet* p, char *reason)
+{
+  // after returning, the packet will be dropped and freed
+  if(hls_verbose)
+    { 
+      position pos;
+      hls_->mn_->getLoc(&pos.x, &pos.y, &pos.z);
+      struct hdr_hls *hlsh = HDR_HLS(p);
+      // HLS Request drop 
+      // idev = information deviation, how old is our info
+      // mydev = how far the dropping node is away from the (actual pos)
+      //         of the target
+      hls_->trace("HLS_REQ_d %.12f (%d_%d) %d (%d) %s idev %.2f mydev %.2f metonode %.2f", 
+		  Scheduler::instance().clock(), // timestamp
+		  hlsh->reqid.node,        // the unique...
+		  hlsh->reqid.nr,          // id of the request
+		  hls_->addr(),                  // my address 	  
+		  hlsh->cell.level,        // the level on which we're 
+		  reason,
+		  // distance between the requested node and the info
+		  distance(hlsh->dst.id, hlsh->dst.pos),
+		  // distance between us and the position of the info
+		  distance(hls_->addr(), hlsh->dst.pos),
+		  // distance between me and the node
+		  distance(hlsh->dst.id, pos));
+      // dropping
+    }  
+  Packet::free(p);
+}
+
+// BHM BasicHandoverManager //////////////////////////////////////
+BasicHandoverManager::BasicHandoverManager(HLSLocationCache* activeEntries, 
+					   HLSLocationCache* passiveEntries,
+					   HLSLocationCache* outOfCellEntries,
+					   HLS* hls,
+					   Cellbuilder* cellbuilder)
+  : HandoverManager(activeEntries, passiveEntries, outOfCellEntries, 
+		    hls, cellbuilder)
+{}
+
+// will be called whenever HLS receives a handover packet.
+// (also if we are not in the correct cell!)
+// if the forceActiveSave flag is set, it means that we MUST put the
+// information in the packet in the activeEntries (normally because
+// there is no better node for the routing than our node and the
+// packet will otherwise be dropped)
+void BasicHandoverManager::recv(Packet* &p, bool forceActiveSave)
+{
+  hdr_hls* hlsh = HDR_HLS(p);
+
+  position destPos;
+  position myPos;
+  // getting my actual position
+  hls_->mn_->getLoc(&myPos.x, &myPos.y, &myPos.z);
+  // getting the destination of the update package
+  destPos = hlsh->cell.pos;
+  // test
+  if(hlsh->src.targetcell == hls_->getCell() && 
+     !sameCell(&destPos, &myPos, hls_->cellbuilder_))
+    {
+      printf("### holy shit! Method sameCell doesn't calculate correctly\n");
+      exit(-1);
+    }
+  // endtest
+  if(sameCell(&destPos, &myPos, hls_->cellbuilder_))
+    {
+      if(hls_trace_handovers)
+	{
+	  int myCell = hls_->cellbuilder_->getCellID(myPos);
+	  // HLS Handover real receive
+	  hls_->trace("HLS_H_rr  %.12f %d<-%d [%d] [%.2f %.2f <%d>] <%d %.2f %.2f>", 
+		      Scheduler::instance().clock(), // timestamp
+		      hls_->addr(),                  // address of update receiver
+		      HDR_IP(p)->saddr(),            // address of the previous info owner
+		      hlsh->src.id,                  // the node-if of the information
+		      myPos.x,                       // my...
+		      myPos.y,                       // coordinates
+		      myCell,                        // my cell
+		      hlsh->cell.id,                 // target cell
+		      destPos.x,                     // center...
+		      destPos.y);                    // of the target cell	   
+	}
+      
+      
+      activeEntries_->add(&hlsh->src);
+      // we have been in the cell, thus we can free the packet.
+      // this will tell gpsr that the packet arrived
+      Packet::free(p);
+      p = NULL;
+      return;
+    }
+  
+  if(forceActiveSave)
+    {
+      if(hls_trace_handovers)
+	{
+	  int myCell = hls_->cellbuilder_->getCellID(myPos);
+	  // HLS Handover forced receive
+	  hls_->trace("HLS_H_fr  %.12f %d<-%d [%d] [%.2f %.2f <%d>] <%d %.2f %.2f>", 
+		      Scheduler::instance().clock(), // timestamp
+		      hls_->addr(),                  // address of update receiver
+		      HDR_IP(p)->saddr(),            // address of the previous info owner
+		      hlsh->src.id,                  // address of update sender
+		      myPos.x,                       // my...
+		      myPos.y,                       // coordinates
+		      myCell,                        // my cell
+		      hlsh->cell.id,                 // target cell
+		      destPos.x,                     // center...
+		      destPos.y);                    // of the target cell	      
+	}
+      
+      outOfCellEntries_->add(&hlsh->src);
+      // we have been in the cell, thus we can free the packet.
+      // this will tell gpsr that the packet arrived
+      Packet::free(p);
+      p = NULL;
+      return;
+    }
+
+#ifdef AGGRESSIVE_CACHING
+  // we are not in the same cell and no forced 
+  // saving, thus just store in the passive entries
+  passiveEntries_->add(&hlsh->src);
+#endif
+} // end of BHM::recv(..)
+
+void BasicHandoverManager::timerCallback()
+{
+  int actualCell = hls_->getCell();
+  if(actualCell != lastCell)
+    {
+      // the entries in activeEntries will only be checked if
+      // we really changed our cell since the last timerCallback
+      checkCacheAndTransmit(activeEntries_, actualCell);
+    }		
+  // the entries of which we know that they aren't in the correct cell
+  // must be checked
+  checkCacheAndTransmit(outOfCellEntries_, actualCell);
+
+  lastCell = actualCell;
+}
+
+
+// gets the table of the cache, checks if the entries belong to the 
+// cell actualCell and if not, construct a packet and try to 
+// send it to the destination cell
+void BasicHandoverManager::checkCacheAndTransmit(HLSLocationCache* cache, int actualCell)
+{
+  // we have changed the cell, thus we must search the activeEntries
+  // for information which must be handed over to our old cell
+  unsigned int size;
+  CHCEntry** table = cache->getTable(&size);
+
+  int arraysize = 20;
+  int index = 0;
+  nodeposition *tmparray 
+    = (nodeposition *)calloc(arraysize, sizeof(nodeposition));
+  if(tmparray == NULL)
+    {
+      printf("out of memory in BasicHandoverManager::checkCacheAndTransmit\n");
+      exit(-1);
+    }
+				  // = new nodeposition[arraysize];
+  // end workaround declaration (more code inloop)
+
+
+  // search in activeEntries for Entries that do not belong in actualCell
+
+  // Walk through Table
+  for (unsigned int i=0; i<size; i++) {
+    if (table[i] != NULL) {
+      CHCEntry* tmp = table[i];
+      while (tmp != NULL) 
+	{	  
+	  nodeposition* tmpinfo = (nodeposition*)tmp->info;
+	  
+	  if(tmpinfo->targetcell != actualCell)
+	    {
+	      // we have to copy the info to a tmp variable:
+	      // if we would handover the info and can't find a better node
+	      // than our one, the routing will hand the packet pack to 
+	      // the locservice to put it in activeEntries. There, it
+	      // will be stored, an afterwards deleted from us because
+	      // we thought to have successfully handed over the info ...
+	      // to avoid this, copy the info, delete it from activeEntries
+	      // and then hand it over (possibly to ourself)
+
+	      // deletion will be done after the for-loop
+	      tmparray[index].copyFrom(tmpinfo);
+	      index++;
+	      if(index >= arraysize)
+		{
+		  // we have to resize the array
+		  arraysize = arraysize*2;
+		  nodeposition *tmp
+		    = (nodeposition *)realloc(tmparray, 
+					      sizeof(nodeposition)*arraysize);
+		    if(tmp == NULL)
+		      {
+			printf("out of memory in BHM:checkCacheAndTransmit\n");
+			exit(-1);
+		      }
+		    tmparray = tmp;
+		  printf("### resize tmparray in checkCacheAndTransmit node %d new size %d\n", hls_->addr(), arraysize);
+		}
+	    }		
+	  tmp = tmp->next;
+	}
+    } // end of while
+  } // end of for
+  
+  for(int i=0;i<index;i++)
+    {
+      // we delete the information here from the cache to avoid
+      // conflicts in the loop over the table of the cache
+      cache->remove(tmparray[i].id);
+      handoverInformation(&tmparray[i]);
+    }
+  free(tmparray);
+} // end of BHM::checkCacheAndTransmit
+
+// this function is responsible for handing over the information
+// it constructs a packet and sends it to the target cell
+// (to the cell where the information should be)
+void BasicHandoverManager::handoverInformation(nodeposition* info)
+{  
+  Packet *pkt = hls_->allocpkt();
+
+  struct hdr_ip *iph = HDR_IP(pkt);
+  struct hdr_cmn *cmnh = HDR_CMN(pkt);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+  struct hdr_hls *hlsh = HDR_HLS(pkt);
+
+  
+  iph->sport() = RT_PORT;
+  iph->dport() = RT_PORT;
+  iph->saddr() = hls_->parent->addr();
+  iph->daddr() = NO_NODE;
+  iph->ttl()   = HLS_TTL;
+
+  position cellPosition = cellbuilder_->getPosition(info->targetcell);
+  // Let GPSR route this pkt to the center of the responsible cell
+  // (or to the closest position possible)
+  iph->dx_ = cellPosition.x;
+  iph->dy_ = cellPosition.y;
+  iph->dz_ = cellPosition.z;
+
+  cmnh->ptype() = PT_HLS;
+  cmnh->addr_type_ = NS_AF_INET;
+  cmnh->num_forwards() = 0;
+  cmnh->next_hop_ = NO_NODE;
+  cmnh->direction() = hdr_cmn::DOWN;
+  cmnh->xmit_failure_ = 0;
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+
+  // init my own header
+  hlsh->init();
+  // now we have to put the actual position information into the
+  // packet (together with a timestamp)
+  hlsh->src.copyFrom(info);
+
+  hlsh->type_ = HLS_HANDOVER;
+
+  // set the cell field
+  hlsh->cell.id    = info->targetcell;
+  hlsh->cell.level = -1; //don't know the level in  the handover
+  hlsh->cell.pos.x = cellPosition.x;
+  hlsh->cell.pos.y = cellPosition.y;
+  hlsh->cell.pos.z = cellPosition.z;
+
+  if(hls_trace_handovers)
+    {
+      int myCell = hls_->getCell();
+      position cellPos = cellbuilder_->getPosition(myCell);
+
+      // HLS Handover send
+      hls_->trace("HLS_H_s   %.12f %d <%d %.2f %.2f> [%d %.4f %.2f %.2f] -> <%d %.2f %.2f>", 
+		  Scheduler::instance().clock(), // timestamp
+		  hls_->addr(),                  // address of handover sender
+		  myCell,                        // my cell
+		  cellPos.x,                     // my cell's position x ...
+		  cellPos.y,                     // and y
+		  hlsh->src.id,                  // information to handover
+		  hlsh->src.ts,                  // the info's ts
+		  hlsh->src.pos.x,               // and the ...
+		  hlsh->src.pos.y,               // position
+		  info->targetcell,              // target cell
+		  cellPosition.x,                // the  
+		  cellPosition.y);               // coordinates of the cell      
+    }
+
+  hls_->parent->recv(pkt, NULL);  
+} // end of BHM::handoverInformation(...)
+
+
+AnswerTimer::AnswerTimer(BasicRequestProcessor* brp, double timeout,
+			 nodeposition* information)  
+{
+  brp_ = brp;
+  info_.copyFrom(information);
+  sched(timeout);
+  next = NULL;
+}
+
+void AnswerTimer::expire(Event* e)
+{}
+
+AnswerTimer::~AnswerTimer()
+{}
+
+hdr_hls* AnswerTimer::getHlsHeaderOfPacket()
+{
+  return NULL;
+}
+
+// CellcastAnswerTimer /////////////////////////////////////
+CellcastAnswerTimer::CellcastAnswerTimer(BasicRequestProcessor* brp, double timeout,
+					 Packet* p, nodeposition* information)  
+  : AnswerTimer(brp, timeout, information)
+{
+  packet_ = p;
+  reqId_.set(HDR_HLS(p)->reqid);
+}
+
+CellcastAnswerTimer::~CellcastAnswerTimer()
+{
+  Packet::free(packet_);      
+}
+
+void CellcastAnswerTimer::expire(Event* e)
+{
+  brp_->sendCellcastReply(packet_, &info_);
+  //Packet::free(packet_);
+}
+
+hdr_hls* CellcastAnswerTimer::getHlsHeaderOfPacket()
+{
+  return HDR_HLS(packet_);
+}
+
+// end of cellcastAnswerTimer
+
+// CirclecastAnswerTimer /////////////////////////////////////
+CirclecastAnswerTimer::CirclecastAnswerTimer(BasicRequestProcessor* brp, double timeout,
+					     const Packet* p, nodeposition* information)  
+  : AnswerTimer(brp, timeout, information)
+{
+  packet_ = p->copy();
+  reqId_.set(HDR_HLS(p)->reqid);
+}
+
+CirclecastAnswerTimer::~CirclecastAnswerTimer()
+{
+  Packet::free(packet_);        
+}
+
+void CirclecastAnswerTimer::expire(Event* e)
+{
+  brp_->sendCellcastReply(packet_, &info_);
+}
+
+hdr_hls* CirclecastAnswerTimer::getHlsHeaderOfPacket()
+{
+  return HDR_HLS(packet_);
+}
+
+
+// StopAndGoTimerHandler ///////////////////////////////////
+// The stopandgotimerhandler isn't really needed any more, it was
+// used in an old implementation of the cellcast stuff.
+// But it's a nice class, perhaps we need it later, thus keep
+// it ;-)
+StopAndGoTimerHandler::StopAndGoTimerHandler(double intervall)
+{
+  counter_ = 0;
+  intervall_ = intervall;
+}
+
+void StopAndGoTimerHandler::incrementCounter()
+{  
+  if(counter_ > 0)
+    {
+      counter_++;
+    }
+  else
+    {
+      resched(intervall_);
+      counter_ = 1;
+    }
+}
+
+void StopAndGoTimerHandler::decrementCounter()
+{
+  counter_--;
+  if(counter_ < 0)
+    {
+      printf("### error in StopAndGoTimerHandler:decrementCounter() counter_ negative\n");
+      exit(-1);
+    }
+  if((counter_ == 0) && (status() == TIMER_PENDING))
+    {
+      // cancel the pending timer because there is no other event
+      cancel();
+    }
+}
+
+// this is called when the timer expires. This method will also decrement
+// the counter and will only reschedule the timer if the counter is 
+// greated than 0
+void StopAndGoTimerHandler::expire(Event* e)
+{
+  // for calling the child classes' expire method
+  this->stopAndGoTimerExpired();
+
+  if(counter_ > 0)
+    {
+      resched(intervall_);
+    }
+}
+
+// BUSTimer ////////////////////////////////////////////////
+BUSTimer::BUSTimer(BasicUpdateSender* bus, double intervall)
+{
+  this->bus_ = bus;
+  this->intervall_ = intervall;
+}
+
+void BUSTimer::expire(Event* e)
+{
+  bus_->timerExpired();
+  double delay = Random::uniform(HLS_UPDATE_JITTER);
+  resched(intervall_ + delay); // reschedule the timer after the intervall
+}
+
+////////////////////////
+// Location Cache //////
+////////////////////////
+
+bool HLSLocationCache::add(nodeposition* info) {
+    return (ChainedHashCache::add(info->id, (void*)(info)));
+}
+
+bool HLSLocationCache::update(nodeposition* info) {
+    return (ChainedHashCache::update(info->id, (void*)(info)));
+}
+
+bool HLSLocationCache::iupdate (void* ventry, void* vdata) {
+    if (((nodeposition*)ventry)->ts < ((nodeposition*)vdata)->ts) {
+	memcpy(ventry,vdata,sizeof(nodeposition));
+	return true;
+    }
+    return false;
+}
+
+bool HLSLocationCache::itimeout (void* ventry) {
+  if ((Scheduler::instance().clock() - ((nodeposition*)ventry)->ts) > lifetime) 
+    { 
+      return true; 
+    }
+
+  
+  //}
+  return false;
+}
+
+void HLSLocationCache::iprint (void* ventry) {
+    nodeposition* entry = (nodeposition*)ventry;
+    printf("(%d), %.4f",
+	   entry->id,
+	   entry->ts);
+}
+
+// end of HLSLocationCache
+
+// RequestCache //////////////////////////////////////////////////////
+// For the cellcast requests and the circlecast requests /////////////
+RequestCache::RequestCache(int initialCacheSize,
+			   BasicRequestProcessor* requestProcessor)
+{
+  packetCache = new Packet*[initialCacheSize];
+  timerCache  = new RequestCacheTimer*[initialCacheSize];
+  actualCacheSize = initialCacheSize;
+  brp_ = requestProcessor;
+
+  for(int i=0;i<actualCacheSize;i++)
+    {
+      packetCache[i] = NULL;
+      timerCache[i] = new RequestCacheTimer(this, i);
+    }
+}
+
+RequestCache::~RequestCache()
+{
+  for(int i=0;i<actualCacheSize;i++)
+    {
+      if(packetCache[i] != NULL)
+	{
+	  Packet::free(packetCache[i]);
+	}
+      delete(timerCache[i]);
+    }  
+}
+
+
+// when this function is called, it means that the timer for
+// the packet at the given position has expired.
+void RequestCache::timerCallback(int number)
+{
+  Packet* tmp = packetCache[number];
+  packetCache[number] = NULL;
+  timerExpired(tmp);
+}
+
+// this is the method which must be reimplemented by the child 
+// classes
+void RequestCache::timerExpired(Packet* p)
+{}
+
+
+
+// stores the packet in the cache and sets the lifetime
+void RequestCache::store(Packet* p, double lifetime)
+{
+  int index = getFreeSlot();
+  packetCache[index] = p;
+  timerCache[index]->sched(lifetime);
+}
+
+
+
+Packet* RequestCache::getRequest(request_id reqid)
+{
+  // loop through the cache
+  for(int i=0;i<actualCacheSize;i++)
+    {
+      // there is an entry ...
+      if(packetCache[i] != NULL)
+	{
+	  // ... with the same request id
+	  if(reqid.equals(&HDR_HLS(packetCache[i])->reqid))
+	    {
+	      // take the packet from the cache and initialize
+	      // the slot
+	      Packet* tmp = packetCache[i];
+	      packetCache[i] = NULL;
+	      timerCache[i]->cancel();
+	      return tmp;	      
+	    }
+	}
+    }
+  // we haven't found anything, thus we return NULL
+  return NULL;
+}
+
+int RequestCache::getFreeSlot()
+{
+  
+  for(int i=0;i<actualCacheSize;i++)
+    {
+      if(packetCache[i] == NULL)
+	{
+	  return i;
+	}
+    }
+  // we arrive here, that means no free space was found,
+  // thus we double the space of the caches
+  int nextFreeSlot = actualCacheSize;
+  actualCacheSize = actualCacheSize * 2;
+  Packet** tmpPacket = (Packet**) realloc(packetCache, 
+					  sizeof(Packet*)*actualCacheSize);
+  RequestCacheTimer** tmpTimer
+    = (RequestCacheTimer**) realloc(timerCache, 
+				    sizeof(RequestCacheTimer)*actualCacheSize);
+  
+  if((tmpPacket == NULL) || (tmpTimer == NULL))
+    {
+      printf("out of memory in RequestCache::getFreeSlot\n");
+      exit(-1);
+    }
+  packetCache = tmpPacket;
+  timerCache  = tmpTimer;
+  // initialize the caches
+  for(int i=nextFreeSlot;i<actualCacheSize;i++)
+    {
+      packetCache[i] = NULL;
+      timerCache[i] = new RequestCacheTimer(this, i);
+    }
+  
+  return nextFreeSlot;
+}
+
+// RequestCacheTimer ////////////////////////////////////////////////
+RequestCacheTimer::RequestCacheTimer(RequestCache* cache, int number)
+{
+  cache_ = cache;
+  this->number = number;
+}
+
+void RequestCacheTimer::expire(Event* e)
+{
+  cache_->timerCallback(number);
+}
+
+
+//////////////////////////////////////////////////////////////////////
+// cellcastRequestCache //////////////////////////////////////////////
+CellcastRequestCache::CellcastRequestCache(int initialCacheSize,
+		       BasicRequestProcessor* requestProcessor)
+  : RequestCache(initialCacheSize, requestProcessor)
+{}
+
+void CellcastRequestCache::timerExpired(Packet* p)
+{
+  // telling the brp that the timer for that packet has
+  // expired
+  brp_->cellcastTimerCallback(p);
+}
+//////////////////////////////////////////////////////////////////////
+// circlecastRequestCache ////////////////////////////////////////////
+CirclecastRequestCache::CirclecastRequestCache(int initialCacheSize,
+					       BasicRequestProcessor* requestProcessor)
+  : RequestCache(initialCacheSize, requestProcessor)
+{}
+
+void CirclecastRequestCache::timerExpired(Packet* p)
+{  
+  // telling the brp that the timer for that packet has
+  // expired
+  brp_->dropAndTraceRequestPacket(p,CIRCLECAST_TIMEOUT);
+}
+
+//////////////////////////////////////////////////////////////////////
+// globale helper functions
+// returns true if pos1 and pos2 are member of the same cell
+bool sameCell(position* pos1, position* pos2, Cellbuilder* cellbuilder)
+{
+  int cell1, cell2;
+  cell1 = cellbuilder->getCellID(*pos1);
+  cell2 = cellbuilder->getCellID(*pos2);  
+  if(cell1 == cell2)
+    {
+      return true;
+    }
+  else
+    {
+      return false;
+    }
+}
+
+// init static variable for hdr_hls::offset_
+int hdr_hls::offset_;
diff -u -r --new-file ./hls/hls_basic.h ../../ns-2.33-hls_working/ns-2.33/hls/hls_basic.h
--- ./hls/hls_basic.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/hls_basic.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,315 @@
+/* this file contains the definition for the basic
+   implementations of the components and also the 
+   prototypes for these components
+*/
+
+#ifndef hls_basic_h
+#define hls_basic_h
+
+#include "timer-handler.h"
+#include "cellbuilder.h"
+//#include "packet.h"
+#include "hls.h"
+
+
+////////////////////////////////////////////////////////
+// basic implementations ///////////////////////////////
+////////////////////////////////////////////////////////
+
+// the StopAndGoTimerHandler is a timer which counts how
+// often he has been scheduled. It has an internal counter 
+// which can be incremented and decremented, if the counter
+// is 0, the timer will not expire, each time it expires, the
+// counter will be decremented.
+class StopAndGoTimerHandler : public TimerHandler
+{
+  public :
+    StopAndGoTimerHandler(double intervall);
+  void incrementCounter();
+  void decrementCounter();
+  
+  protected :
+    void expire(Event* e);
+  // this is the expire method which should be used by the child
+  // classes. With this construction, the whole counter management
+  // can be kept in the parent class
+  virtual void stopAndGoTimerExpired() = 0;//{printf("parent stopandgo\n");};
+  private :
+    int counter_;
+  double intervall_;
+};
+
+class BUSTimer;
+
+// the basic update sender sends an update each n
+// milliseconds (where n is a parameter the user can
+// determine) to every level.
+class BasicUpdateSender : public UpdateSender
+{
+ public:
+  BasicUpdateSender(Cellbuilder* cellbuilder, HLS* hls);
+  ~BasicUpdateSender();
+  void start();
+  void timerExpired();
+ 
+ private:
+  double updateIntervall_;   // meassured in seconds
+  BUSTimer* timer_;
+
+  nodeposition sendUpdatePacketToCell(int cellid, int level);
+
+  nodeposition* lastUpdatePosition_; // contains the position from which
+  // we have send the last update (for each level)
+
+  // Update Trace Support
+  const char* upd_reason;
+};
+
+class BasicUpdateReceiver : public UpdateReceiver
+{
+  public :
+    BasicUpdateReceiver(HLSLocationCache* activeEntries, 
+			HLSLocationCache* passiveEntries, 
+			HLSLocationCache* outOfCellEntries,
+			HLS* hls);
+    void recv(Packet* &p, bool forceActiveSave);
+};
+
+//declaration necessary for the BasicRequestProcessor
+class CellcastRequestCache;
+class CirclecastRequestCache;
+class AnswerTimer;
+class CleanTimerListTimer;
+
+class BasicRequestProcessor : public RequestProcessor
+{
+  public :
+    BasicRequestProcessor(HLSLocationCache* passiveEntries, HLS* hls);
+  ~BasicRequestProcessor();
+    void recv(Packet* &p); 
+    void recvCellcastRequest(Packet* &p);
+    void cellcastReplyOnMacReceived(const Packet* p);
+    void recvCellcastReply(Packet* &p); 
+    void processRequestUnreachableCell(Packet* &p_old);
+    void recvCirclecastRequest(Packet* &p, bool fromDropCallback);
+    void circlecastRequestOnMacReceived(const Packet* p);
+    void cellcastTimerCallback(Packet* p);
+    void dropAndTraceRequestPacket(Packet* p, char *reason);
+    protected :      
+      void cleanTimerList();
+
+    private :
+
+    AnswerTimer* answerTimerList_;
+    CellcastRequestCache* cellcastRequestCache_;
+    CirclecastRequestCache* circlecastRequestCache_;
+    CleanTimerListTimer* cleanTimerListTimer_;
+      
+    void sendCellcastRequest(int nodeid, request_id reqid, struct_cell* cell);
+    
+    void sendCirclecastRequest(int nodeid, request_id, int* cells);
+    // the cellcastBuffer stores the packets which caused the sending
+    // of a cellcast request.If an answer arrives, the packet can be
+    // forwarded to the target. If no answer arrives, the packet can
+    // be forwarded to the RC on the next higher level
+    cellcastEntry* cellcastBuffer_;
+
+
+    friend class CellcastAnswerTimer;
+    friend class CirclecastAnswerTimer;
+};
+
+
+// the answer timer triggers the sending of the answer to a
+// cellcast request: it is quite likely that more than one
+// node have the requested information. To avoid collisions
+// in sending, every node which receives a request schedules
+// a timer and sends an answer if he hasn't heared another 
+// answer packet before
+
+class AnswerTimer : public TimerHandler
+{
+  public :
+    AnswerTimer(BasicRequestProcessor* brp, double timeout, 
+		nodeposition* information);
+  virtual ~AnswerTimer();
+  AnswerTimer* next;
+  // attributes
+  request_id reqId_;
+  virtual hdr_hls* getHlsHeaderOfPacket();
+
+  protected :
+    void expire(Event* e);
+  BasicRequestProcessor* brp_;
+  nodeposition info_; // the info which we want to sent
+
+  private :
+};
+
+class CellcastAnswerTimer : public AnswerTimer
+{   
+  public :
+  CellcastAnswerTimer(BasicRequestProcessor* brp, double timeout, 
+		      Packet* p, nodeposition* information);
+  ~CellcastAnswerTimer(); 
+  hdr_hls* getHlsHeaderOfPacket();
+  protected :
+    void expire(Event* e);
+  private :
+    Packet* packet_;
+};
+
+class CirclecastAnswerTimer : public AnswerTimer
+{
+  public :
+    CirclecastAnswerTimer(BasicRequestProcessor* brp, double timeout, 
+			  const Packet* p, nodeposition* information);
+  ~CirclecastAnswerTimer(); 
+  hdr_hls* getHlsHeaderOfPacket();
+  protected :
+    void expire(Event* e);
+  private :
+    Packet* packet_;
+};
+
+class BUSTimer : public TimerHandler 
+{
+  public :
+    BUSTimer(BasicUpdateSender* bus, double intervall);
+
+  protected :
+    void expire(Event* e);
+
+  private :
+    double intervall_; // meassured in seconds
+  BasicUpdateSender* bus_;
+};
+
+class BasicHandoverManager : public HandoverManager
+{  
+  public :
+    BasicHandoverManager(HLSLocationCache* activeEntries, 
+			 HLSLocationCache* passiveEntries,
+			 HLSLocationCache* outOfCellEntries,
+			 HLS* hls, 
+			 Cellbuilder* cellbuilder); 
+  // will be called whenever HLS receives a handover packet.
+  void recv(Packet* &p, bool forceActiveSave);
+  void timerCallback(); // called when the timer expired
+  
+ private:
+  void handoverInformation(nodeposition* info);
+  void checkCacheAndTransmit(HLSLocationCache* cache, int actualCell);
+  
+}; // end handover manager
+
+// the advanced hm sends all information to a cell in one
+// packet in the data compartement
+class AdvancedHandoverManager : public HandoverManager
+{  
+  public :
+    AdvancedHandoverManager(HLSLocationCache* activeEntries, 
+			 HLSLocationCache* passiveEntries,
+			 HLSLocationCache* outOfCellEntries,
+			 HLS* hls, 
+			 Cellbuilder* cellbuilder); 
+  // will be called whenever HLS receives a handover packet.
+  void recv(Packet* &p, bool forceActiveSave);
+  void timerCallback(); // called when the timer expired
+  
+ private:
+  void handoverInformation(nodeposition* info,  int numberOfInfos);
+  void checkCacheAndTransmit(HLSLocationCache* cache, int actualCell);
+  void bubblesort(nodeposition* A, int size);
+  void exchange(nodeposition* a, nodeposition* b);
+  
+}; // end handover manager
+
+////////////////////////////////////////////////////////////
+// CACHES //////////////////////////////////////////////////
+////////////////////////////////////////////////////////////
+
+// replaces the old Store which couldn't grow
+class HLSLocationCache : public ChainedHashCache {
+ public:
+     HLSLocationCache(class LocationService* parent, 
+		     const unsigned int hash_size = CHC_BASE_SIZE, 
+		     const double lifetime = 0.0 ) 
+	: ChainedHashCache(parent,hash_size,lifetime) {}
+    ~HLSLocationCache() {}
+    
+    // search and remove already defined in parent class, the 
+    // code below is just for documenatation
+    bool add(nodeposition*);
+    bool update(nodeposition*);
+
+ private:
+    bool iupdate (void*, void*);
+    bool itimeout (void*);
+    void iprint (void*);
+    inline void* inew() { return ((void*)(new nodeposition)); }
+    inline void idelete (void* ventry) { delete (nodeposition*)ventry; }
+    inline void icopy (void* ventry, void* vdata) 
+      { memcpy(ventry,vdata,sizeof(nodeposition)); }
+};
+
+class RequestCacheTimer;
+
+// has an internal cache which stores request pakets and timers
+// for theses packets. When the timer expires, a callback will be called
+// to inform that the request hasn't been successfull. There exists also
+// a method to get the packets back
+class RequestCache {
+  public :
+    RequestCache(int initialCacheSize, 
+		 BasicRequestProcessor* requestProcessor);
+  ~RequestCache();
+  void timerCallback(int number);
+  void store(Packet* p, double lifetime);
+  Packet* getRequest(request_id reqid);
+  virtual void timerExpired(Packet* p);
+  
+ protected :
+   BasicRequestProcessor* brp_;
+
+    private :
+      int actualCacheSize;
+    Packet** packetCache;
+    RequestCacheTimer** timerCache;
+    int getFreeSlot();
+    
+};
+
+class RequestCacheTimer : public TimerHandler 
+{
+  public :
+    RequestCacheTimer(RequestCache* cache, int number);
+
+  protected :
+    void expire(Event* e);
+
+  private :
+    RequestCache* cache_;
+  int number;
+};
+
+class CellcastRequestCache : public RequestCache
+{
+  public : 
+  CellcastRequestCache(int initialCacheSize,
+		       BasicRequestProcessor* requestProcessor);
+  void timerExpired(Packet* p);
+};
+
+class CirclecastRequestCache : public RequestCache
+{
+  public : 
+    CirclecastRequestCache(int initialCacheSize,
+			   BasicRequestProcessor* requestProcessor);
+  void timerExpired(Packet* p);
+};
+
+// returns true if pos1 and pos2 are member of the same cell
+extern bool sameCell(position* pos1, position* pos2, 
+		     Cellbuilder* cellbuilder);
+#endif
diff -u -r --new-file ./hls/hls.cc ../../ns-2.33-hls_working/ns-2.33/hls/hls.cc
--- ./hls/hls.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/hls.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,660 @@
+/*
+ * File: Code for a new Location Service for the ns
+ *       network simulator
+ * Author : Wolfgang Kiess
+
+
+   architecture:
+     The features of Location Services
+       - send PosInfos
+       - receive PosInfos
+       - receive and save PosInfos
+       - doing Positionrequests
+       - receive und answer Positionrequests are implemented in individual classes
+     Therefore a compact interface must be implemented. (across a parentclass with virtual functions). So you can implement a very simple version first, where components can be enhanced and exchanged easily.
+
+     Baseversion of the components:
+     Sending of PosInfos : always after a given timeintervall
+     Forwarding of PosInfos : no special functionality
+     receive and save PosInfos: as described with a compact maximum number of spaces.
+     Positionrequests : to the homecell on level 1
+     receive and answer Positionrequests: Routing to the cell, 
+		first node of the cell answers or asks the cell on next level;
+		if there is no node in the cell reachable, the packet gets 
+		forwarded to the cell on the next level.
+
+     TODO :
+     - the parameter reqid is abused to determine if a node has already
+       answered a cellcast or circlecast. This parameter was just
+       introduced to enable a better tracing 
+ * 
+ */
+
+
+#include "hls_basic.h"
+#include "mac.h"
+#include "quadratic.h"
+
+// just for broadcast
+#include "../gpsr/gpsr.h"
+
+
+HLS::HLS(Agent* p)
+  : LocationService(p)
+{
+  parent = p;
+}
+
+void HLS::init()
+{
+  // radiorange, x and y required 
+  double maxx = mn_->T_->upperX();
+  double maxy = mn_->T_->upperY();
+
+  double rrange = God::instance()->getRadioRange();
+
+
+  reqtable_ = new LSRequestCache(this,HLS_REQTABLE_SIZE,HLS_REQTABLE_TIMEOUT);
+
+  cellbuilder_ = new QuadraticCellbuilder(rrange, maxx, maxy);
+  updateSender_ = new BasicUpdateSender(cellbuilder_, this);
+
+  activeEntries_ = new HLSLocationCache(this, HLS_ACTIVE_ENTRIES_SIZE, ENTRY_LIFETIME);
+    //new Store(NUMBER_OF_ACTIVE_ENTRIES);
+  passiveEntries_ =  new HLSLocationCache(this, CHC_BASE_SIZE, ENTRY_LIFETIME);
+    //new Store(NUMBER_OF_PASSIVE_ENTRIES);
+  outOfCellEntries_ = new HLSLocationCache(this, HLS_ACTIVE_ENTRIES_SIZE, ENTRY_LIFETIME);
+  updateReceiver_ = new BasicUpdateReceiver(activeEntries_,
+					    passiveEntries_, 
+					    outOfCellEntries_,
+					    this);
+  requestProcessor_ = new BasicRequestProcessor(passiveEntries_, this);
+  handoverManager_ = new AdvancedHandoverManager(
+    //new BasicHandoverManager(
+					      activeEntries_, 
+					      passiveEntries_, 
+					      outOfCellEntries_,
+					      this,
+					      cellbuilder_);
+  
+  // initialize the last request number value
+  lastReqNr = -1;
+
+  updateSender_->start();
+}
+
+HLS::~HLS() {
+  delete cellbuilder_;
+  delete updateSender_; 
+  delete activeEntries_; 
+  delete passiveEntries_;
+  delete outOfCellEntries_;
+  delete updateReceiver_; 
+  delete requestProcessor_; 
+  delete reqtable_;
+  delete handoverManager_;
+}
+
+// is called by tap in GPSR_Agent, that means we can have a
+// look at all packets we receive, no matter to which address
+// they were sent to
+// at the moment, we process beacons, piggybacked location info
+// and cellcast replies here
+void HLS::evaluatePacket(const Packet *p)
+{ 
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  //struct hdr_ip *iphdr = HDR_IP(p);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+  struct hdr_cmn *cmnh = HDR_CMN(p);
+
+  if ((cmnh->ptype()==PT_GPSR)&&(gpsrh->mode_ == GPSRH_BEACON)) {
+    // Direct Neighbor Information from GPSR Beacons
+    nodeposition neighb;
+    neighb.id = HDR_IP(p)->saddr();//iphdr->saddr();
+    neighb.ts = Scheduler::instance().clock(); // Off by a few because Beacons don't have a TS
+
+    neighb.pos.x = gpsrh->hops_[0].x;
+    neighb.pos.y = gpsrh->hops_[0].y;
+    neighb.pos.z = gpsrh->hops_[0].z;    
+
+    passiveEntries_->add(&neighb);
+  } // end of BEACON processing
+
+  if(hlsh->type_ == HLS_CELLCAST_REPLY)
+    {
+      requestProcessor_->cellcastReplyOnMacReceived(p);
+    }
+
+  if(hlsh->type_ == HLS_CIRCLECAST_REQUEST)
+    {
+      requestProcessor_->circlecastRequestOnMacReceived(p);
+    }
+
+  // it is not an explicit hls packet 
+  if(hlsh->status_ != ON_THE_FLY_UPDATE)
+    {
+      // the packet didn't contain locservice info
+      return;
+    }
+  
+  // if it is part of a communication connection, the sender of the packet
+  // will put his  position in the header to keep us in sync. 
+  if(HDR_IP(p)->daddr() == addr())
+    { 
+      // we are the target, thus endpoint of the communication connection
+      // update the entry 
+      passiveEntries_->add(&hlsh->src);
+      if(hls_verbose)
+	{
+	  // HLS Cache Update
+	  trace("HLS_CUpd  %.12f %d [%d %.4f %.2f %.2f]",
+		Scheduler::instance().clock(), // when
+		addr(),                        // I
+		hlsh->src.id,                  // the updater
+		hlsh->src.ts,                  // ts of the information
+		hlsh->src.pos.x,               // x ...
+		hlsh->src.pos.y);              // and y of the target
+	}
+    }
+#ifdef AGGRESSIVE_CACHING
+  else 
+    {
+      // we are not the target but grep all info we can
+      passiveEntries_->add(&hlsh->src);	      
+    }  
+#endif
+}
+  
+void HLS::recv(Packet* &p) {
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  
+  if((HDR_CMN(p)->ptype()) == PT_HLS)
+    {
+#ifdef AGGRESSIVE_CACHING
+
+      // save positioninformation included in this packet into passiveEntries
+      passiveEntries_->add(&hlsh->src);	
+#endif
+	
+
+    switch(hlsh->type_)
+      {
+      case HLS_UPDATE :
+	updateReceiver_->recv(p, false);
+	break;
+      case HLS_HANDOVER :
+	// at the moment, handover packets will be treated like 
+	// updates (which isn't really correct, we extract the src 
+	// information in the hls-header, but the source is the 
+	// one who sent us the handover packet. 
+	// normally, there should be another field just for
+	// this data.
+	handoverManager_->recv(p, false);
+	
+	break;
+      case HLS_REQUEST :
+	requestProcessor_->recv(p);
+	break;	
+
+      case HLS_CELLCAST_REQUEST :
+	requestProcessor_->recvCellcastRequest(p);
+	p = NULL;
+	break;
+      case HLS_CELLCAST_REPLY :
+	requestProcessor_->recvCellcastReply(p);
+	break;
+      case HLS_REPLY :
+	// we should put the result in the passive entries table
+	processReply(p);
+	break;
+      case HLS_CIRCLECAST_REQUEST :
+	requestProcessor_->recvCirclecastRequest(p, false);
+	break;
+      default:
+	printf("##error : HDR_HLS(p)->type unknown (hls.cc) node %d\n", 
+	       addr());
+	break;
+      }
+  } 
+  return;
+} // end of HLS::recv(...)
+
+
+
+void HLS::dropPacketCallback(Packet* &p) 
+{ 
+  // if the dropped packet is a locs packet there are two 
+  // possibilities:
+  // update/handover packet => save in active entries (I am not a member of the
+  // right cell the entry belongs to. After callCheckTimer expires the packet
+  // is transfered (back) to the cell.)
+  // request packet => The targetcell is not reachable. The Request has to be 
+  // forwarded to the cell on the next level.
+
+
+  if((HDR_CMN(p)->ptype()) == PT_HLS)
+    {
+      switch(HDR_HLS(p)->type_)
+	{
+	case HLS_UPDATE : 
+	  // force the updateReceiver to save the info in his active store
+	  updateReceiver_->recv(p, true);//, true);
+	  break;
+	case HLS_REQUEST :
+	  requestProcessor_->processRequestUnreachableCell(p);
+	  p = NULL;
+	  break;		  	  
+	case HLS_HANDOVER :
+	  handoverManager_->recv(p, true);
+	  break;
+	case HLS_REPLY :
+	  if(hls_verbose)
+	    { 
+	      position pos;
+	      mn_->getLoc(&pos.x, &pos.y, &pos.z);
+	      struct hdr_hls *hlsh = HDR_HLS(p);
+	      
+	      // HLS Reply drop (no route to requesting node)
+	      trace("HLS_REP_d %.12f (%d_%d) %d %.2f", 
+		    Scheduler::instance().clock(), // timestamp
+		    hlsh->reqid.node,          // the unique...
+		    hlsh->reqid.nr,            // id of the request
+		    addr(),                    // my address 	  
+		    distance(hlsh->dst.id, pos));// the distance between my pos
+	      // and the node who wanted the info
+	    }
+	  break;          
+	case HLS_CELLCAST_REQUEST :
+	  printf("### %d: dropPacketCallback of cellcast request\n", addr());
+	  trace("%.21f %d: dropPacketCallback of cellcast request\n", 
+		Scheduler::instance().clock(), addr());
+	  break;
+	case HLS_CELLCAST_REPLY :
+	  break;
+      case HLS_CIRCLECAST_REQUEST :
+	requestProcessor_->recvCirclecastRequest(p, true);
+	break;
+	default :
+	  printf("### %d: dropPacketCallback with undefined type\n", addr());
+	  trace("%.21f %d: dropPacketCallback with undefined type %d\n", 
+		Scheduler::instance().clock(), addr(), HDR_HLS(p)->type_);
+	  break;
+	}
+    }
+  return; 
+} 
+
+bool HLS::poslookup(Packet *p) {
+    struct hdr_ip *iphdr = HDR_IP(p);
+
+    if(iphdr->daddr() < 0) // don't process broad- or geocast packets
+      {
+	// there can't be an entry for this address
+	return true;
+      }
+    
+    // Prune Location Service Packets
+    
+    if (HDR_CMN(p)->ptype()== PT_HLS)  { return true; }
+    
+    // 1. check the local cache (active and passive)
+    nodeposition* nodepos = findEntry(iphdr->daddr());
+
+    if((nodepos != NULL) &&
+       ((Scheduler::instance().clock() - nodepos->ts) < HLS_MAX_CACHE_LOOKUP_AGE))
+      {
+	if(hls_verbose)
+	  {
+	    // HLS Cache Lookup
+	    trace("HLS_CL    %.12f %d [%d %.4f %.2f %.2f] {%.2f}",
+		  Scheduler::instance().clock(), // when
+		  addr(),                        // I
+		  nodepos->id,                   // target
+		  nodepos->ts,                   // ts of the information
+		  nodepos->pos.x,                // x ...
+		  nodepos->pos.y,                // and y of the target
+		  distance(nodepos->id, nodepos->pos)); // deviation
+	  }
+	
+	iphdr->dx_ = nodepos->pos.x;
+	iphdr->dy_ = nodepos->pos.y;
+	iphdr->dz_ = nodepos->pos.z;
+
+	// write my address to the packet to keep loc_service at my
+	// communication partner up to date
+	struct hdr_hls* hlsh = HDR_HLS(p);
+	mn_->getLoc(&hlsh->src.pos.x, &hlsh->src.pos.y, &hlsh->src.pos.z);
+	hlsh->src.ts = Scheduler::instance().clock();
+	hlsh->src.id = addr();
+	hlsh->status_ = ON_THE_FLY_UPDATE;
+	return true;
+	}
+    // 2. Check on neighbourtable of routing is not necessary. All packets the 
+    // node receives are checked in evaluatePacket method. So informatiosn are 
+    // saved in passive entries
+    
+    // 3. Send a posRequests
+    // No Location can be found in the Location Cache, so we'll
+    // check if the dst is already queried and if it is not, we'll
+    // send a Location Request Packet
+
+
+      
+    // Check if DST has been queried
+    locrequest* request = (locrequest*)reqtable_->search(iphdr->daddr());
+
+    
+    if (!request) {
+      // DST has not been queried in a long time (if ever)
+      
+      // remember that we sent the request
+      struct locrequest tmpreq = { 
+	iphdr->daddr(), Scheduler::instance().clock(), 0, 0 
+      };
+      reqtable_->add(&tmpreq);
+
+      sendRequest(iphdr->daddr(), 1); // 1 because of level 1
+    }
+    
+    // false has to been returned since nothing was found. The routing asks the locservice, if the Position is present, again after a given timeout.
+    // hier muss false zurckgegeben werden, da noch nichts gefunden wurde.
+    return false;
+}
+
+// sends a reqeust to the responsible cell on the given level
+// returns true if it was a valid level (that means a responsible
+// cell could have been determined) or false if it wasn't a valid level
+bool HLS::sendRequest(int nodeid, int level)
+{
+  Packet *p = allocpkt();
+  
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  struct hdr_ip *iph = HDR_IP(p);
+  struct hdr_cmn *cmnh = HDR_CMN(p);
+  struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+ 
+  iph->sport() = RT_PORT;
+  iph->dport() = RT_PORT;
+  iph->saddr() = parent->addr();
+  iph->daddr() = NO_NODE;
+
+  // determine the RC for the given node
+  position pos;
+  mn_->getLoc(&pos.x, &pos.y, &pos.z);
+  int responsibleCell = cellbuilder_->getRC(nodeid, level, pos);
+
+  if(responsibleCell == NO_VALID_LEVEL)
+    {
+      return false;
+    }
+
+  lastReqNr++;
+  struct request_id reqID(addr(), lastReqNr);
+
+  position cellPosition = cellbuilder_->getPosition(responsibleCell);
+
+  // TRACE
+  if(hls_verbose)
+    {
+      // HLS Request send
+      trace("HLS_REQ_s %.12f (%d_%d) %d ->%d <%d %.2f %.2f (%d)>", 
+	    Scheduler::instance().clock(), // timestamp
+	    reqID.node,                    // address of requestor
+	    reqID.nr,                      // local number of the request
+	    reqID.node,                    // address if requestor
+	    nodeid,                        // target node
+	    responsibleCell,               // destination cell
+	    cellPosition.x,                // x and y 
+	    cellPosition.y,                // of the center of the cell
+	    level);                        // level of the cell
+    }
+
+
+  // Let GPSR route this pkt to the center of the responsible cell
+  iph->dx_ = cellPosition.x;
+  iph->dy_ = cellPosition.y;
+  iph->dz_ = cellPosition.z;
+  iph->ttl() = HLS_REQUEST_TTL_PER_LEVEL * level;
+
+  cmnh->ptype() = PT_HLS;
+  cmnh->addr_type_ = NS_AF_INET;
+  cmnh->num_forwards() = 0;
+  cmnh->next_hop_ = NO_NODE;
+  cmnh->direction() = hdr_cmn::DOWN;
+  cmnh->xmit_failure_ = 0;
+
+  gpsrh->mode_ = GPSRH_DATA_GREEDY;
+  gpsrh->port_ = hdr_gpsr::LOCS;
+  gpsrh->geoanycast = true;
+
+  // now we have to put our position information into the
+  // packet (together with a timestamp)
+  hlsh->src.id = parent->addr();
+  hlsh->src.ts = Scheduler::instance().clock();
+  mn_->getLoc(&hlsh->src.pos.x, &hlsh->src.pos.y, &hlsh->src.pos.z);
+  hlsh->type_ = HLS_REQUEST;
+
+  // set the cell field
+  hlsh->cell.init();
+  hlsh->cell.id    = responsibleCell;
+  hlsh->cell.level = level;
+  hlsh->cell.pos.x = cellPosition.x;
+  hlsh->cell.pos.y = cellPosition.y;
+  hlsh->cell.pos.z = cellPosition.z;
+  
+  // put the id of the requested node in the packet
+  hlsh->dst.id = nodeid;
+  // the unique id for the request
+  hlsh->reqid = reqID;
+
+  parent->recv(p, NULL);
+  return true;
+} //end of send Request
+
+// this mehtod is called when we received a reply packet to
+// a position lookup
+void HLS::processReply(Packet* &p)
+{
+  // put the result in the passive store
+  struct hdr_hls *hlsh = HDR_HLS(p);
+  if(hlsh->dst.id == addr())
+    {
+      if(hls_verbose)
+	{
+	  // HLS Reply receive
+	  trace("HLS_REP_r %.12f (%d_%d) %d <-%d [%.4f %.2f %.2f] {%.2f}", 
+		Scheduler::instance().clock(), // timestamp
+		hlsh->reqid.node,              // the unique...
+		hlsh->reqid.nr,                // id of the request
+		addr(),                        // address of requestor
+		hlsh->src.id,                  // node who answered
+		hlsh->src.ts,                  // the age of the answer
+		hlsh->src.pos.x,               // the  
+		hlsh->src.pos.y,               // coordinates
+		distance(hlsh->src.id, hlsh->src.pos)); // deviation
+		
+	}
+      // out node is the target of the reply
+      printf("***********************************************\n");
+      printf("*** (%d): reply from (%d) received (ts %f) ****\n", 
+	     addr(), hlsh->src.id, Scheduler::instance().clock());
+      printf("***********************************************\n");
+      
+      // save it
+      passiveEntries_->add(&hlsh->src);
+
+      // delete request entry in reqtable
+      reqtable_->remove(hlsh->src.id);
+
+      // notify the routing agent that the reply arrived
+      parent->notifyPos(hlsh->src.id);
+
+      // we've been the target of the reply, so free it
+      Packet::free(p);
+      p = NULL;
+    }
+#ifdef AGGRESSIVE_CACHING
+  else
+    {
+      // we save the destination because the source has 
+      // already been saved in the recv-function
+      passiveEntries_->add(&hlsh->dst);
+    }
+#endif
+}
+
+// returns the id of the cell in which the node is at the moment
+int HLS::getCell()
+{
+  position pos;
+  mn_->getLoc(&pos.x, &pos.y, &pos.z);
+  return cellbuilder_->getCellID(pos);
+}
+
+// searches our caches (active an passive) for an entry for the
+// node with id nodeid.
+// returns a pointer to the nodeposition information if we found
+// something, otherwise NULL
+nodeposition* HLS::findEntry(int nodeid)
+{
+  if(nodeid == addr())
+    {
+      // we are looking for ourself
+      nodeposition nodepos = getNodeInfo();//new nodeposition();
+      passiveEntries_->add(&nodepos);
+      return (nodeposition*) passiveEntries_->search(nodeid);
+    }
+
+  nodeposition* nodepos = (nodeposition*) activeEntries_->search(nodeid);
+
+  if(nodepos == NULL)
+    {
+      nodepos = (nodeposition*) outOfCellEntries_->search(nodeid);
+    }
+ 
+ if(nodepos == NULL)
+    {
+      // what happens if entries are present in passive and active cache?
+      nodepos = (nodeposition*) passiveEntries_->search(nodeid);
+    }
+
+  return nodepos;
+}
+
+// same as above, we just don't search our passive cache
+// (thus only location servers will answer the request)
+nodeposition* HLS::findActiveEntry(int nodeid)
+{
+  if(nodeid == addr())
+    {
+      // we are looking for ourself
+      nodeposition nodepos = getNodeInfo();
+
+      passiveEntries_->add(&nodepos);
+      return (nodeposition*) passiveEntries_->search(nodeid);
+    }
+
+  nodeposition* nodepos = (nodeposition*) activeEntries_->search(nodeid);
+
+  if(nodepos == NULL)
+    {
+      nodepos = (nodeposition*) outOfCellEntries_->search(nodeid);
+    }
+  return nodepos;
+}
+
+
+// returns the information about our current position, cell, ...
+nodeposition HLS::getNodeInfo()
+{
+  struct nodeposition nodepos;
+  nodepos.id = parent->addr();
+  nodepos.ts = Scheduler::instance().clock();
+  mn_->getLoc(&nodepos.pos.x, &nodepos.pos.y, &nodepos.pos.z);
+  nodepos.targetcell = -1;
+  return nodepos;
+}
+
+// calculates the size of the HLS header of this packet
+// (not the real size! Rather the number of bytes which would
+// be necessary in an optimized implementation)
+int HLS::hdr_size(Packet* p)
+{
+  struct hdr_cmn *cmnh = HDR_CMN(p);
+  struct hdr_hls *hlsh = HDR_HLS(p);
+
+  // Defining Base Field Types in Bytes
+  const unsigned int nodeid     = 4; // IPv4 Adressen should be sufficient
+  const unsigned int timestamp  = 2;
+  const unsigned int locCoord   = 3; // to have enough prescision
+  const unsigned int position   = locCoord + locCoord;
+  const unsigned int cell       = 2;
+  //const unsigned int request_id = 2; // is always used together with source ID !
+  const unsigned int level      = 1;
+
+  const unsigned int nodeposition = nodeid + timestamp + position; // 12
+
+  const unsigned int TTL        = 1;
+  const unsigned int flags      = 1;
+  const unsigned int basic_info = TTL + flags;
+  
+  // All LS based routing agents must be listed here - copied by wk from mk
+  if (cmnh->ptype() == PT_GPSR) { return 0; } // GPSR Packet
+
+
+  if (cmnh->ptype() == PT_HLS) { // HLS Packet
+    switch(hlsh->type_)
+      {
+      case HLS_UPDATE :	
+	return(basic_info+nodeposition+cell);
+	// src of the update, target cell
+	break;
+      case HLS_HANDOVER :
+	return(basic_info+(hlsh->numberOfNodeinfosToHandover + 1)*nodeposition+cell);
+	// information to handover, target cell, previous location server
+	break;
+      case HLS_REQUEST :
+	return(basic_info+nodeposition+cell+level+nodeid);
+	// src of the request, target cell, level of target cell, target node
+	// (from the perspective of the source) 
+	break;	
+      case HLS_CELLCAST_REQUEST :
+	return(basic_info+nodeposition+cell+nodeid);
+	// sender of the ccrequest, target cell, node for which is asked
+	break;
+      case HLS_CELLCAST_REPLY :
+	return(basic_info+3*nodeposition);
+	// source and target of the reply + the information
+	break;
+      case HLS_REPLY :
+	return(basic_info+2*nodeposition);
+	// sender and receiver of the answer
+	break;
+      case HLS_CIRCLECAST_REQUEST :
+	return (basic_info+nodeposition+cell*2+nodeid);
+	// sender of request, first cell and actual target cell (all
+	// other cells can be calculated with this), node for which is
+	// asked
+	break;
+      default:
+	printf("Invalid HLS Packet wants to know it's size !\n");
+	abort();
+      }	
+  }
+  
+  // Data Packet
+  return (2*nodeposition);
+} // end of hdr_size
+
+// returns the distance between the actual location of the node nodeid
+// and the given position
+double distance(int nodeid, position pos)
+{
+  position nodepos;
+  God::instance()->getPosition(nodeid, &nodepos.x, &nodepos.y, &nodepos.z);
+  double deltaX = pos.x - nodepos.x;
+  double deltaY = pos.y - nodepos.y;
+  //double deltaZ = pos.z - nodepos.z;
+
+  return sqrt((deltaX*deltaX)+(deltaY*deltaY));
+}
diff -u -r --new-file ./hls/hls.h ../../ns-2.33-hls_working/ns-2.33/hls/hls.h
--- ./hls/hls.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/hls.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,502 @@
+/*
+ * File: this header file contains the necessary information for the
+ *       agent for the Hierarchical Location Service
+ * Author: Wolfgang Kiess
+ *
+ */
+
+
+#ifndef ns_hls_h
+#define ns_hls_h
+
+#include "agent.h"
+#include "tclcl.h"
+#include "packet.h"
+#include "address.h"
+#include "ip.h"
+#include "locservices/locservice.h"
+#include "locservices/chc.h" // for the caches
+
+// the STORE_CLEAN_INTERVALL is the intervall in which the
+// content of the stores (active and passive) is checked 
+#define STORE_CLEAN_INTERVALL 4
+
+
+// the following is for the request table
+#define HLS_REQTABLE_TIMEOUT 3.0
+#define HLS_REQTABLE_SIZE    97
+
+// the number of slots in the acitveEntries CHC; at the moment
+// it should be a very small number because we have to do
+// a linear search on it (the HandoverManager)
+# define HLS_ACTIVE_ENTRIES_SIZE 37
+
+#define hls_verbose true
+#define hls_trace_updates true // must be set explicitly to trace
+// the sending and receiving of updates
+#define hls_trace_handovers true // tracing of sending and receiving
+// the handover of activeEntries
+
+#define HLS_HANDOVER_INTERVALL 2 // in seconds, the intervall in
+// which the handover manager will check the entries
+#define HLS_HANDOVER_JITTER 0.500 // the jitter in the timer to
+// avoid collisions
+
+class UpdateSender;
+class Store;
+class Cellbuilder;
+class UpdateReceiver;
+class RequestProcessor;
+class CleanPosinfoTimer;
+class HLS;
+class HLSLocationCache;
+class HandoverTimer;
+
+
+
+#define HDR_HLS(p) (hdr_hls::access(p))
+
+#define HLS_TTL 60
+#define HLS_REQUEST_TTL_PER_LEVEL 30
+#define HLS_UPDATE_TTL_PER_LEVEL 10
+// if the above HLS_REQUEST_TTL_PER_LEVEL is for example = 30, a 
+// request to a first level rc gets a ttl of 30, one to a 
+// second level RC a ttl of 60 and so on, it is always multiplied
+// by the level.
+
+#define HLS_UPDATE             1
+#define HLS_REQUEST            2
+#define HLS_REPLY              3
+#define HLS_CELLCAST_REQUEST   4
+#define HLS_CELLCAST_REPLY     5
+#define HLS_CIRCLECAST_REQUEST 6
+#define HLS_HANDOVER           7
+// handover packets are aktive entries which have
+// left their cell and must be retransmitted to that cell
+// (don't use update packets to distinguish them later 
+// in the tracefiles)
+
+// status_ definitions in the hls header
+#define INITIAL_STATUS 0
+//#define NO_INFORMATION_STATUS 1
+//#define HAVE_INFORMATION_STATUS 2
+#define ON_THE_FLY_UPDATE       3 // a poslookup has been executed 
+// successfully for this packet, we have included our posinfo in
+// the SRC to keep my counterpart in sync 
+#define REQUEST_LOCATED         4 // when we have found the location
+// of a node, we mark the packet with this flag.
+// When the packet is dropped, we know that it's because there is no
+// (greedy) route to the target.
+#define REQUEST_LOCATED_AND_RETRIED 5 // before dropping a packet 
+// because of a "located but no route" error, we try to send it
+// directly to that node, it's quite possible that a beacon was lost
+// and the node is still in reach. To avoid infinite recursion (e.g when
+// the MAC-layer returns the packet), we change the state once again to 
+// drop the packet afterwards)
+
+// DROP Reasons
+#define LOCATED_AND_NO_ROUTE     "LNR"
+#define CIRCELCAST_ALREADY_SEND  "CAS"
+#define CIRCLECAST_TIMEOUT       "CTO"
+
+
+
+#define HLS_UPDATE_JITTER         1 /* 0-1000 ms Delay in update to 
+					   avoid collisions */
+#define HLS_UPDATE_CHECK_INTERVALL      2     // in this intervall, HLS will check if
+                                              // updates are necessary
+#define HLS_MAX_UPDATE_INTERVALL        9    // this defines the Maximum time which 
+// should lie between updates for the top level cell (and the cell on the second highest
+// level if  TIME_TRIGGERED_FOR_SECOND_HIGHEST_LEVEL is defined)
+#define TIME_TRIGGERED_UPDATES_FOR_SECOND_HIGHEST_LEVEL
+
+// how long an entry will be kept in the active and passive
+// store before it is deleted
+#define ENTRY_LIFETIME 20
+#define HLS_MAX_CACHE_LOOKUP_AGE       10  // determines the max age of a cache lookup
+// (i.e. we return the position out of our cache if it is young enough to be still
+// valid)
+#define HLS_UPDATE_DISTANCE            250 // distance before a update gets necessary
+#define HLS_UPDATE_STARTUP             2   // the second in which the earliest update will be
+#define HLS_UPDATE_STARTUP_MAX_JITTER  11  // avoid all the collisions at startup
+#define HLS_UPDATE_STARTUP_GROUPS      5  // defines the number of groups in which the 
+// nodes schedule their first updates (the membership is determined by a modulo operation
+// on the node's id)
+
+
+#define NUMBER_OF_NEIGHBOR_CELLS 8 // the max number of cells which another cells
+// can have as neighbors
+#define NO_CELL                  -1 // to initialize the neighbors table in
+// a circelcast packet and to indicate that the entry is empty (e.g if we
+// have to transmit the circle cast packet to the neighbors of a cell which 
+// is a cell on the border, this cell doesn't have 8 neighbors but only 5.
+// Thus the neighbors fields from 5-7 will contain NO_CELL
+
+// if aggressive caching is defined, nodes will grep all information they
+// could an cache them
+//#define AGGRESSIVE_CACHING
+
+#define CELLCAST_BUFFER_SIZE 5  // the number of places in the cellcast buffer
+// is the max number of cellcast which can be performed by a node in parallel
+#define CELLCAST_BUFFER_ENTRY_TIMEOUT 0.2   // how long the sender of a 
+// cellcast request will wait for answers. After the expiration of this 
+// amount of time, the cellcast will be declared to have failed, the
+// request will be forwarded to the RC on the next level
+#define CIRCLECAST_ENTRY_TIMEOUT 0.6 // how long the sender of a 
+// circlecast request will wait for answers. After the expiration of this 
+// amount of time, the circlecast will be declared to have failed
+
+#define CELLCAST_BUFFER_CHECK_INTERVALL 0.1 // how often the cellcast buffer
+// will be checked for expired entries;
+#define CELLCAST_ANSWER_JITTER          0.08 // the intervall in which we chose
+// a random jitter before sending an answer (if we haven't heard an answer of
+// somone else before)
+
+////////////////////////////////////////////////////////
+// packet format and other types ///////////////////////
+////////////////////////////////////////////////////////
+typedef struct nodeposition {
+  nsaddr_t id;
+  double ts;
+  position pos;
+  
+  int targetcell; // the id of the cell to which this nodposition
+  // belongs to (if it was send as a update)
+  // identifies the cell where it should be stored as
+  // activeEntry
+
+  // copies the information in n in this struct
+  void copyFrom(nodeposition *n)
+  {
+    id = n->id;
+    ts = n->ts;
+    pos.x = n->pos.x;
+    pos.y = n->pos.y;
+    pos.z = n->pos.z;
+    targetcell = n->targetcell;
+  }
+};
+
+// this is the unique request id which every request 
+// will contain (for easier tracing)
+struct request_id {
+  int node;  // the node which sent the request
+  int nr;    // the unique number
+
+  request_id()
+  {
+     node = NO_NODE; 
+     nr = -1;
+  }
+
+  request_id(int node, int nr)
+  {
+    this->node = node;
+    this->nr   = nr;
+  }
+
+  inline bool equals(request_id* id2) { 
+    if((node == id2->node) && 
+       (nr   == id2->nr)) 
+      return true;
+  return false;
+  }
+
+  inline void set(request_id id2)
+  {
+    node = id2.node;
+    nr   = id2.nr;
+  }
+
+  inline void init() { node = NO_NODE; nr = -1;}
+
+};
+
+// this identifies a cell in the packet
+// used for updates and requests, therefore all geo-anycast
+// packets
+typedef struct struct_cell {
+  int id;         // id of the cell
+  int level;      // the level on which the cell is (perspective
+                  // of the sender)
+  position pos;   // position of the cell
+  
+  void init()
+  {
+    id = NO_NODE;
+    level = -1;
+    pos.x = 0;
+    pos.y = 0;
+    pos.z = 0;
+  }
+};
+
+struct hdr_hls {
+  nodeposition src;
+  nodeposition dst;
+
+  int cellcastRequestSender; // only for cellcasts, in all other
+  // cases, this is -2
+  
+  int type_; // the type of the packet, e.g. an update
+  int status_; // the status, e.g. for marking the return packet
+  // to a broadcast request in a cell (you can mark it as
+  // "i had information about the node" or as "i don't know the
+  // location of the node"; at the moment, no negative packets
+  // are send
+  
+  request_id reqid; // only for request packets (all packets 
+  // associatet with a request will have the same reqid, that
+  // means the request, the cellcast packets and also the reply)
+  // if it isn't a request packet, the reqid will contain -1
+  // in both fields
+
+  struct_cell cell; // the target cell of a geo-anycast
+  // that means the target of a update or a request
+
+  // only for tracing updates, contains the reason of the update
+  const char* updreason_;
+
+  // the following fields are necessary for the backup of the 
+  // cell on the highest level. They are used in the cellcastCircle
+  // mode
+  int neighbors[NUMBER_OF_NEIGHBOR_CELLS]; // contains the list of 
+  // neighbors to which the packet should be sent (first to the 
+  // neighbor[0] cell, than to the neighbor[1] cell,..
+  // the initialized entries contain -1
+  int neighborIndex; // the index in the array neighbors indicastes 
+  // to which cell the packet is actually send
+  bool circleCastAlreadySend; // this field is a marker for a packet;
+  // it doesn't have to be send over the "network", it is a workaround
+  // to avoid keeping a list of all packets for which we have sent a
+  // circlecast. Instead we mark the packet and drop it if we want to
+  // send a second circlecast for it.
+  int numberOfNodeinfosToHandover; // this parameter is only used in the
+  // advanced handover mangaer: it indicates how much nodeposition entries
+  // we transmit with this packet
+
+   void init() {
+     src.id = NO_NODE;
+     src.ts = -1.0;
+     src.pos.x = -1.0;
+     src.pos.y = -1.0;
+     src.pos.z = -1.0;
+
+     dst.id = NO_NODE;
+     dst.ts = -1.0;
+     dst.pos.x = -1.0;
+     dst.pos.y = -1.0;
+     dst.pos.z = -1.0;
+
+     cellcastRequestSender = -2;
+
+     type_ = 0;
+     status_ = INITIAL_STATUS;
+
+     reqid.init();
+
+     cell.init();
+
+     updreason_ = "";
+
+     for(int i=0;i<NUMBER_OF_NEIGHBOR_CELLS;i++)
+       {
+	 neighbors[i] = NO_CELL;       
+       }
+     neighborIndex = -1;
+
+     circleCastAlreadySend = false;
+     numberOfNodeinfosToHandover = -1;
+   }
+ 
+  static int offset_;
+  inline static int& offset() { return offset_;}
+  inline static hdr_hls* access(const Packet* p) {
+    return (hdr_hls*) p->access(offset_);
+  }
+};
+
+// stores the information necessary to go on after a node
+// receives a response to a cellcast request
+struct cellcastEntry {
+  double timeout; // the timestamp when the cellcast has a timeout
+  request_id* id;  // the id of the request (consiting of the
+  // node and a unique number)
+  bool circlecast;
+  Packet* p; // the request packet which contains the info
+};
+
+////////////////////////////////////////////////////////
+// prototypes //////////////////////////////////////////
+////////////////////////////////////////////////////////
+
+// is responsible for sending position information 
+// updates
+class UpdateSender
+{
+  public :
+    UpdateSender(){};
+    UpdateSender(Cellbuilder* cellbuilder, HLS* hls);
+  virtual void start(); // responisble for starting the
+                        // the update sender
+
+  protected : 
+    Cellbuilder* cellbuilder_;
+  HLS * hls_;
+    
+};
+
+// the methods here are called whenever an update packet
+// arrives at the node
+class UpdateReceiver
+{
+  public :
+    UpdateReceiver(){};
+    UpdateReceiver(HLSLocationCache* activeEntries, 
+		   HLSLocationCache* passiveEntries,
+		   HLSLocationCache* outOfCellEntries,
+		   HLS* hls);
+    virtual void recv(Packet* &p, bool forceActiveSave);
+  protected :
+    HLSLocationCache* activeEntries_;
+    HLSLocationCache* passiveEntries_;
+    HLSLocationCache* outOfCellEntries_;
+    HLS*   hls_;
+};
+
+// the methods here are called whenever a position request
+// arrives at a node
+class RequestProcessor
+{ 
+  public :
+    RequestProcessor(){};
+    RequestProcessor(HLSLocationCache* passiveEntries, HLS* hls);
+    virtual void recv(Packet* &p);
+    virtual void recvCellcastRequest(Packet* &p);
+    virtual void cellcastReplyOnMacReceived(const Packet* p);
+    virtual void recvCellcastReply(Packet* &p);
+    virtual void processRequestUnreachableCell(Packet* &p);
+    virtual void recvCirclecastRequest(Packet* &p, bool fromDropCallback);    
+    virtual void circlecastRequestOnMacReceived(const Packet* p);
+
+  protected :
+    HLSLocationCache* passiveEntries_;
+    HLS*   hls_;
+    virtual Packet* newReply(Packet* req, struct nodeposition* infosrc);
+    virtual void sendCellcastReply(const Packet* req, struct nodeposition* info);
+};
+
+// this class is responsible for managing the handover of active position
+// information. That means it tests if we are still in the correct cell
+// and sends a handover packet to the RC if we have left it.
+class HandoverManager
+{  
+  public :
+  HandoverManager(HLSLocationCache* activeEntries, 
+		  HLSLocationCache* passiveEntries,
+		  HLSLocationCache* outOfCellEntries,
+		  HLS* hls,
+		  Cellbuilder* cellbuilder); 
+  virtual ~HandoverManager();
+  // will be called whenever HLS receives a handover packet.
+  virtual void recv(Packet* &p, bool forceActiveSave)
+    {printf("HandoverManager.recv() called\n");};
+  virtual void timerCallback(){printf("HandoverManager.callback() called\n");}; 
+  // called when the timer expired
+
+  protected :
+    // called when we discoverd in the timerCallback that there is
+    // information which should be in another cell
+    virtual void handoverInformation(nodeposition* info){};
+
+    HLSLocationCache* activeEntries_;
+    HLSLocationCache* passiveEntries_;
+    HLSLocationCache* outOfCellEntries_;
+    HLS*   hls_;
+    Cellbuilder* cellbuilder_;
+    HandoverTimer* timer_;      // responsible for periodically calling 
+                               // the callback
+    int lastCell;         // remembers the id of the last cell in which
+    // the node has been (thus enables me to determine when we changed
+    // the cell)
+}; // end handover manager
+
+
+class HandoverTimer : public TimerHandler
+{
+  public :
+    HandoverTimer(HandoverManager* manager, double intervall);
+
+  protected :
+    void expire(Event* e);
+
+  private :
+    double intervall_; // meassured in seconds
+  HandoverManager* manager_;  
+};// end HandoverTimer
+
+class HLS : public LocationService {
+
+ public:
+    HLS(Agent* p);
+    ~HLS();
+ 
+    void recv(Packet* &p);
+    bool poslookup(Packet *p);
+    void init(); 
+    void evaluatePacket(const Packet *p);
+    int hdr_size(Packet* p); // returns the size the LS part of the header
+    void dropPacketCallback(Packet* &p);
+    int getCell(); // returns the id of the cell in which we are
+    // at the moment
+    
+
+    protected :
+      Packet* allocpkt() { return parent->allocpkt(); }
+      Cellbuilder* cellbuilder_;     
+      nodeposition* findEntry(int nodeid);
+      nodeposition* findActiveEntry(int nodeid);
+      nodeposition getNodeInfo();
+      
+    private :
+      UpdateSender* updateSender_;
+      HLSLocationCache* activeEntries_;  // contains the active entries
+      // (these are the entries which belong to the cell
+      // in which we are, no cached entries here)
+      HLSLocationCache* passiveEntries_; // contains the passive entries
+      // (cached entries which are filtered out of the
+      // network traffic, posinfo extracted from beacons and replies to
+      // location query packets)
+      HLSLocationCache* outOfCellEntries_; // contains the entries
+      // which must be stored (the target cell couldn't be reached, so
+      // we have to store them and retry a transmit to that cell later).
+      UpdateReceiver* updateReceiver_;
+      RequestProcessor* requestProcessor_;
+      HandoverManager* handoverManager_;
+
+      LSRequestCache* reqtable_; // stores the requests we have sent
+      int lastReqNr;             // stores the number of the last req
+
+      void sendGeocast();
+      bool sendRequest(int nodeid, int level);
+      void processReply(Packet* &p);
+
+    // declare the update senders as friends to enable their
+    // access to the parent, ...
+    friend class BasicUpdateSender;
+    friend class BasicUpdateReceiver;
+    friend class RequestProcessor;
+    friend class BasicRequestProcessor;
+    friend class CellcastAnswerTimer; // for access to parent_
+    friend class BasicHandoverManager;
+    friend class AdvancedHandoverManager;
+    
+};
+
+// returns the distance between the actual location of the node nodeid
+// and the given position
+extern double distance(int nodeid, position pos);
+
+void printUsageStatistics();
+
+#endif // ns_hls_h
diff -u -r --new-file ./hls/position.h ../../ns-2.33-hls_working/ns-2.33/hls/position.h
--- ./hls/position.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/position.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef position
+#define position
+
+class position
+{
+  public :
+  int x;
+  int y;
+  int z;
+}position;
+
+#endif
diff -u -r --new-file ./hls/quadratic.cc ../../ns-2.33-hls_working/ns-2.33/hls/quadratic.cc
--- ./hls/quadratic.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/quadratic.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,591 @@
+#include "quadratic.h"
+#include <math.h>
+#include <stdio.h>
+
+// defines the length of a level-n-region meassured in
+// level-n-1-regions 
+#define REGION_LENGTH 3 
+// defines the heigth of a level-n-region meassured in
+// level-n-1-regions 
+#define REGION_HEIGTH 3
+
+#define FACTOR 2
+// necessary for the V2. REGION_LENTH and .._HEIGTH 
+// above now stand for the base size of a region, the
+// factor indicates the growth. e.g. lenght = heigth = 3,
+// factor = 2: level one Region 3x3, level 2 region 6x6
+// level 3 region 12x12 and so on
+#define HIGHEST_LEVEL_CENTER_ZONE_SIDELENGTH 1.0
+// the sidelength of the area in the center of the 
+// simulation field for the highest level rcs (these should
+// be in the center of the area)
+// meassured in fraction of the total length and heigth
+// thus 0 < HIGHEST_LEVEL_CENTER_ZONE_SIDELENGTH <= 1
+
+// the quadratic cellbuilder divides the array in squares
+// with a diagonal which is equal to the radio range
+// the id's for the cell are assigned from left to right
+// and from bottom to top :
+//
+// +---+---+---+---+---+---+---+---+---+          +
+// | 18| 19| 20| 21| 22| 23| 24| 25| 26|
+// +---+---+---+---+---+---+---+---+---+
+// | 9 | 10| 11| 12| 13| 14| 15| 16| 17|     0
+// +---+---+---+---+---+---+---+---+---+
+// | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
+// +---+---+---+---+---+---+---+---+---+
+// +     0     +     1     +     2     +          +    
+//
+
+
+// this cellbuilder is still in a prototype state,
+// bugs are possible !!
+
+QuadraticCellbuilder::QuadraticCellbuilder
+   (double radiorange, double fieldsize_x, double fieldsize_y)
+       : Cellbuilder(radiorange, x, y)
+    {
+      this->radiorange = radiorange;
+      this->x = fieldsize_x;
+      this->y = fieldsize_y;
+      printf("radiorange %.f, x %.f y %.f\n", radiorange,x,y);
+
+      // determine the length and heigth of one square
+      double tmp = sqrt(((radiorange) * (radiorange)) / 2);
+
+      // used to round it to the next lower int
+      squarelength = (int) floor(tmp); 
+      tmp = x / squarelength;
+      // round to the next bigger int
+      cellsPerLine = (int) ceil(tmp);
+
+      tmp = y / squarelength;
+      cellsPerColumn = (int) ceil(tmp);
+
+      double factorLength, factorHeigth;
+      factorLength = (log((double)cellsPerLine/REGION_LENGTH)/ log(2.0))+1;
+      factorHeigth = (log((double)cellsPerColumn/REGION_HEIGTH)/log(2.0))+1;
+      
+      printf("length : %f , cellperline %d , heigth %f\n", factorLength, cellsPerLine, factorHeigth);
+      
+      if(factorLength > factorHeigth)
+	{
+	  tmp = factorLength;
+	}
+      else
+	{
+	  tmp = factorHeigth;
+	}
+      maxLevel = (int) ceil(tmp);
+      printf("maxlevel %d\n", maxLevel);
+    }
+
+
+// returns the id number of the cell to which the given
+// position belongs to
+int QuadraticCellbuilder::getCellID (position position)
+{
+  int line, column;
+  line   = (int) (position.y / squarelength);
+  column = (int) position.x / squarelength;
+  
+  return (line*cellsPerLine) + column;
+}
+
+
+// returns the region on level LEVEL to which this position belongs to
+int QuadraticCellbuilder::getRegion (position position, int level)
+{
+  if(level > maxLevel)
+    {
+      return NO_VALID_LEVEL;
+    }
+
+  int cellid = getCellID(position);
+  
+  int line = cellid / cellsPerLine;
+  int column = cellid % cellsPerLine;  
+  
+
+  // length and heigth are meassured in numbers of cells
+  int length = (int)  pow(2.0, level-1)*REGION_LENGTH;
+  int heigth = (int) pow(2.0, level-1)*REGION_HEIGTH;
+
+  column = column / length;
+  line = line / heigth;
+  int regionsPerLine = (cellsPerLine / length) + 1;
+
+  return (line*regionsPerLine) + column;
+}
+
+
+// returns the responsible cell (RC) on the level for the
+// node with NODEID in the region to which position belongs to
+// (so it can be determined which cell is responsible for the node
+// nodeid in the region to which position belongs to)
+int QuadraticCellbuilder::getRC (int nodeid, int level, position position)
+{
+  if(level > maxLevel)
+    {
+      return NO_VALID_LEVEL;
+    }
+
+  int region = getRegion(position, level);
+  
+  // length of a region on this level, meassured in cells
+  int length = (int)  pow(2.0, level-1)*REGION_LENGTH;
+
+  // heigth of a region on this level, meassured in cells
+  int heigth = (int) pow(2.0, level-1)*REGION_HEIGTH;
+  
+  // compute nodeid mod count of the cells in the region
+  // This makes sure competences are evenly distributed
+  
+  // adding the level to also make the decision depending on it
+  int cell = (nodeid + level) % (length*heigth);
+
+  int lineInRegion = cell / length;
+  int columnInRegion = cell % length;
+
+  int regionsPerLine = (cellsPerLine) / length + 1;
+
+  int lineOfRegion = ((region / regionsPerLine) * heigth);
+  int columnOfRegion = ((region % regionsPerLine) * length);
+
+  int lineAbsolute = lineOfRegion + lineInRegion;
+  int columnAbsolute = columnOfRegion + columnInRegion;
+
+
+  return (lineAbsolute*cellsPerLine) + columnAbsolute;
+
+}
+
+
+// returns the position of the cell with CELLID
+// (the geographical center of the cell)
+position QuadraticCellbuilder::getPosition (int cellid)
+{
+  position tmp = position();
+  tmp.x = 0;
+  tmp.y = 0;
+
+  int line = cellid / cellsPerLine;
+  int column = cellid % cellsPerLine;
+
+  tmp.x = (int) ((column * squarelength) + (0.5 * squarelength))/1;
+  tmp.y = (int) ((line * squarelength) + (0.5 * squarelength))/1;
+
+  return tmp;
+}
+
+
+int QuadraticCellbuilder::getMaxLevel()
+{
+  return maxLevel;
+}
+
+// purpose of the function:
+// determine the neighbor cells of the cell with cellid. Neighbor-cells are those
+// who share an edge with the given cell (in the quadratic version, there at max
+// 8 neighbor cells, at min 3 (if the cell is in the edge)
+// RETURN: *number contains the number of neighbors, *result an array with the 
+// cellids
+// !!! copied from CellbuilderV2 !!!
+void QuadraticCellbuilder::getNeighborCells(int cellid, int* number, 
+					      int** result)
+{
+  // calculation:
+  // +---+---+---+---+
+  // | 18| 19| 20| 21| 
+  // +---+---+---+---+
+  // | 9 | 10| 11| 12|
+  // +---+---+---+---+
+  // | 0 | 1 | 2 | 3 | 
+  // +---+---+---+---+
+  // consider we want to have the neighbors of 11:
+  // take line (=1) and column (=2) of 11, subtract one (so we
+  // have the line (=0) and column (=1) of cell 1 and check the 
+  // 9 combinations of line and column (check if they are in our simulation 
+  // area).
+
+  int line = cellid / cellsPerLine;
+  int column = cellid % cellsPerLine;
+  line -= 1; // we start at the lower left edge of the 8 sorounding cells
+  column -= 1;
+  int localResult[8]; // we have 8 neighbors at max
+  int resultCounter = 0;
+
+  int tmpLine = line;
+  if(isLineValid(tmpLine)) // check if line is in field
+    {
+      for(int k=0;k<3;k++) // all 3 columsn
+	{
+	  int tmpColumn = column + k;
+	  if(isColumnValid(tmpColumn))// check if column is in field
+	    {
+	      // calculate the cellid
+	      localResult[resultCounter] = (tmpLine*cellsPerLine) + tmpColumn;
+	      resultCounter++;
+	    }	      
+	}
+    }
+
+  tmpLine = line+1;
+  // field on the right hand side
+  // ...
+  // ..x
+  // ...
+  if(isColumnValid(column+2))// check if column is in field
+    {
+      // calculate the cellid
+      localResult[resultCounter] = (tmpLine*cellsPerLine) + column+2;
+      resultCounter++;
+    }
+
+  tmpLine = line+2;
+  // highest line (from right to left)
+  // xxx
+  // ...
+  // ...
+  if(isLineValid(tmpLine)) // check if line is in field
+    {
+      for(int k=2;k>=0;k--) // all 3 columsn from right to left
+	{
+	  int tmpColumn = column + k;
+	  if(isColumnValid(tmpColumn))// check if column is in field
+	    {
+	      // calculate the cellid
+	      localResult[resultCounter] = (tmpLine*cellsPerLine) + tmpColumn;
+	      resultCounter++;
+	    }	      
+	}
+    }
+
+  tmpLine = line+1;
+  // and the last on on the left
+  // ...
+  // x..
+  // ...
+  if(isColumnValid(column))// check if column is in field
+    {
+      // calculate the cellid
+      localResult[resultCounter] = (tmpLine*cellsPerLine) + column;
+      resultCounter++;
+    }
+  
+
+  
+  *result = new int[8];
+  
+  for(int i=0;i<8;i++)
+    {
+      if(i<resultCounter)
+	{
+	  (*result)[i] = localResult[i];
+	}
+      else
+	{
+	  (*result)[i] = -1;
+	}
+    }
+  *number = 8;
+      
+}
+
+
+
+
+//////////////////////////////////////////////////////////
+// the second version of the quadratic cellbuilder
+// it is a special version for a 2000 x 2000 scenario
+// the REGION_LENGTH defines here the size of a level 1 region
+// (meassured in cells). The building of the region is here
+// top-down, that means the cellbuilder divides the area of 
+// the simulation in four, these four in 16 and each of these
+// areas is now 3 cells long and high
+//////////////////////////////////////////////////////////
+QuadraticCellbuilderV2::QuadraticCellbuilderV2
+   (double radiorange, double fieldsize_x, double fieldsize_y)
+  : Cellbuilder(radiorange, x, y)
+    {
+      this->radiorange = radiorange;
+      this->x = fieldsize_x;
+      this->y = fieldsize_y;
+
+      // determine the length and heigth of one square
+      double tmp = sqrt(((radiorange) * (radiorange)) / 2);
+
+      // used to round it to the next lower int
+      squarelength = (int) floor(tmp); 
+      tmp = x / squarelength;
+      // round to the next bigger int
+      cellsPerLine = (int) ceil(tmp);
+
+
+      tmp = y / squarelength;
+      cellsPerColumn = (int) ceil(tmp);
+
+      numberOfCells = cellsPerLine * cellsPerColumn;
+
+      double factorLength, factorHeigth;
+      factorLength = log((double)cellsPerLine)/log((double)REGION_LENGTH);
+      factorHeigth = log((double)cellsPerColumn)/log((double)REGION_HEIGTH);
+      
+      
+      if(factorLength > factorHeigth)
+	{
+	  tmp = factorLength;
+	}
+      else
+	{
+	  tmp = factorHeigth;
+	}
+      maxLevel = (int) ceil(tmp);
+    }
+
+
+// returns the id number of the cell to which the given
+// position belongs to
+int QuadraticCellbuilderV2::getCellID (position position)
+{
+  int line, column;
+  line   = (int) (position.y / squarelength);
+  column = (int) position.x / squarelength;
+  
+  return (line*cellsPerLine) + column;
+}
+
+
+// returns the region on level LEVEL to which this position belongs to
+int QuadraticCellbuilderV2::getRegion (position position, int level)
+{
+  if(level > maxLevel)
+    {
+      return NO_VALID_LEVEL;
+    }
+
+  if(level == maxLevel)
+    {
+      return 1;
+    }
+
+  int cellid = getCellID(position);
+  
+  int line = cellid / cellsPerLine;
+  int column = cellid % cellsPerLine;  
+  
+
+  // length and heigth are meassured in numbers of cells
+  int length = (int) (REGION_LENGTH * pow((double)FACTOR, level-1));
+  int heigth = (int) (REGION_HEIGTH * pow((double)FACTOR, level-1));
+
+  column = column / length;
+  line = line / heigth;
+  int regionsPerLine = (cellsPerLine / length) + 1;
+
+  return (line*regionsPerLine) + column;
+}
+
+
+// returns the responsible cell (RC) on the level for the
+// node with NODEID in the region to which position belongs to
+// (so it can be determined which cell is responsible for the node
+// nodeid in the region to which position belongs to)
+int QuadraticCellbuilderV2::getRC (int nodeid, int level, position position)
+{
+  if(level > maxLevel)
+    {
+      return NO_VALID_LEVEL;
+    }
+  
+  int region = getRegion(position, level);
+  
+  // length of a region on this level, meassured in cells
+  int length; 
+  int heigth; 
+  if(level < maxLevel)
+    {
+      length = (int) (REGION_LENGTH * pow((double)FACTOR, level-1));
+      // heigth of a region on this level, meassured in cells
+      
+      heigth = (int) (REGION_HEIGTH * pow((double)FACTOR, level-1));
+    }
+  else
+    {
+      // we are on the maxlevel, the rc's on the highest levels
+      // should be somewhere in the center of the aread.
+      length = (int) ceil(cellsPerLine*HIGHEST_LEVEL_CENTER_ZONE_SIDELENGTH);
+      heigth = (int) ceil(cellsPerColumn*HIGHEST_LEVEL_CENTER_ZONE_SIDELENGTH);
+    }
+  
+
+  // compute nodeid mod count of the cells in the region
+  // This makes sure competences are evenly distributed
+
+  int lineAbsolute;
+  int columnAbsolute;
+
+  // adding the level to also make the decision depending on it
+  int cell = (nodeid + level) % (length*heigth);
+  
+  int lineInRegion = cell / length;
+  int columnInRegion = cell % length;
+  
+  if(level < maxLevel)
+    {      
+      int regionsPerLine = (cellsPerLine) / length + 1;
+      
+      int lineOfRegion = ((region / regionsPerLine) * heigth);
+      int columnOfRegion = ((region % regionsPerLine) * length);
+      
+      lineAbsolute = lineOfRegion + lineInRegion;
+      columnAbsolute = columnOfRegion + columnInRegion;
+    }
+  else
+    {
+      // maxLevel
+      lineAbsolute = ((cellsPerLine-length)/2) + lineInRegion;
+      //             < line of region       >
+      columnAbsolute = ((cellsPerColumn-heigth)/2) + columnInRegion;
+      //                < column of region      >
+    }
+
+
+  // the "% numberOfCells" assures that cell we return is a valid one
+  return ((lineAbsolute*cellsPerLine) + columnAbsolute) % numberOfCells;
+
+}
+
+
+// returns the position of the cell with CELLID
+// (the geographical center of the cell)
+position QuadraticCellbuilderV2::getPosition (int cellid)
+{
+  position tmp = position();
+  tmp.x = 0;
+  tmp.y = 0;
+
+  int line = cellid / cellsPerLine;
+  int column = cellid % cellsPerLine;
+
+  tmp.x = (int) ((column * squarelength) + (0.5 * squarelength))/1;
+  tmp.y = (int) ((line * squarelength) + (0.5 * squarelength))/1;
+
+  return tmp;
+}
+
+int QuadraticCellbuilderV2::getMaxLevel()
+{
+  return maxLevel;
+}
+
+// purpose of the function:
+// determine the neighbor cells of the cell with cellid. Neighbor-cells are those
+// who share an edge with the given cell (in the quadratic version, there at max
+// 8 neighbor cells, at min 3 (if the cell is in the edge)
+// RETURN: *number contains the number of neighbors, *result an array with the 
+// cellids
+void QuadraticCellbuilderV2::getNeighborCells(int cellid, int* number, 
+					      int** result)
+{
+  // calculation:
+  // +---+---+---+---+
+  // | 18| 19| 20| 21| 
+  // +---+---+---+---+
+  // | 9 | 10| 11| 12|
+  // +---+---+---+---+
+  // | 0 | 1 | 2 | 3 | 
+  // +---+---+---+---+
+  // consider we want to have the neighbors of 11:
+  // take line (=1) and column (=2) of 11, subtract one (so we
+  // have the line (=0) and column (=1) of cell 1 and check the 
+  // 9 combinations of line and column (check if they are in our simulation 
+  // area).
+
+  int line = cellid / cellsPerLine;
+  int column = cellid % cellsPerLine;
+  line -= 1; // we start at the lower left edge of the 8 sorounding cells
+  column -= 1;
+  int localResult[8]; // we have 8 neighbors at max
+  int resultCounter = 0;
+  int tmpLine = line;
+  
+  // first line (from left to right)
+  // ...
+  // ...
+  // xxx
+  if(isLineValid(tmpLine)) // check if line is in field
+    {
+      for(int k=0;k<3;k++) // all 3 columsn
+	{
+	  int tmpColumn = column + k;
+	  if(isColumnValid(tmpColumn))// check if column is in field
+	    {
+	      // calculate the cellid
+	      localResult[resultCounter] = (tmpLine*cellsPerLine) + tmpColumn;
+	      resultCounter++;
+	    }	      
+	}
+    }
+
+  tmpLine = line+1;
+  // field on the right hand side
+  // ...
+  // ..x
+  // ...
+  if(isColumnValid(column+2))// check if column is in field
+    {
+      // calculate the cellid
+      localResult[resultCounter] = (tmpLine*cellsPerLine) + column+2;
+      resultCounter++;
+    }
+
+  tmpLine = line+2;
+  // highest line (from right to left)
+  // xxx
+  // ...
+  // ...
+  if(isLineValid(tmpLine)) // check if line is in field
+    {
+      for(int k=2;k>=0;k--) // all 3 columsn from right to left
+	{
+	  int tmpColumn = column + k;
+	  if(isColumnValid(tmpColumn))// check if column is in field
+	    {
+	      // calculate the cellid
+	      localResult[resultCounter] = (tmpLine*cellsPerLine) + tmpColumn;
+	      resultCounter++;
+	    }	      
+	}
+    }
+
+  tmpLine = line+1;
+  // and the last on on the left
+  // ...
+  // x..
+  // ...
+  if(isColumnValid(column))// check if column is in field
+    {
+      // calculate the cellid
+      localResult[resultCounter] = (tmpLine*cellsPerLine) + column;
+      resultCounter++;
+    }
+  
+
+  
+  *result = new int[8];
+  
+  for(int i=0;i<8;i++)
+    {
+      if(i<resultCounter)
+	{
+	  (*result)[i] = localResult[i];
+	}
+      else
+	{
+	  (*result)[i] = -1;
+	}
+    }
+  *number = 8;
+      
+}
diff -u -r --new-file ./hls/quadratic.h ../../ns-2.33-hls_working/ns-2.33/hls/quadratic.h
--- ./hls/quadratic.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/quadratic.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,121 @@
+#ifndef quadratic_h
+#define quadratic_h
+
+#include "cellbuilder.h"
+
+class QuadraticCellbuilder : public Cellbuilder
+{
+  public :
+    QuadraticCellbuilder(double radiorange, double fieldsize_x, double fieldsize_y);
+
+    
+      int getCellID (position position);
+
+      int getRegion (position position, int level);
+
+      int getRC (int nodeid, int level, position position);
+
+      position getPosition (int cellid);
+
+      int getMaxLevel();
+      
+      void print(position p);
+      void getNeighborCells(int cellid, int* number, int** result);
+      
+
+ private:
+      double radiorange; // the transmission range
+      double x;          // the size of the field (it's length)
+      double y;          // the size of the field (it's heigth)
+      int squarelength;     // the length and heigth of one square
+      int cellsPerLine; // the number of cells which are on the same
+                        // line in x-direction
+      int cellsPerColumn;
+      int maxLevel;     // the biggest level possible (on this level, 
+      // there is only one region which consist of the whole simulation
+      // area)
+      inline bool isLineValid(int line) {
+	if((0 <= line) && (line < cellsPerLine))
+	  {
+	    return true;
+	  }
+	else 
+	  {
+	    return false;
+	  }
+      };
+      inline bool isColumnValid(int column) {
+	if((0 <= column) && (column  < cellsPerColumn))
+	  {
+	    return true;
+	  }
+	else 
+	  {
+	    return false;
+	  }	
+      };
+};
+
+
+// this is the second, improved version of the QuadraticCellbuilder;
+// it tries to concentrate the highest level RCs in the center of the
+// area, it also contains some "bugfixes" which led to strange 
+// behaviour in the first version
+class QuadraticCellbuilderV2 : public Cellbuilder
+{
+
+  public :
+    QuadraticCellbuilderV2(double radiorange, double fieldsize_x, double fieldsize_y);
+
+    
+      int getCellID (position position);
+
+      int getRegion (position position, int level);
+
+      int getRC (int nodeid, int level, position position);
+
+      position getPosition (int cellid);
+
+      int getMaxLevel();
+
+      void getNeighborCells(int cellid, int* number, int** result);
+      
+
+ private:
+      double radiorange; // the transmission range
+      double x;          // the size of the field (it's length)
+      double y;          // the size of the field (it's heigth)
+      int squarelength;     // the length and heigth of one square
+      int cellsPerLine; // the number of cells which are on the same
+                        // line in x-direction
+      int cellsPerColumn;
+      int maxLevel;     // the biggest level possible (on this level, 
+      // there is only one region which consist of the whole simulation
+      // area)
+      int numberOfCells; // the number of cells used in this simulation
+      inline bool isLineValid(int line) {
+	if((0 <= line) && (line < cellsPerLine))
+	  {
+	    return true;
+	  }
+	else 
+	  {
+	    return false;
+	  }
+      };
+      inline bool isColumnValid(int column) {
+	if((0 <= column) && (column  < cellsPerColumn))
+	  {
+	    return true;
+	  }
+	else 
+	  {
+	    return false;
+	  }	
+      };
+      
+};
+
+#endif
+
+
diff -u -r --new-file ./hls/README_HLS ../../ns-2.33-hls_working/ns-2.33/hls/README_HLS
--- ./hls/README_HLS	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/README_HLS	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,31 @@
+Information for HLS testing
+
+This is a version of ns-2 with support for HLS (Hierarchical Location Service)
+The corresponding HLS sourcecode can be found in "ns-2.33/hls/"
+Additional scripts are contained in "ns-2.33/hls/utils".
+
+
+Scenario/Traffic:
+There are two files in ns-2.33/hls/utils that generate traffic patterns and scenarios. Usage is explained, when you type "./scengen" for scenario or "./trafgen" for traffic.
+
+
+Running:
+After successfull compilation, go to the utils directory and type
+
+ns hls.tcl
+
+This should start a short simulation with hls. There is also a more complex possibility to start a simulation with 'run.tcl'. Type
+
+ns run.tcl -out hls_trace.txt -sc sc-x2000-y2000-n100-s30-t100-MRD -cp cp-n100-c400-15-98.tcl -nn 100 -locs 3 -use_peri 1 -x 2000 -y 2000 -mac_emu 0 -stop 100 -zip 0
+
+the attributes are explained in run.tcl. You can adjust your simulation with these.
+
+(Notice: ns is in a different directory than hls stuff. So you have to type the full pathname to your ns executable or set an alias for it)
+
+
+Analysing:
+Use the ns-2.33/hls/utils/evaluate.pl script for generating a lot of information on the results of the simulation. The other scripts in this directory can also be helpful.
+gls_evaluate.pl		: to evaluate a GLS simulation
+runfromdirectory.pl	: run a bunch of simulations 
+evFromdirectory.pl	: run a bunch of evaluations
+
diff -u -r --new-file ./hls/utils/cp-n100-c400-15-98.tcl ../../ns-2.33-hls_working/ns-2.33/hls/utils/cp-n100-c400-15-98.tcl
--- ./hls/utils/cp-n100-c400-15-98.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/cp-n100-c400-15-98.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,404 @@
+#
+# nodes: 100, max conn: 4, send rate: 0.100000, seed: 1, active nodes: 100
+#
+
+$ns_ at 15.157052578469 "[$node_(65) set ragent_] test-query 5"
+$ns_ at 15.161809181396 "[$node_(51) set ragent_] test-query 86"
+$ns_ at 15.171559079155 "[$node_(22) set ragent_] test-query 78"
+$ns_ at 15.205960570454 "[$node_(15) set ragent_] test-query 83"
+$ns_ at 15.402038364837 "[$node_(23) set ragent_] test-query 13"
+$ns_ at 15.411475469062 "[$node_(97) set ragent_] test-query 8"
+$ns_ at 15.710629381067 "[$node_(87) set ragent_] test-query 61"
+$ns_ at 15.820110364690 "[$node_(5) set ragent_] test-query 14"
+$ns_ at 16.300628677548 "[$node_(24) set ragent_] test-query 36"
+$ns_ at 16.578294566553 "[$node_(19) set ragent_] test-query 80"
+$ns_ at 17.080066645445 "[$node_(61) set ragent_] test-query 12"
+$ns_ at 17.085281481430 "[$node_(12) set ragent_] test-query 55"
+$ns_ at 17.125430326855 "[$node_(89) set ragent_] test-query 52"
+$ns_ at 17.366162654524 "[$node_(72) set ragent_] test-query 9"
+$ns_ at 17.731511184211 "[$node_(90) set ragent_] test-query 95"
+$ns_ at 18.214786973247 "[$node_(64) set ragent_] test-query 87"
+$ns_ at 18.492407294035 "[$node_(46) set ragent_] test-query 47"
+$ns_ at 18.931644203833 "[$node_(80) set ragent_] test-query 59"
+$ns_ at 19.079405504100 "[$node_(27) set ragent_] test-query 90"
+$ns_ at 19.345730047605 "[$node_(9) set ragent_] test-query 53"
+$ns_ at 19.506578006314 "[$node_(59) set ragent_] test-query 10"
+$ns_ at 19.638070873503 "[$node_(13) set ragent_] test-query 37"
+$ns_ at 19.711909240660 "[$node_(14) set ragent_] test-query 41"
+$ns_ at 19.904042852739 "[$node_(92) set ragent_] test-query 53"
+$ns_ at 20.341544846416 "[$node_(20) set ragent_] test-query 53"
+$ns_ at 20.414750051126 "[$node_(59) set ragent_] test-query 15"
+$ns_ at 20.849435666197 "[$node_(13) set ragent_] test-query 47"
+$ns_ at 21.038235532285 "[$node_(19) set ragent_] test-query 38"
+$ns_ at 21.279447427749 "[$node_(98) set ragent_] test-query 41"
+$ns_ at 21.421012223555 "[$node_(43) set ragent_] test-query 23"
+$ns_ at 21.685644249864 "[$node_(98) set ragent_] test-query 83"
+$ns_ at 21.777566203386 "[$node_(47) set ragent_] test-query 84"
+$ns_ at 22.057576014780 "[$node_(64) set ragent_] test-query 12"
+$ns_ at 22.123352556637 "[$node_(19) set ragent_] test-query 89"
+$ns_ at 22.330947316896 "[$node_(11) set ragent_] test-query 97"
+$ns_ at 22.399124717135 "[$node_(65) set ragent_] test-query 77"
+$ns_ at 22.412008115822 "[$node_(3) set ragent_] test-query 74"
+$ns_ at 22.481717206367 "[$node_(6) set ragent_] test-query 40"
+$ns_ at 23.037247490197 "[$node_(7) set ragent_] test-query 93"
+$ns_ at 23.277935602395 "[$node_(82) set ragent_] test-query 62"
+$ns_ at 23.381072709538 "[$node_(94) set ragent_] test-query 23"
+$ns_ at 23.525650650523 "[$node_(34) set ragent_] test-query 88"
+$ns_ at 23.551919780477 "[$node_(79) set ragent_] test-query 37"
+$ns_ at 23.643301292632 "[$node_(9) set ragent_] test-query 52"
+$ns_ at 23.826056277764 "[$node_(75) set ragent_] test-query 46"
+$ns_ at 24.082700106806 "[$node_(83) set ragent_] test-query 52"
+$ns_ at 24.114414310121 "[$node_(5) set ragent_] test-query 27"
+$ns_ at 24.141296968379 "[$node_(6) set ragent_] test-query 18"
+$ns_ at 24.395135318083 "[$node_(16) set ragent_] test-query 41"
+$ns_ at 24.399171139269 "[$node_(66) set ragent_] test-query 80"
+$ns_ at 24.761908985048 "[$node_(2) set ragent_] test-query 55"
+$ns_ at 24.894547087035 "[$node_(2) set ragent_] test-query 97"
+$ns_ at 25.392559034384 "[$node_(28) set ragent_] test-query 59"
+$ns_ at 25.430398433119 "[$node_(75) set ragent_] test-query 43"
+$ns_ at 25.590469529103 "[$node_(86) set ragent_] test-query 43"
+$ns_ at 25.619407897543 "[$node_(13) set ragent_] test-query 11"
+$ns_ at 25.690019115097 "[$node_(55) set ragent_] test-query 81"
+$ns_ at 25.952406008128 "[$node_(19) set ragent_] test-query 3"
+$ns_ at 26.031010408784 "[$node_(71) set ragent_] test-query 83"
+$ns_ at 26.143686385304 "[$node_(80) set ragent_] test-query 32"
+$ns_ at 26.307222636894 "[$node_(88) set ragent_] test-query 23"
+$ns_ at 26.438276248119 "[$node_(15) set ragent_] test-query 74"
+$ns_ at 26.768654476122 "[$node_(85) set ragent_] test-query 55"
+$ns_ at 27.173095743076 "[$node_(87) set ragent_] test-query 82"
+$ns_ at 27.232400322727 "[$node_(20) set ragent_] test-query 34"
+$ns_ at 27.329981276734 "[$node_(73) set ragent_] test-query 80"
+$ns_ at 27.452681719810 "[$node_(93) set ragent_] test-query 88"
+$ns_ at 27.932861034510 "[$node_(27) set ragent_] test-query 70"
+$ns_ at 27.960926108757 "[$node_(76) set ragent_] test-query 34"
+$ns_ at 27.981342486343 "[$node_(56) set ragent_] test-query 37"
+$ns_ at 28.093311556433 "[$node_(97) set ragent_] test-query 75"
+$ns_ at 28.767588747762 "[$node_(59) set ragent_] test-query 55"
+$ns_ at 29.005072552440 "[$node_(83) set ragent_] test-query 29"
+$ns_ at 29.065464044209 "[$node_(74) set ragent_] test-query 81"
+$ns_ at 29.103480614026 "[$node_(3) set ragent_] test-query 46"
+$ns_ at 29.131073734504 "[$node_(93) set ragent_] test-query 78"
+$ns_ at 29.224057400418 "[$node_(98) set ragent_] test-query 40"
+$ns_ at 30.850604456874 "[$node_(88) set ragent_] test-query 68"
+$ns_ at 30.876041532064 "[$node_(72) set ragent_] test-query 56"
+$ns_ at 31.023994342521 "[$node_(94) set ragent_] test-query 88"
+$ns_ at 31.714884144170 "[$node_(41) set ragent_] test-query 94"
+$ns_ at 32.021302843509 "[$node_(71) set ragent_] test-query 1"
+$ns_ at 32.175285306866 "[$node_(59) set ragent_] test-query 2"
+$ns_ at 32.233463203665 "[$node_(29) set ragent_] test-query 5"
+$ns_ at 32.250048372566 "[$node_(28) set ragent_] test-query 91"
+$ns_ at 32.872000883262 "[$node_(10) set ragent_] test-query 2"
+$ns_ at 33.099827549908 "[$node_(75) set ragent_] test-query 5"
+$ns_ at 33.854473779778 "[$node_(35) set ragent_] test-query 83"
+$ns_ at 33.915448150491 "[$node_(92) set ragent_] test-query 95"
+$ns_ at 33.920880508039 "[$node_(62) set ragent_] test-query 54"
+$ns_ at 33.957236794666 "[$node_(71) set ragent_] test-query 85"
+$ns_ at 34.463637506709 "[$node_(89) set ragent_] test-query 62"
+$ns_ at 34.570840736550 "[$node_(22) set ragent_] test-query 52"
+$ns_ at 34.805107595194 "[$node_(27) set ragent_] test-query 98"
+$ns_ at 34.813943616379 "[$node_(71) set ragent_] test-query 58"
+$ns_ at 34.863527904084 "[$node_(67) set ragent_] test-query 31"
+$ns_ at 35.005059151788 "[$node_(69) set ragent_] test-query 15"
+$ns_ at 35.092867713801 "[$node_(60) set ragent_] test-query 19"
+$ns_ at 35.267451223903 "[$node_(41) set ragent_] test-query 21"
+$ns_ at 35.453202734764 "[$node_(55) set ragent_] test-query 12"
+$ns_ at 35.465545730733 "[$node_(44) set ragent_] test-query 89"
+$ns_ at 35.909758813465 "[$node_(24) set ragent_] test-query 72"
+$ns_ at 36.043987860744 "[$node_(72) set ragent_] test-query 51"
+$ns_ at 36.356101273063 "[$node_(98) set ragent_] test-query 70"
+$ns_ at 36.493314980556 "[$node_(99) set ragent_] test-query 22"
+$ns_ at 36.926201675292 "[$node_(58) set ragent_] test-query 91"
+$ns_ at 37.033912919246 "[$node_(60) set ragent_] test-query 72"
+$ns_ at 37.200677905085 "[$node_(45) set ragent_] test-query 85"
+$ns_ at 37.592219463098 "[$node_(11) set ragent_] test-query 52"
+$ns_ at 37.666549611416 "[$node_(21) set ragent_] test-query 15"
+$ns_ at 37.690298536847 "[$node_(43) set ragent_] test-query 7"
+$ns_ at 37.726653277478 "[$node_(3) set ragent_] test-query 16"
+$ns_ at 37.773893178996 "[$node_(53) set ragent_] test-query 18"
+$ns_ at 38.263527299569 "[$node_(31) set ragent_] test-query 17"
+$ns_ at 38.924680419365 "[$node_(77) set ragent_] test-query 18"
+$ns_ at 39.197734062772 "[$node_(30) set ragent_] test-query 10"
+$ns_ at 39.259696131344 "[$node_(57) set ragent_] test-query 55"
+$ns_ at 40.190693021442 "[$node_(11) set ragent_] test-query 15"
+$ns_ at 40.375875258120 "[$node_(46) set ragent_] test-query 20"
+$ns_ at 40.894944746028 "[$node_(37) set ragent_] test-query 95"
+$ns_ at 41.030303877350 "[$node_(96) set ragent_] test-query 92"
+$ns_ at 41.224034116255 "[$node_(23) set ragent_] test-query 77"
+$ns_ at 41.421301476856 "[$node_(90) set ragent_] test-query 8"
+$ns_ at 41.846949588882 "[$node_(98) set ragent_] test-query 67"
+$ns_ at 41.919888766421 "[$node_(83) set ragent_] test-query 49"
+$ns_ at 41.927180222177 "[$node_(34) set ragent_] test-query 32"
+$ns_ at 42.052799118211 "[$node_(0) set ragent_] test-query 25"
+$ns_ at 42.173459117810 "[$node_(35) set ragent_] test-query 48"
+$ns_ at 42.302058229319 "[$node_(51) set ragent_] test-query 77"
+$ns_ at 42.564865517169 "[$node_(11) set ragent_] test-query 87"
+$ns_ at 42.666144221802 "[$node_(78) set ragent_] test-query 4"
+$ns_ at 42.699867755435 "[$node_(70) set ragent_] test-query 95"
+$ns_ at 43.251297479518 "[$node_(27) set ragent_] test-query 14"
+$ns_ at 43.324460323953 "[$node_(56) set ragent_] test-query 34"
+$ns_ at 43.470166261887 "[$node_(95) set ragent_] test-query 78"
+$ns_ at 43.653621776218 "[$node_(92) set ragent_] test-query 67"
+$ns_ at 43.817560411781 "[$node_(74) set ragent_] test-query 1"
+$ns_ at 43.847256936402 "[$node_(83) set ragent_] test-query 99"
+$ns_ at 44.202570602713 "[$node_(6) set ragent_] test-query 93"
+$ns_ at 44.347860049466 "[$node_(90) set ragent_] test-query 69"
+$ns_ at 45.518629938392 "[$node_(93) set ragent_] test-query 69"
+$ns_ at 45.714812435318 "[$node_(45) set ragent_] test-query 75"
+$ns_ at 45.799610982793 "[$node_(8) set ragent_] test-query 5"
+$ns_ at 45.836354966434 "[$node_(81) set ragent_] test-query 69"
+$ns_ at 45.850383406670 "[$node_(22) set ragent_] test-query 53"
+$ns_ at 45.875446389604 "[$node_(29) set ragent_] test-query 81"
+$ns_ at 46.150780878784 "[$node_(64) set ragent_] test-query 80"
+$ns_ at 46.218290133718 "[$node_(8) set ragent_] test-query 32"
+$ns_ at 46.221768894085 "[$node_(92) set ragent_] test-query 97"
+$ns_ at 46.297344960156 "[$node_(46) set ragent_] test-query 32"
+$ns_ at 46.517143426903 "[$node_(46) set ragent_] test-query 37"
+$ns_ at 47.033894037550 "[$node_(42) set ragent_] test-query 5"
+$ns_ at 47.086258102418 "[$node_(41) set ragent_] test-query 70"
+$ns_ at 47.429497544073 "[$node_(8) set ragent_] test-query 22"
+$ns_ at 47.774192656418 "[$node_(26) set ragent_] test-query 87"
+$ns_ at 47.903980406548 "[$node_(53) set ragent_] test-query 42"
+$ns_ at 47.963794700907 "[$node_(78) set ragent_] test-query 69"
+$ns_ at 48.165506875797 "[$node_(21) set ragent_] test-query 88"
+$ns_ at 48.352679465698 "[$node_(88) set ragent_] test-query 24"
+$ns_ at 48.399179028633 "[$node_(33) set ragent_] test-query 15"
+$ns_ at 48.442676191056 "[$node_(86) set ragent_] test-query 45"
+$ns_ at 48.759853743451 "[$node_(49) set ragent_] test-query 28"
+$ns_ at 48.811612667040 "[$node_(3) set ragent_] test-query 75"
+$ns_ at 48.913168839211 "[$node_(64) set ragent_] test-query 76"
+$ns_ at 49.004803933273 "[$node_(22) set ragent_] test-query 64"
+$ns_ at 49.171974472375 "[$node_(16) set ragent_] test-query 95"
+$ns_ at 49.316827020807 "[$node_(64) set ragent_] test-query 93"
+$ns_ at 49.480130406828 "[$node_(74) set ragent_] test-query 46"
+$ns_ at 49.682170835208 "[$node_(99) set ragent_] test-query 82"
+$ns_ at 49.811590097316 "[$node_(13) set ragent_] test-query 83"
+$ns_ at 50.110563668949 "[$node_(86) set ragent_] test-query 80"
+$ns_ at 50.193831990103 "[$node_(50) set ragent_] test-query 51"
+$ns_ at 50.325942366534 "[$node_(38) set ragent_] test-query 72"
+$ns_ at 50.607424661317 "[$node_(96) set ragent_] test-query 27"
+$ns_ at 50.715153220420 "[$node_(82) set ragent_] test-query 74"
+$ns_ at 51.088529254309 "[$node_(28) set ragent_] test-query 78"
+$ns_ at 51.786833070506 "[$node_(17) set ragent_] test-query 26"
+$ns_ at 51.901585975997 "[$node_(76) set ragent_] test-query 39"
+$ns_ at 52.319563399576 "[$node_(17) set ragent_] test-query 39"
+$ns_ at 52.353691133726 "[$node_(13) set ragent_] test-query 52"
+$ns_ at 52.426469759636 "[$node_(63) set ragent_] test-query 39"
+$ns_ at 52.530442284083 "[$node_(14) set ragent_] test-query 64"
+$ns_ at 52.631703171118 "[$node_(5) set ragent_] test-query 63"
+$ns_ at 52.846925993709 "[$node_(35) set ragent_] test-query 92"
+$ns_ at 52.979080585611 "[$node_(31) set ragent_] test-query 2"
+$ns_ at 52.982067448868 "[$node_(0) set ragent_] test-query 12"
+$ns_ at 53.310264006708 "[$node_(7) set ragent_] test-query 87"
+$ns_ at 53.457948393700 "[$node_(14) set ragent_] test-query 74"
+$ns_ at 53.625570788629 "[$node_(37) set ragent_] test-query 50"
+$ns_ at 54.379580570811 "[$node_(95) set ragent_] test-query 15"
+$ns_ at 54.400574609607 "[$node_(65) set ragent_] test-query 29"
+$ns_ at 54.761039069041 "[$node_(80) set ragent_] test-query 50"
+$ns_ at 55.078582056116 "[$node_(28) set ragent_] test-query 8"
+$ns_ at 55.514734666293 "[$node_(67) set ragent_] test-query 58"
+$ns_ at 55.526024143646 "[$node_(67) set ragent_] test-query 71"
+$ns_ at 55.582008350166 "[$node_(3) set ragent_] test-query 83"
+$ns_ at 55.590639411001 "[$node_(60) set ragent_] test-query 31"
+$ns_ at 55.611074611083 "[$node_(3) set ragent_] test-query 57"
+$ns_ at 55.723587021282 "[$node_(17) set ragent_] test-query 98"
+$ns_ at 56.180222641450 "[$node_(97) set ragent_] test-query 59"
+$ns_ at 56.299862322685 "[$node_(68) set ragent_] test-query 26"
+$ns_ at 56.416514174418 "[$node_(52) set ragent_] test-query 45"
+$ns_ at 56.759580348630 "[$node_(77) set ragent_] test-query 36"
+$ns_ at 57.015191684595 "[$node_(76) set ragent_] test-query 38"
+$ns_ at 57.151924239646 "[$node_(64) set ragent_] test-query 57"
+$ns_ at 57.374942783067 "[$node_(49) set ragent_] test-query 1"
+$ns_ at 57.672296499291 "[$node_(77) set ragent_] test-query 29"
+$ns_ at 58.161330348472 "[$node_(68) set ragent_] test-query 70"
+$ns_ at 58.420873460127 "[$node_(40) set ragent_] test-query 49"
+$ns_ at 58.983540832064 "[$node_(52) set ragent_] test-query 78"
+$ns_ at 59.176473221355 "[$node_(28) set ragent_] test-query 13"
+$ns_ at 59.571165402196 "[$node_(2) set ragent_] test-query 25"
+$ns_ at 59.579281955737 "[$node_(47) set ragent_] test-query 70"
+$ns_ at 59.696502463254 "[$node_(10) set ragent_] test-query 28"
+$ns_ at 60.021410572770 "[$node_(77) set ragent_] test-query 7"
+$ns_ at 60.097944112488 "[$node_(68) set ragent_] test-query 14"
+$ns_ at 60.813152616201 "[$node_(9) set ragent_] test-query 51"
+$ns_ at 61.159576151486 "[$node_(89) set ragent_] test-query 15"
+$ns_ at 61.284888244718 "[$node_(8) set ragent_] test-query 72"
+$ns_ at 61.742267875208 "[$node_(21) set ragent_] test-query 72"
+$ns_ at 61.799175852674 "[$node_(76) set ragent_] test-query 96"
+$ns_ at 62.552983843797 "[$node_(81) set ragent_] test-query 25"
+$ns_ at 62.952181557900 "[$node_(78) set ragent_] test-query 5"
+$ns_ at 63.033170501976 "[$node_(71) set ragent_] test-query 61"
+$ns_ at 63.071441233448 "[$node_(59) set ragent_] test-query 84"
+$ns_ at 63.335993099891 "[$node_(2) set ragent_] test-query 93"
+$ns_ at 63.496438056230 "[$node_(78) set ragent_] test-query 59"
+$ns_ at 63.501282703599 "[$node_(92) set ragent_] test-query 63"
+$ns_ at 63.691985922015 "[$node_(57) set ragent_] test-query 32"
+$ns_ at 63.692592300090 "[$node_(1) set ragent_] test-query 47"
+$ns_ at 63.703669319014 "[$node_(83) set ragent_] test-query 32"
+$ns_ at 63.731260545648 "[$node_(6) set ragent_] test-query 52"
+$ns_ at 63.762519607896 "[$node_(59) set ragent_] test-query 9"
+$ns_ at 64.076730279025 "[$node_(78) set ragent_] test-query 71"
+$ns_ at 64.214681542309 "[$node_(36) set ragent_] test-query 15"
+$ns_ at 64.236572142530 "[$node_(50) set ragent_] test-query 94"
+$ns_ at 64.904634470701 "[$node_(71) set ragent_] test-query 88"
+$ns_ at 65.086894312133 "[$node_(51) set ragent_] test-query 20"
+$ns_ at 65.177808006057 "[$node_(74) set ragent_] test-query 17"
+$ns_ at 65.328121203754 "[$node_(90) set ragent_] test-query 57"
+$ns_ at 65.566136173827 "[$node_(42) set ragent_] test-query 86"
+$ns_ at 65.633957603897 "[$node_(84) set ragent_] test-query 86"
+$ns_ at 65.683815764700 "[$node_(83) set ragent_] test-query 46"
+$ns_ at 65.716318193808 "[$node_(45) set ragent_] test-query 49"
+$ns_ at 65.854430201971 "[$node_(82) set ragent_] test-query 15"
+$ns_ at 66.409619941647 "[$node_(50) set ragent_] test-query 7"
+$ns_ at 66.835893679392 "[$node_(21) set ragent_] test-query 26"
+$ns_ at 66.934991139010 "[$node_(81) set ragent_] test-query 59"
+$ns_ at 67.081108157140 "[$node_(56) set ragent_] test-query 94"
+$ns_ at 67.509740581530 "[$node_(97) set ragent_] test-query 36"
+$ns_ at 67.945048073280 "[$node_(50) set ragent_] test-query 69"
+$ns_ at 68.017613506414 "[$node_(76) set ragent_] test-query 81"
+$ns_ at 68.199976388444 "[$node_(46) set ragent_] test-query 70"
+$ns_ at 68.248051050218 "[$node_(67) set ragent_] test-query 23"
+$ns_ at 68.388181857921 "[$node_(9) set ragent_] test-query 66"
+$ns_ at 68.498325803054 "[$node_(67) set ragent_] test-query 99"
+$ns_ at 68.557061069871 "[$node_(52) set ragent_] test-query 99"
+$ns_ at 68.653020390575 "[$node_(99) set ragent_] test-query 60"
+$ns_ at 68.696869305619 "[$node_(13) set ragent_] test-query 62"
+$ns_ at 69.042473076804 "[$node_(83) set ragent_] test-query 8"
+$ns_ at 69.654113140637 "[$node_(71) set ragent_] test-query 46"
+$ns_ at 69.854790580755 "[$node_(19) set ragent_] test-query 59"
+$ns_ at 69.865737620111 "[$node_(18) set ragent_] test-query 98"
+$ns_ at 70.205770357953 "[$node_(74) set ragent_] test-query 93"
+$ns_ at 70.361244784242 "[$node_(36) set ragent_] test-query 58"
+$ns_ at 70.511907376917 "[$node_(21) set ragent_] test-query 70"
+$ns_ at 70.911084336030 "[$node_(19) set ragent_] test-query 50"
+$ns_ at 71.504160279454 "[$node_(46) set ragent_] test-query 7"
+$ns_ at 71.542227094124 "[$node_(2) set ragent_] test-query 87"
+$ns_ at 71.575465262477 "[$node_(92) set ragent_] test-query 0"
+$ns_ at 71.682488808994 "[$node_(77) set ragent_] test-query 48"
+$ns_ at 72.557466862273 "[$node_(27) set ragent_] test-query 64"
+$ns_ at 72.560636616794 "[$node_(48) set ragent_] test-query 56"
+$ns_ at 73.013781031332 "[$node_(19) set ragent_] test-query 45"
+$ns_ at 73.057800624276 "[$node_(70) set ragent_] test-query 16"
+$ns_ at 73.204235962875 "[$node_(68) set ragent_] test-query 21"
+$ns_ at 73.305439145628 "[$node_(70) set ragent_] test-query 53"
+$ns_ at 73.335609865712 "[$node_(23) set ragent_] test-query 85"
+$ns_ at 73.342464770996 "[$node_(57) set ragent_] test-query 80"
+$ns_ at 73.363259917473 "[$node_(28) set ragent_] test-query 73"
+$ns_ at 74.800435630615 "[$node_(17) set ragent_] test-query 88"
+$ns_ at 74.943624533316 "[$node_(67) set ragent_] test-query 50"
+$ns_ at 74.983675323978 "[$node_(18) set ragent_] test-query 46"
+$ns_ at 75.023333238540 "[$node_(97) set ragent_] test-query 26"
+$ns_ at 75.118974470675 "[$node_(33) set ragent_] test-query 10"
+$ns_ at 75.174272603054 "[$node_(39) set ragent_] test-query 42"
+$ns_ at 75.560768456988 "[$node_(44) set ragent_] test-query 14"
+$ns_ at 75.785867987618 "[$node_(94) set ragent_] test-query 4"
+$ns_ at 76.009352880574 "[$node_(74) set ragent_] test-query 75"
+$ns_ at 76.029230556037 "[$node_(27) set ragent_] test-query 40"
+$ns_ at 76.156117941357 "[$node_(66) set ragent_] test-query 87"
+$ns_ at 76.280669327515 "[$node_(68) set ragent_] test-query 88"
+$ns_ at 76.536686255392 "[$node_(45) set ragent_] test-query 72"
+$ns_ at 76.563158451852 "[$node_(10) set ragent_] test-query 22"
+$ns_ at 76.575178953165 "[$node_(55) set ragent_] test-query 49"
+$ns_ at 76.579462829325 "[$node_(7) set ragent_] test-query 87"
+$ns_ at 76.705163547169 "[$node_(39) set ragent_] test-query 50"
+$ns_ at 76.974013976729 "[$node_(45) set ragent_] test-query 7"
+$ns_ at 76.979450779014 "[$node_(17) set ragent_] test-query 4"
+$ns_ at 77.074489923212 "[$node_(36) set ragent_] test-query 49"
+$ns_ at 77.114847555325 "[$node_(3) set ragent_] test-query 47"
+$ns_ at 77.255057827196 "[$node_(20) set ragent_] test-query 62"
+$ns_ at 77.321675738440 "[$node_(96) set ragent_] test-query 98"
+$ns_ at 77.510710479889 "[$node_(73) set ragent_] test-query 37"
+$ns_ at 77.535866106603 "[$node_(86) set ragent_] test-query 89"
+$ns_ at 77.615061348079 "[$node_(60) set ragent_] test-query 32"
+$ns_ at 77.641085708300 "[$node_(43) set ragent_] test-query 53"
+$ns_ at 77.737304756244 "[$node_(44) set ragent_] test-query 10"
+$ns_ at 77.770684769682 "[$node_(11) set ragent_] test-query 93"
+$ns_ at 77.810675768969 "[$node_(63) set ragent_] test-query 83"
+$ns_ at 78.209797536044 "[$node_(38) set ragent_] test-query 57"
+$ns_ at 78.552678731898 "[$node_(1) set ragent_] test-query 26"
+$ns_ at 78.886153318288 "[$node_(5) set ragent_] test-query 19"
+$ns_ at 79.332905891836 "[$node_(97) set ragent_] test-query 69"
+$ns_ at 79.604745349047 "[$node_(20) set ragent_] test-query 6"
+$ns_ at 79.642677043711 "[$node_(55) set ragent_] test-query 23"
+$ns_ at 79.837232960150 "[$node_(5) set ragent_] test-query 54"
+$ns_ at 79.947206343331 "[$node_(32) set ragent_] test-query 15"
+$ns_ at 80.065901691881 "[$node_(29) set ragent_] test-query 97"
+$ns_ at 80.171016397785 "[$node_(98) set ragent_] test-query 58"
+$ns_ at 80.351656074610 "[$node_(82) set ragent_] test-query 97"
+$ns_ at 80.450146460455 "[$node_(61) set ragent_] test-query 35"
+$ns_ at 80.679801923798 "[$node_(36) set ragent_] test-query 71"
+$ns_ at 80.791368262066 "[$node_(84) set ragent_] test-query 78"
+$ns_ at 81.051741070843 "[$node_(26) set ragent_] test-query 20"
+$ns_ at 81.247122510214 "[$node_(25) set ragent_] test-query 35"
+$ns_ at 81.730166283979 "[$node_(13) set ragent_] test-query 30"
+$ns_ at 81.733437339854 "[$node_(31) set ragent_] test-query 29"
+$ns_ at 81.945660853925 "[$node_(67) set ragent_] test-query 41"
+$ns_ at 82.173803715296 "[$node_(76) set ragent_] test-query 10"
+$ns_ at 82.261291367298 "[$node_(40) set ragent_] test-query 51"
+$ns_ at 82.340251617463 "[$node_(37) set ragent_] test-query 50"
+$ns_ at 82.642947057251 "[$node_(1) set ragent_] test-query 22"
+$ns_ at 82.750485188361 "[$node_(36) set ragent_] test-query 4"
+$ns_ at 82.837057108594 "[$node_(74) set ragent_] test-query 68"
+$ns_ at 83.835798399538 "[$node_(24) set ragent_] test-query 87"
+$ns_ at 83.850676325637 "[$node_(16) set ragent_] test-query 96"
+$ns_ at 84.199870246163 "[$node_(2) set ragent_] test-query 23"
+$ns_ at 84.238053783490 "[$node_(73) set ragent_] test-query 64"
+$ns_ at 84.309214486486 "[$node_(12) set ragent_] test-query 60"
+$ns_ at 84.588943815651 "[$node_(76) set ragent_] test-query 91"
+$ns_ at 84.632135450718 "[$node_(50) set ragent_] test-query 48"
+$ns_ at 84.675342468441 "[$node_(73) set ragent_] test-query 94"
+$ns_ at 84.692183808793 "[$node_(4) set ragent_] test-query 46"
+$ns_ at 85.195830291248 "[$node_(38) set ragent_] test-query 60"
+$ns_ at 85.534498069686 "[$node_(14) set ragent_] test-query 88"
+$ns_ at 85.667336919185 "[$node_(11) set ragent_] test-query 97"
+$ns_ at 86.385665435015 "[$node_(39) set ragent_] test-query 63"
+$ns_ at 86.513709109001 "[$node_(75) set ragent_] test-query 71"
+$ns_ at 86.564150960395 "[$node_(83) set ragent_] test-query 69"
+$ns_ at 87.376589670392 "[$node_(4) set ragent_] test-query 85"
+$ns_ at 87.418977890261 "[$node_(34) set ragent_] test-query 53"
+$ns_ at 87.452265762370 "[$node_(89) set ragent_] test-query 63"
+$ns_ at 87.475376268970 "[$node_(3) set ragent_] test-query 99"
+$ns_ at 87.604004870343 "[$node_(47) set ragent_] test-query 42"
+$ns_ at 87.753974741095 "[$node_(82) set ragent_] test-query 1"
+$ns_ at 88.033083314427 "[$node_(41) set ragent_] test-query 32"
+$ns_ at 88.189909559159 "[$node_(21) set ragent_] test-query 77"
+$ns_ at 88.967599392674 "[$node_(53) set ragent_] test-query 23"
+$ns_ at 89.335076642180 "[$node_(97) set ragent_] test-query 10"
+$ns_ at 89.505623596748 "[$node_(22) set ragent_] test-query 29"
+$ns_ at 89.831490725907 "[$node_(74) set ragent_] test-query 2"
+$ns_ at 90.215520639759 "[$node_(29) set ragent_] test-query 48"
+$ns_ at 90.379889796411 "[$node_(10) set ragent_] test-query 44"
+$ns_ at 90.827979192246 "[$node_(60) set ragent_] test-query 39"
+$ns_ at 91.001988249080 "[$node_(53) set ragent_] test-query 71"
+$ns_ at 91.304548143714 "[$node_(40) set ragent_] test-query 58"
+$ns_ at 91.445922047729 "[$node_(11) set ragent_] test-query 89"
+$ns_ at 91.493907080415 "[$node_(85) set ragent_] test-query 31"
+$ns_ at 91.555769973378 "[$node_(93) set ragent_] test-query 74"
+$ns_ at 91.617289230196 "[$node_(71) set ragent_] test-query 11"
+$ns_ at 91.811026580680 "[$node_(41) set ragent_] test-query 57"
+$ns_ at 91.828612549752 "[$node_(4) set ragent_] test-query 97"
+$ns_ at 92.143803072814 "[$node_(44) set ragent_] test-query 85"
+$ns_ at 92.314569906588 "[$node_(80) set ragent_] test-query 18"
+$ns_ at 92.523043879185 "[$node_(26) set ragent_] test-query 22"
+$ns_ at 93.052078274174 "[$node_(41) set ragent_] test-query 44"
+$ns_ at 93.280823532682 "[$node_(16) set ragent_] test-query 75"
+$ns_ at 94.071355061656 "[$node_(45) set ragent_] test-query 91"
+$ns_ at 94.349301278291 "[$node_(18) set ragent_] test-query 70"
+$ns_ at 94.761472329367 "[$node_(50) set ragent_] test-query 83"
+$ns_ at 94.932337759003 "[$node_(73) set ragent_] test-query 34"
+$ns_ at 95.666204263699 "[$node_(80) set ragent_] test-query 73"
+$ns_ at 95.717781262271 "[$node_(0) set ragent_] test-query 77"
+$ns_ at 95.769997491322 "[$node_(70) set ragent_] test-query 12"
+$ns_ at 95.777050090777 "[$node_(73) set ragent_] test-query 95"
+$ns_ at 96.235217521911 "[$node_(70) set ragent_] test-query 3"
+$ns_ at 96.295441930220 "[$node_(13) set ragent_] test-query 81"
+$ns_ at 96.360058859520 "[$node_(61) set ragent_] test-query 60"
+$ns_ at 96.596874330355 "[$node_(94) set ragent_] test-query 43"
+$ns_ at 96.962616470490 "[$node_(88) set ragent_] test-query 90"
+$ns_ at 97.075261797650 "[$node_(7) set ragent_] test-query 58"
+$ns_ at 97.311586569520 "[$node_(55) set ragent_] test-query 17"
+$ns_ at 97.510775370597 "[$node_(39) set ragent_] test-query 4"
+$ns_ at 97.684177701507 "[$node_(71) set ragent_] test-query 30"
+$ns_ at 97.714417334338 "[$node_(40) set ragent_] test-query 38"
+$ns_ at 97.747682480313 "[$node_(91) set ragent_] test-query 6"
+$ns_ at 97.781636096722 "[$node_(34) set ragent_] test-query 16"
+$ns_ at 97.842091824604 "[$node_(26) set ragent_] test-query 12"
+$ns_ at 97.924068041390 "[$node_(33) set ragent_] test-query 80"
diff -u -r --new-file ./hls/utils/cp-n40-a40-t40-c4-m0 ../../ns-2.33-hls_working/ns-2.33/hls/utils/cp-n40-a40-t40-c4-m0
--- ./hls/utils/cp-n40-a40-t40-c4-m0	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/cp-n40-a40-t40-c4-m0	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,164 @@
+#
+# nodes: 40, max conn: 4, send rate: 0.100000, seed: 1, active nodes: 40
+#
+
+$ns_ at 0.012128558015 "[$node_(0) set ragent_] test-query 12"
+$ns_ at 0.162992589243 "[$node_(18) set ragent_] test-query 39"
+$ns_ at 0.290314778805 "[$node_(19) set ragent_] test-query 36"
+$ns_ at 0.338853877178 "[$node_(36) set ragent_] test-query 9"
+$ns_ at 0.372171756034 "[$node_(15) set ragent_] test-query 21"
+$ns_ at 0.468396190747 "[$node_(30) set ragent_] test-query 24"
+$ns_ at 0.819133520465 "[$node_(28) set ragent_] test-query 16"
+$ns_ at 1.253104955475 "[$node_(3) set ragent_] test-query 24"
+$ns_ at 1.348067988267 "[$node_(3) set ragent_] test-query 21"
+$ns_ at 1.364390533981 "[$node_(7) set ragent_] test-query 13"
+$ns_ at 1.429707334036 "[$node_(20) set ragent_] test-query 10"
+$ns_ at 1.551119201526 "[$node_(20) set ragent_] test-query 24"
+$ns_ at 1.974710562150 "[$node_(31) set ragent_] test-query 0"
+$ns_ at 2.185024415114 "[$node_(20) set ragent_] test-query 13"
+$ns_ at 2.287673075697 "[$node_(36) set ragent_] test-query 12"
+$ns_ at 2.515945025827 "[$node_(22) set ragent_] test-query 26"
+$ns_ at 2.612529304957 "[$node_(27) set ragent_] test-query 14"
+$ns_ at 3.154236601105 "[$node_(14) set ragent_] test-query 36"
+$ns_ at 3.206958455426 "[$node_(20) set ragent_] test-query 17"
+$ns_ at 3.421821334881 "[$node_(30) set ragent_] test-query 31"
+$ns_ at 3.475195077751 "[$node_(8) set ragent_] test-query 21"
+$ns_ at 3.538883013249 "[$node_(15) set ragent_] test-query 23"
+$ns_ at 3.759835680636 "[$node_(7) set ragent_] test-query 11"
+$ns_ at 4.345814103192 "[$node_(36) set ragent_] test-query 39"
+$ns_ at 4.472958968936 "[$node_(16) set ragent_] test-query 22"
+$ns_ at 4.679563643480 "[$node_(30) set ragent_] test-query 31"
+$ns_ at 5.248159712485 "[$node_(33) set ragent_] test-query 39"
+$ns_ at 5.309586210506 "[$node_(4) set ragent_] test-query 28"
+$ns_ at 5.354811085736 "[$node_(6) set ragent_] test-query 5"
+$ns_ at 5.549253171738 "[$node_(3) set ragent_] test-query 17"
+$ns_ at 5.720260927953 "[$node_(29) set ragent_] test-query 22"
+$ns_ at 5.967426190754 "[$node_(24) set ragent_] test-query 38"
+$ns_ at 6.080032868958 "[$node_(14) set ragent_] test-query 29"
+$ns_ at 6.498427337856 "[$node_(9) set ragent_] test-query 20"
+$ns_ at 7.128625664078 "[$node_(15) set ragent_] test-query 29"
+$ns_ at 7.246541365248 "[$node_(3) set ragent_] test-query 9"
+$ns_ at 7.586051582697 "[$node_(20) set ragent_] test-query 14"
+$ns_ at 7.686042826071 "[$node_(10) set ragent_] test-query 27"
+$ns_ at 8.102165557064 "[$node_(9) set ragent_] test-query 25"
+$ns_ at 8.521729767116 "[$node_(3) set ragent_] test-query 34"
+$ns_ at 8.662865035087 "[$node_(17) set ragent_] test-query 24"
+$ns_ at 8.690528631073 "[$node_(9) set ragent_] test-query 32"
+$ns_ at 9.066579271126 "[$node_(18) set ragent_] test-query 29"
+$ns_ at 10.130748603950 "[$node_(7) set ragent_] test-query 3"
+$ns_ at 10.696457740610 "[$node_(29) set ragent_] test-query 23"
+$ns_ at 11.067894087086 "[$node_(27) set ragent_] test-query 25"
+$ns_ at 11.207585209020 "[$node_(7) set ragent_] test-query 5"
+$ns_ at 11.312920455835 "[$node_(13) set ragent_] test-query 9"
+$ns_ at 11.527966843090 "[$node_(8) set ragent_] test-query 22"
+$ns_ at 11.710631908096 "[$node_(16) set ragent_] test-query 33"
+$ns_ at 11.990021509412 "[$node_(33) set ragent_] test-query 29"
+$ns_ at 12.076670700082 "[$node_(18) set ragent_] test-query 21"
+$ns_ at 12.080223025154 "[$node_(19) set ragent_] test-query 28"
+$ns_ at 12.531975848186 "[$node_(38) set ragent_] test-query 6"
+$ns_ at 12.742747353063 "[$node_(21) set ragent_] test-query 6"
+$ns_ at 12.811530293598 "[$node_(20) set ragent_] test-query 10"
+$ns_ at 13.321944275783 "[$node_(13) set ragent_] test-query 33"
+$ns_ at 13.375850586155 "[$node_(12) set ragent_] test-query 26"
+$ns_ at 14.084002958838 "[$node_(17) set ragent_] test-query 34"
+$ns_ at 14.196840605041 "[$node_(25) set ragent_] test-query 33"
+$ns_ at 14.559126278809 "[$node_(15) set ragent_] test-query 3"
+$ns_ at 14.615802044495 "[$node_(6) set ragent_] test-query 15"
+$ns_ at 14.656778654547 "[$node_(32) set ragent_] test-query 7"
+$ns_ at 14.658292817416 "[$node_(23) set ragent_] test-query 19"
+$ns_ at 14.940828146994 "[$node_(23) set ragent_] test-query 24"
+$ns_ at 15.184294010263 "[$node_(33) set ragent_] test-query 0"
+$ns_ at 15.275360948194 "[$node_(4) set ragent_] test-query 34"
+$ns_ at 15.330973497402 "[$node_(23) set ragent_] test-query 21"
+$ns_ at 15.352761472395 "[$node_(20) set ragent_] test-query 12"
+$ns_ at 15.706019463914 "[$node_(7) set ragent_] test-query 2"
+$ns_ at 16.383553507983 "[$node_(32) set ragent_] test-query 12"
+$ns_ at 16.496917295562 "[$node_(19) set ragent_] test-query 9"
+$ns_ at 16.847568533820 "[$node_(19) set ragent_] test-query 12"
+$ns_ at 17.046482011263 "[$node_(39) set ragent_] test-query 19"
+$ns_ at 17.089703965537 "[$node_(34) set ragent_] test-query 10"
+$ns_ at 17.131197906653 "[$node_(38) set ragent_] test-query 36"
+$ns_ at 17.459861829635 "[$node_(13) set ragent_] test-query 2"
+$ns_ at 17.809636581592 "[$node_(23) set ragent_] test-query 35"
+$ns_ at 18.043889131396 "[$node_(32) set ragent_] test-query 2"
+$ns_ at 18.152039822235 "[$node_(10) set ragent_] test-query 2"
+$ns_ at 19.178617734930 "[$node_(27) set ragent_] test-query 38"
+$ns_ at 19.352048419955 "[$node_(26) set ragent_] test-query 25"
+$ns_ at 19.685587332330 "[$node_(16) set ragent_] test-query 0"
+$ns_ at 19.868631222107 "[$node_(21) set ragent_] test-query 34"
+$ns_ at 20.037912529785 "[$node_(5) set ragent_] test-query 37"
+$ns_ at 20.090467528353 "[$node_(38) set ragent_] test-query 20"
+$ns_ at 20.637058233050 "[$node_(22) set ragent_] test-query 23"
+$ns_ at 20.748690989985 "[$node_(6) set ragent_] test-query 8"
+$ns_ at 21.028455746660 "[$node_(5) set ragent_] test-query 21"
+$ns_ at 21.294875656665 "[$node_(38) set ragent_] test-query 1"
+$ns_ at 22.088438803137 "[$node_(10) set ragent_] test-query 30"
+$ns_ at 22.315515531127 "[$node_(36) set ragent_] test-query 37"
+$ns_ at 22.997652767408 "[$node_(9) set ragent_] test-query 16"
+$ns_ at 23.781003309919 "[$node_(18) set ragent_] test-query 38"
+$ns_ at 23.833125504261 "[$node_(1) set ragent_] test-query 12"
+$ns_ at 24.160207296452 "[$node_(11) set ragent_] test-query 8"
+$ns_ at 24.203225887129 "[$node_(1) set ragent_] test-query 8"
+$ns_ at 24.560092604615 "[$node_(14) set ragent_] test-query 39"
+$ns_ at 24.663318126401 "[$node_(12) set ragent_] test-query 32"
+$ns_ at 24.691999080541 "[$node_(26) set ragent_] test-query 31"
+$ns_ at 24.694106067482 "[$node_(33) set ragent_] test-query 28"
+$ns_ at 24.903560346961 "[$node_(28) set ragent_] test-query 0"
+$ns_ at 25.506479732047 "[$node_(2) set ragent_] test-query 31"
+$ns_ at 25.545645683375 "[$node_(5) set ragent_] test-query 0"
+$ns_ at 26.034273199310 "[$node_(27) set ragent_] test-query 36"
+$ns_ at 26.476390503103 "[$node_(34) set ragent_] test-query 36"
+$ns_ at 26.508884496756 "[$node_(1) set ragent_] test-query 3"
+$ns_ at 26.665270004255 "[$node_(35) set ragent_] test-query 5"
+$ns_ at 26.683554958393 "[$node_(25) set ragent_] test-query 35"
+$ns_ at 26.848698716520 "[$node_(7) set ragent_] test-query 25"
+$ns_ at 26.878107629638 "[$node_(3) set ragent_] test-query 35"
+$ns_ at 26.900239467551 "[$node_(7) set ragent_] test-query 34"
+$ns_ at 26.982144910807 "[$node_(0) set ragent_] test-query 3"
+$ns_ at 27.527729191076 "[$node_(16) set ragent_] test-query 6"
+$ns_ at 27.627202507339 "[$node_(28) set ragent_] test-query 25"
+$ns_ at 28.567699913555 "[$node_(15) set ragent_] test-query 33"
+$ns_ at 28.691547692492 "[$node_(26) set ragent_] test-query 23"
+$ns_ at 29.265676357759 "[$node_(15) set ragent_] test-query 20"
+$ns_ at 29.426414792468 "[$node_(24) set ragent_] test-query 18"
+$ns_ at 29.592411101907 "[$node_(38) set ragent_] test-query 4"
+$ns_ at 29.635880918371 "[$node_(20) set ragent_] test-query 25"
+$ns_ at 30.064349913344 "[$node_(29) set ragent_] test-query 15"
+$ns_ at 30.496477217898 "[$node_(29) set ragent_] test-query 2"
+$ns_ at 30.573721615182 "[$node_(24) set ragent_] test-query 4"
+$ns_ at 30.812841871437 "[$node_(20) set ragent_] test-query 9"
+$ns_ at 30.938704808909 "[$node_(17) set ragent_] test-query 11"
+$ns_ at 31.005189710991 "[$node_(11) set ragent_] test-query 39"
+$ns_ at 31.330009264768 "[$node_(3) set ragent_] test-query 14"
+$ns_ at 31.389460017826 "[$node_(28) set ragent_] test-query 31"
+$ns_ at 31.490949181803 "[$node_(1) set ragent_] test-query 33"
+$ns_ at 32.044638203649 "[$node_(2) set ragent_] test-query 14"
+$ns_ at 32.618253579792 "[$node_(17) set ragent_] test-query 26"
+$ns_ at 32.670851698596 "[$node_(38) set ragent_] test-query 28"
+$ns_ at 32.718568588146 "[$node_(37) set ragent_] test-query 36"
+$ns_ at 33.133614803375 "[$node_(0) set ragent_] test-query 8"
+$ns_ at 33.149136206783 "[$node_(32) set ragent_] test-query 10"
+$ns_ at 33.463262594151 "[$node_(19) set ragent_] test-query 21"
+$ns_ at 33.647233224396 "[$node_(9) set ragent_] test-query 6"
+$ns_ at 33.922744276969 "[$node_(7) set ragent_] test-query 18"
+$ns_ at 34.120094510844 "[$node_(12) set ragent_] test-query 3"
+$ns_ at 34.663403961218 "[$node_(31) set ragent_] test-query 20"
+$ns_ at 34.713734328178 "[$node_(19) set ragent_] test-query 0"
+$ns_ at 34.816353912870 "[$node_(10) set ragent_] test-query 29"
+$ns_ at 35.001086923775 "[$node_(16) set ragent_] test-query 0"
+$ns_ at 35.094664875007 "[$node_(18) set ragent_] test-query 9"
+$ns_ at 35.175828389446 "[$node_(14) set ragent_] test-query 22"
+$ns_ at 35.937437504467 "[$node_(32) set ragent_] test-query 16"
+$ns_ at 36.929453272719 "[$node_(21) set ragent_] test-query 37"
+$ns_ at 37.289301489043 "[$node_(39) set ragent_] test-query 14"
+$ns_ at 37.853821662051 "[$node_(17) set ragent_] test-query 38"
+$ns_ at 37.996351417941 "[$node_(28) set ragent_] test-query 17"
+$ns_ at 38.257596173287 "[$node_(0) set ragent_] test-query 11"
+$ns_ at 38.363794532612 "[$node_(21) set ragent_] test-query 39"
+$ns_ at 38.529999495560 "[$node_(5) set ragent_] test-query 22"
+$ns_ at 38.546177332372 "[$node_(36) set ragent_] test-query 31"
+$ns_ at 38.890475292915 "[$node_(7) set ragent_] test-query 31"
+$ns_ at 38.996274077602 "[$node_(12) set ragent_] test-query 27"
+$ns_ at 39.130289626631 "[$node_(30) set ragent_] test-query 33"
+$ns_ at 39.629854371370 "[$node_(38) set ragent_] test-query 34"
+$ns_ at 39.681296513967 "[$node_(11) set ragent_] test-query 35"
diff -u -r --new-file ./hls/utils/evaluate.pl ../../ns-2.33-hls_working/ns-2.33/hls/utils/evaluate.pl
--- ./hls/utils/evaluate.pl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/evaluate.pl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,2185 @@
+#!/usr/bin/perl
+# -*- cperl -*-
+# $Id: evaluate.pl,v 1.4 2003/01/29 18:41:05 kiess Exp $
+# edited version by wk to adapt to hls
+
+use strict;
+
+# Switches - to check
+my $miss_analysis = 0;
+my $latency_analysis = 0;
+my $bDatfile = 0;
+my $bLatfile = 0;
+my $noFiles = 0;
+my $filemark = "";
+my @filelist = ();
+my $quant_step = 0.25; # Quantization step size for latency spectrum
+
+my $gen_rte = 0; # Generate RTE Files only
+my $write_file;
+my $actfile = "";
+my $processed = 0;
+
+#################################
+#
+# Intermediate Hashes
+#
+my %PKT = ();
+my %LAT = ();
+my %LOOKUP = ();
+
+#################################
+#
+# Compatibility
+#
+my $simulator_eval = 0;
+my %COMPAT = ();
+
+#################################
+#
+# Data Hashes
+#
+my %speed = ('max' => 0, 'avg' => 0, 'cnt' => 0);
+my %duplicates = ('sent' => 0, 'recv' => 0);
+my %collisions = ('valid' => 0, 'cols' => 0);
+my %areausage = ('valid' => 0, 'sends' => 0, 'usage' => ());
+my %packetflow = ();
+my %reachability = ();
+my %delivery = ();
+my %drops = ();
+my %bw = ();
+my %stats = ();
+my %latency = ();
+my %latency_spectrum = ();
+my %gls_update = ();
+my %delivery_count = ();
+# wk
+my %lookup =('queries' => 0, 'cache_lookups' => 0, 'request_send' => 0, 
+	     'reply_receive' => 0, 'request_drop' => 0, 'reply_drop' => 0, 
+	     'ifq_drop_request' => 0, 'ttl_drop_request' => 0,'cbk_drop_request' => 0,
+	     'ifq_drop_reply' => 0, 'ttl_drop_reply' => 0,'cbk_drop_reply' => 0,
+	     'nrte_drop_request' => 0,'nrte_drop_reply' => 0,);
+my %updates_send = ();
+my %updates_received = ();
+my %unanswered_requests = ();
+my %request_first_locate_level = (); # intermediate hash for each file
+my %request_first_locate_samecell = ();# intermediate hash for each file
+
+my %request_locate_same_cell; # overall hash storing the summary of request locates
+my %request_locate_not_same_cell;# overall hash storing the summary of request locates
+my $request_locate_counter = 0;
+
+my %cache_statistic = ('maxage' => 0,'minage' => 0,'totalage' => 0);
+my %reply_statistic = ('maxage' => 0,'minage' => 0,'totalage' => 0);
+my %request_u_distance = ();
+my %request_drop = ();
+my %update_holder = (); #the one who has the latest info about node x
+# contains at position x the number and position of node y who has info
+# about x
+my %query_distance = ( 'max' => 0 , 'numberOfEntries' => 0);
+my %cl_deviation   = ( 'max' => 0 , 'numberOfEntries' => 0);
+my $query_distance_quant_step = 250;
+my $deviation_quant_step = 50;
+#for the handovers
+my %handovers = ('send' => 0, 'receive' => 0, 'forcereceive' => 0);
+my %handovers_number = ();
+my %handover_send_distance = ( 'max' => 0 , 'numberOfEntries' => 0);
+my $handover_distance_quant_step = 150;
+# for CICs
+my %cic_send_number_of_neighbors = ();
+my %cic_send = ('total' => 0);
+my %request_drop_after_cic_send = ();
+
+my %request_send_time = ();
+my %request_time_hash = ();
+my $radio_range = 250;
+my $cellsize = sqrt(($radio_range*$radio_range)/2);
+
+my %request_drop_lnr_deviation = ('info_still_exact' => 0, 
+				  'target_node_reachable' => 0,
+				  'info_not_exact_but_node_reachable' => 0);
+my $request_drop_cas_deviation_still_exact = 0; # contains the number of CAS drops of
+# requests with info still exact enough
+
+my @lnr_conana;
+my @lnr_gconana;
+# for connectivity analysis, this variables always contain the last CONANA
+# and GCONANAN value
+my %conana =('time'=>0,'node'=>0,'packetNr'=>0,'hops'=>0);
+my %gconana =('time'=>0,'node'=>0,'packetNr'=>0,'hops'=>0);
+my @cbk_conana;
+my @cbk_gconana;
+# the following hash checks if all test queries have been answered
+my %queries = ();
+
+## erroranalyze; all necessary variables start with ea_
+# for each request, we store in detail what happenen, then classes are build and
+# the results are printed
+my %ea_requests = ();
+# contains the hierachy(the cells in the hierachy) for each node. When a node 
+# sends an update, the hierachy is updated.
+my %ea_actual_hierachy = ();
+# used to hold the calculated values when switching between one file and
+# another
+my %ea_reach_stats =();
+my %ea_cells_reached_in_request_sender_hierachy = ();
+my %ea_drop_reasons =();
+my %ea_correct_cells_reached = ();
+#################################
+#
+# Data Variables
+#
+my $duration = 1; # Init value determines lowest runtime
+my ($nn, $x, $y) = (0,0,0);
+my $routing = "NONE";
+my $mac = "NONE";
+
+#################################
+#
+# Lookup Tables
+#
+# HLS
+my @HLSTYPE  = ("empty", "UPDATE","REQUEST","REPLY","CCREQ","CCREPLY","CIREQU","HNDOVER");
+
+# end HLS
+my @LOCSTYPE = ("QUERY ", "REPLY ", "DATA  ", "UPDATE", "UPDACK", "BEACON", "BCNREQ");
+my @GPSRTYPE = ("GREEDY", "PERI  ", "PROBE ", "BEACON", "BCNREQ");
+my @CBFTYPE  = ("DATA  ", "RCPT  ", "RTF   ", "CTF   ", "REC   ", "ACT   ");
+my @DSRTYPE  = ("RTREQ ", "RTRPLY", "RTERR ", "RTRQER", "RTRPER");
+my @PINGTYPE = ("Ping", "Echo", "TOTAL ");
+my @SPEEDS   = (0,10,30,50);
+
+#################################
+#
+# Main
+#
+parseCmdLine();
+if ($noFiles == 0){ usage(); }else{
+
+  #
+  # Setup
+  #
+  printf ("Parser started for %i Files\n",$noFiles);
+
+  for (my $i = 0; $i < $noFiles; $i++){
+
+    if (($miss_analysis == 1) && ($i >= 1)) { last; }
+
+    $actfile = $filelist[$i];
+    print "Processing file $actfile...";
+
+    # Reset Intermediate Hashes
+    %PKT = (); %LAT = (); %LOOKUP = ();
+    %COMPAT = ();
+    %cic_send_number_of_neighbors = ();
+    %request_first_locate_level = ();
+    %request_first_locate_samecell = ();
+    %ea_requests = ();
+    %queries = ();
+    $simulator_eval = 0;
+
+    # Generate RTE File
+    my $write_file = 0;
+
+    if ($gen_rte) {
+      my $basename = $actfile;
+      $basename =~ s/\.gz//;
+      $basename =~ s/\.rte//;
+      $basename = "$basename.rte";
+      if (-e $basename) {
+	print "(rte exists) ";
+      }else{
+	print "(rte create) ";
+	$write_file = open(RTEFILE, ">$basename");
+	print RTEFILE "# This is the mangled route file for $actfile\n";
+      }
+    }
+
+    # Zip or no zip
+    my $zipped = 0;
+    if ($actfile =~ /\.gz$/){
+      $zipped = 1;
+      if (not open(FILE, "zcat $actfile |")) { print " not found\n"; next; }
+      else{ print " found\n"; }
+    }elsif ($actfile =~ /\.bz$/){
+      $zipped = 2;
+      if (not open(FILE, "bzcat $actfile |")) { print " not found\n"; next; }
+      else{ print " found\n"; }
+    }else{
+      if (not open(FILE, "< $actfile")) { print " not found\n"; next; }
+      else{ print " found\n"; }
+    }
+
+    print "Parsing";
+    my $filesize = (stat($actfile))[7];
+
+    $processed++;
+
+    my $parsedsize = 0;
+    my $step = 0;
+    if ($zipped) { $step = 0.9 * $filesize; }
+    else { $step = 0.1 * $filesize; }
+    my $mark = $step;
+
+    #
+    # Parse through Tracefile
+    #
+    while (my $line = <FILE>) {
+
+      # Progress Indicator
+      if ($parsedsize >= $mark) {
+	printf(".");
+	$mark += $step;
+      }
+      $parsedsize += length($line);
+
+      next if $line =~ /^V/o;
+
+      # Parameter
+      if ($line =~ /^M \d+.\d+ nn (\d+) x (\d+) y (\d+) rp (\S+)/o) {
+	$nn += $1/$noFiles; $x += $2/$noFiles; $y += $3/$noFiles; $routing = $4;
+	next;
+      }
+      if ($line =~ /^M \d+.\d+ prop.*mac (\S+)/o) {
+	$mac = $1;
+	next;
+      }
+
+      # Speeds
+      if ($line =~ /^M \d+.\d+ \d+ \(\d+.\d+, \d+.\d+, \d+.\d+\), \(\d+.\d+, \d+.\d+\), (\d+.\d+)/o) {
+	if ($1 > $speed{max}) {
+	  $speed{max} = $1;
+	}
+	$speed{avg} += $1;
+	$speed{cnt}++;
+	next;
+      }
+
+      # Route Information
+      if($line =~ /^CBFDBG: (\d+.\d+) _(\S+)_: RouteInfo (\d+) \((\d+)->(\d+)\) : (\d+) (\d+)/o) {
+	my $time = $1; my $node = $2;
+	my $pkt_uid  = $3;
+	my $pkt_src  = $4;
+	my $pkt_dst  = $5;
+	my $taken    = $6;
+	my $shortest = $7;
+
+	$LOOKUP{$pkt_uid}->{taken} = $taken;
+	$LOOKUP{$pkt_uid}->{shortest} = $shortest;
+      }
+
+      # Simulator Evaluation
+      if ($line =~ /^## (\S+): (\d+) (\d+) (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)/o) {
+	my ($protocol, $mactrans, $mactraf) = ($1,$2,$3);
+	my @area = ($4,$5,$6);
+	my ($shortest, $greedy, $drops) = ($7,$8,$9);
+
+	# Remember the comment
+	$simulator_eval = 1;
+
+	# Bandwidth Consumption
+	$bw{MAC}{$protocol}->{cnt} += $mactrans;
+	$bw{MAC}{$protocol}->{bw} += $mactraf;
+	$bw{MAC}->{cnt} += $mactrans;
+	$bw{MAC}->{bw} += $mactraf;
+
+	# Area Information 
+	if ($protocol eq "Ping") {
+	  my $sends = 0;
+	  for (my $i=0; $i < 3; $i++) {
+	    $areausage{usage}{$i} += $area[$i];
+	    $sends += $area[$i];
+	  }
+	  $areausage{sends} += $sends;
+	  $areausage{valid} = 1;
+	}
+
+	# Connectivity
+	if (($protocol eq "Ping") || ($protocol eq "Echo")) {
+	  $reachability{$protocol}{drops} += $drops;
+	  $reachability{$protocol}{shortest} += $shortest;
+	  $reachability{$protocol}{greedy} += $greedy;
+	}
+
+      }
+
+      #HLS result parsing wk
+      if($line =~ /^TESTQ \d+\.\d+ (\d+) \((\d+\.\d+) (\d+\.\d+)\) (\d+) \((\d+\.\d+) (\d+\.\d+)\)/o) {
+	$lookup{queries}++;
+	my $src = $1;
+	my $srcx = $2;
+	my $srcy = $3;
+	my $dst = $4;
+	my $dstx = $5;
+	my $dsty = $6;
+	$queries{$src."-".$dst} = 1;
+	#print "$srcx, $srcy, $dstx, $dsty   +++ ";
+	#print distance($srcx, $srcy, $dstx, $dsty)."\n";
+	incrDistanceHash(\%query_distance, distance($srcx, $srcy, $dstx, $dsty),
+			$query_distance_quant_step);
+      }
+
+      #parsing the connectivity traces
+      if($line =~ /^CONANA: (\d+\.\d+) _(\d+)_ (\d+) \[\d+->\d+->-?\d+\] \[(\d+)\]/o){
+
+	$conana{time} = $1;
+	$conana{node} = $2;
+	$conana{packetNr} = $3;
+	$conana{hops} = $4;
+      }
+      if($line =~ /^GCONANA: (\d+\.\d+) _(\d+)_ (\d+) \[\d+->\d+->-?\d+\] \[(\d+)\]/o){
+
+	$gconana{time} = $1;
+	$gconana{node} = $2;
+	$gconana{packetNr} = $3;
+	$gconana{hops} = $4;
+      }
+
+      if($line =~ /^HLS_CL    (\d+\.\d+) (\d+) \[(\d+) (\d+\.\d+) (\d+\.\d+) (\d+\.\d+)\] {(\d+\.\d+)}/o) {
+	$lookup{cache_lookups}++;
+	my $src = $2;
+	my $dst = $3;
+	my $lookup_time = $1;
+	my $entry_timestamp = $4;
+	my $x = $5;
+	my $y = $6;
+	my $deviation = $7;
+	$queries{$src."-".$dst} = 0;
+	# now start calculating
+	my $age = $lookup_time - $entry_timestamp;
+	if($cache_statistic{maxage} <= $age){
+	  $cache_statistic{maxage} = $age
+	}
+	if($cache_statistic{minage} >= $age){
+	  $cache_statistic{minage} = $age
+	}
+	$cache_statistic{totalage} += $age;
+	# deviation
+	incrDistanceHash(\%cl_deviation, $deviation,
+			 $deviation_quant_step);
+
+      }
+
+      if($line =~ /^HLS_REQ_s (\d+\.\d+) \((\d+_\d+)\) (\d+) ->(\d+) <(\d+)/o) {
+	$lookup{request_send}++;
+	my $time = $1;
+	my $reqid = $2;
+	my $source = $3;
+	my $target_node = $4;
+	my $target_cell = $5;
+	$queries{$source."-".$target_node} = 0;
+	incrHash(\%unanswered_requests, $reqid, 1);
+	$request_send_time{$reqid} = $time;
+	# EA
+	$ea_requests{$reqid} = ();
+	initializeRequestHash($reqid, $target_node, $target_cell);
+	# end EA
+      }
+
+      # request next level
+      if($line =~ /^HLS_REQ_n (\d+\.\d+) \((\d+_\d+)\) (\d+) ->(\d+) <(\d+) \d+\.\d+ \d+\.\d+ \((\d+)\)>/o) {
+	my $time = $1;
+	my $reqid = $2;
+	my $source = $3;
+	my $target_node = $4;
+	my $target_cell = $5;
+	my $level = $6;
+
+	# storing the next cell to which we forward this request
+	my $key = "rc" . $level . "_s";
+	$ea_requests{$reqid}->{$key} = $target_cell;
+
+	# storing the cell which is really responsible for the target_node
+	# on the given level
+	my $key = "rc" . $level . "_t";
+	$ea_requests{$reqid}->{$key} = $ea_actual_hierachy{$target_node}->{$level};
+	$ea_requests{$reqid}->{level} = $level;
+      }
+
+      # request locate
+      if($line =~ /^HLS_REQ_l \d+\.\d+ \((\d+_\d+)\) \d+ ->\d+ \[\d+\.\d+ \d+\.\d+ \d+\.\d+\] <(\d+) (\d+) \((\d+)\)>/o) {
+	my $reqid = $1;
+	my $myCell = $2;
+	my $targetCell = $3;
+	my $targetLevel = $4;
+	if (!(exists $request_first_locate_level{$reqid})){
+	  # there is no entry for this request, thus this is the first time we have
+	  # a location information for this request.
+	  #print "entering $reqid\n";
+	  $request_first_locate_level{$reqid} = $targetLevel;
+	  if($myCell == $targetCell) {
+	    $request_first_locate_samecell{$reqid} = 1;
+	  }
+	  else {
+	    
+	    $request_first_locate_samecell{$reqid} = 0;
+	  }
+	}
+      }
+      # end request locate
+
+      if(($line =~ /^HLS_REP_r (\d+\.\d+) \((\d+_\d+)\) \d+ <-\d+ \[(\d+\.\d+) (\d+\.\d+) (\d+\.\d+)\]/o) && 
+	 ($ea_requests{$2}->{status} ne "REP_r")) #we haven't aleready received a reply for this request
+	{
+	my $lookup_time = $1;
+	my $reqid = $2;
+	my $entry_timestamp = $3;
+	my $x = $4;
+	my $y = $5;
+
+	$lookup{reply_receive}++;
+	$unanswered_requests{$2}--;
+	# calculation
+	my $age = $lookup_time - $entry_timestamp;
+	if($reply_statistic{maxage} <= $age){
+	  $reply_statistic{maxage} = $age
+	}
+	if($reply_statistic{minage} >= $age){
+	  $reply_statistic{minage} = $age
+	}
+	$reply_statistic{totalage} += $age;
+
+	my $overall_time = $lookup_time - $request_send_time{$reqid};
+	incrQuantHash(\%request_time_hash, $overall_time, 1);
+
+	#EA
+	if($ea_requests{$reqid}->{status} ne "" ) {
+	  print "###error : $reqid previous $ea_requests{$reqid}->{status} now REP_r\n";
+	} 
+	$ea_requests{$reqid}->{status} = "REP_r";
+      }
+      
+      if($line =~ /^HLS_CIC_s \d+\.\d+ \((\d+_\d+)\).*</g) { 
+	my $counter = 0;
+	my $reqid = $1;
+	# count the number of cells (the no cell entries are -1, at
+	# the end of the line and won't be matched
+	while($line =~ /\G(\d+),/g) { $counter++;}
+
+	$cic_send_number_of_neighbors{$reqid} = $counter;
+	$cic_send{total}++;
+	incrHash(\%cic_send, $counter, 1);
+      }
+
+      if($line =~ /^HLS_REQ_d \d+\.\d+ \((\d+_\d+)\) \d+ \((\d+)\) (\S+) idev (\d+.\d+) mydev (\d+.\d+) metonode (\d+.\d+)/o) {
+	my $request = $1;
+	my $level = $2;
+	my $reason = $3;
+	my $information_deviation = $4;
+	my $my_distance_to_last_known_point = $5;
+	my $actual_distance = $6;
+#	print "REQ_d\n";
+	$request_drop{$level . " " . $reason}++;
+	$lookup{request_drop}++;
+	$unanswered_requests{$1}--;
+
+	if(exists $cic_send_number_of_neighbors{$request}) {
+	  # we have a drop after a cic send, analyse how much neighbors the cell 
+	  # had
+	  incrHash(\%request_drop_after_cic_send, 
+		   $cic_send_number_of_neighbors{$request}, 1);
+	}
+
+	if($reason eq "LNR") {
+	  if($information_deviation < $radio_range) {
+	    $request_drop_lnr_deviation{info_still_exact} += 1;
+	    
+	    if($actual_distance < $radio_range) {
+	      $request_drop_lnr_deviation{target_node_reachable} += 1;
+	    }
+	  } else {
+	    if($actual_distance < $radio_range) {
+	      $request_drop_lnr_deviation{info_not_exact_but_node_reachable} += 1;
+	    }
+	  }
+
+	  push(@lnr_gconana, $gconana{hops});
+	  push(@lnr_conana, $conana{hops});
+	  # we have "consumed" the information, thus setting it to
+	  # an non occuring value to indicate that there is no information
+	  $gconana{hops} = -1;
+	  $conana{hops} = -1;
+	}
+	if($reason eq "CAS"){
+	  if ($information_deviation < $radio_range) {
+	    $request_drop_cas_deviation_still_exact += 1;
+	  }
+	}
+
+	# ea
+	if($ea_requests{$request}->{status} ne "") {
+	  print "#error with reqid $request previous $ea_requests{$request}->{status} now $reason\n";
+	}
+	$ea_requests{$request}->{status} = $reason;
+	if(($reason eq "CTO") || ($reason eq "CTO")) {
+	  
+	}
+	  
+	  
+      }
+
+      if($line =~ /^HLS_REP_d \d+\.\d+ \((\d+_\d+)\)/o) {
+	$lookup{reply_drop}++;
+	$unanswered_requests{$1}--;
+	if( $ea_requests{$1}->{status} ne "") {
+	  print "error with request $1, status is  $ea_requests{$1}->{status}, but a reply to this is dropped\n";
+	}
+      }
+      
+      if($line =~ /^HLS_CC_sa (\d+\.\d+) \((\d+_\d+)\) \d+ -> \d+ \[\d+ (\d+\.\d+) (\d+\.\d+) (\d+\.\d+)\]/o) {
+	my $reqid = $2;
+	$ea_requests{$reqid}->{cc_sa} = "true";
+      }
+      # trace the packet drops (IFQ, TTL, CBK)
+      if($line =~ /^D \d+\.\d+ _\d+_ RTR  (\S+) \d+ HLS \d+ .*\] (\d+) \[.*\((\d+_\d+)\)/o) {
+	my $reason = $1;
+	my $packet_type = $2;
+	# to avoid that drops of e.g. cellcast replies falsify the result, we test if 
+	# it's the correct pkt type
+	if((@HLSTYPE[$packet_type] eq "REQUEST") || (@HLSTYPE[$packet_type] eq "REPLY")) {
+	  if($reason eq "IFQ") {
+	    if(@HLSTYPE[$packet_type] eq "REQUEST") {
+	      $lookup{ifq_drop_request}++;}
+	    if(@HLSTYPE[$packet_type] eq "REPLY") {
+	      $lookup{ifq_drop_reply}++;}
+	  }
+	  
+	  if($reason eq "TTL") {
+	    if(@HLSTYPE[$packet_type] eq "REQUEST") {
+	      $lookup{ttl_drop_request}++;}
+	    if(@HLSTYPE[$packet_type] eq "REPLY") {
+	      $lookup{ttl_drop_reply}++;}
+	  }
+	  
+	  if($reason eq "CBK") {
+	    if(@HLSTYPE[$packet_type] eq "REQUEST") {
+	      $lookup{cbk_drop_request}++;}
+	    if(@HLSTYPE[$packet_type] eq "REPLY") {
+	      $lookup{cbk_drop_reply}++;
+	      push(@cbk_gconana, $gconana{hops});
+	      push(@cbk_conana, $conana{hops});
+	      # we have "consumed" the information, thus setting it to
+	      # an non occuring value to indicate that there is no information
+	      $gconana{hops} = -1;
+	      $conana{hops} = -1;
+	    }
+	  }
+	  
+	  $unanswered_requests{$3}--;
+	  if(($ea_requests{$3}->{status} ne "") && (@HLSTYPE[$packet_type] eq "REPLY")){
+	    print "####### error reqid $3 reason $reason previous $ea_requests{$3}->{status}\n";
+	  }
+	  
+	  $ea_requests{$3}->{status} = $reason;
+	}
+      }
+
+     # trace NRTE drops
+     if($line =~ /^D \d+\.\d+ _\d+_ RTR NRTE \d+ HLS \d+ .*\] (\d+) \[.*\((\d+_\d+)\)/o) {
+	my $packet_type = $1;
+	if(@HLSTYPE[$packet_type] eq "REQUEST") {
+	  $lookup{nrte_drop_request}++;}
+	if(@HLSTYPE[$packet_type] eq "REPLY") {
+	  $lookup{nrte_drop_reply}++;}
+      
+	$unanswered_requests{$2}--;
+      }
+
+      # trace in which distance to a level 3 cell we were'nt able to forward
+      # a request
+      if($line =~ /HLS_REQ_u \d+\.\d+ \((\d+_\d+)\) \d+ \((\d+\.\d+) (\d+\.\d+)\) <\d+ (\d+\.\d+) (\d+\.\d+) \((\d+)\)>/o) {
+	my $reqid = $1;
+	my $nodex = $2;
+	my $nodey = $3;
+	my $cellx = $4;
+	my $celly = $5;
+	my $level = $6;
+	#calculations
+	my $distance = distance($nodex,$nodey, $cellx, $celly);
+	$request_u_distance{$level} += $distance;
+	$request_u_distance{$level."count"} += 1;
+
+	#EA
+	
+	my $deltaX = normalize($nodex - $cellx);
+	my $deltaY = normalize($nodey - $celly);
+	my $key = "rc" . $level . "_v"; # means "responsible cell on level x visited
+	if(($deltaX < $cellsize/2) && (($deltaY < $cellsize/2) )) {
+	  # this means the REQ_u has been done by a node which was in the
+	  # correct cell
+	  
+	  #$ea_requests{$reqid}->{$key} = "1";
+	} else {
+	  #$ea_requests{$reqid}->{$key} = "0";
+	}
+	
+	# end EA
+      }
+      # parsing the cellcast send to determine which cell we've reached (just
+      # for errorcases, if we reach a cell and the first node in this cell nows the
+      # location, we get a LNR or CAS error in the failure case)
+      if($line =~ /HLS_CC_sr (\d+\.\d+) \((\d+_\d+)\) (\d+) -\*(\d+)/o) {
+	my $time = $1;
+	my $reqid = $2;
+	my $source = $3;
+	my $target_node = $4;
+	my $actual_level =  $ea_requests{$reqid}->{level};
+	$ea_requests{$reqid}->{"rc".$actual_level."_v"} = "1";
+
+	#if($actual_level eq "3") {
+	#  print "$reqid\n";
+	#}
+
+	
+      }
+
+      # parsing the updates...
+      if($line =~ /HLS_UD_(r |fr) (\d+\.\d+) (\d+)<-(\d+) \[\d+\.\d+ \d+\.\d+ <\d+>\] <\d+ (\d+\.\d+) (\d+\.\d+) \((\d+)\)>/o) {
+	my $timestamp = $2;
+	my $receiving_node = $3;
+	my $sending_node = $4;
+	my $cellx = $5;
+	my $celly = $6;
+	my $level = $7;
+	# calculations...
+	if($level = 3) {
+	  $update_holder{$sending_node."x"} = $cellx;
+	  $update_holder{$sending_node."y"} = $celly;
+	  $update_holder{$sending_node."ts"} = $timestamp;
+	}
+      }
+      
+
+      # end of HLS result parsing
+      # wk: hls update parsing
+      
+      # wk: end hls update parsing
+      if($line =~ /^HLS_UPD_s \d+.\d+ (\d+) <(\d+) \d+.\d+ \d+.\d+ \((\d+)\)> (\S+)/o) {
+	my $node = $1;
+	my $cell = $2;
+	my $level = $3;
+	my $reason = $4;
+	incrHash(\%updates_send, "$level $reason", 1); #counts level+reason
+	incrHash(\%updates_send, "$level", 1); #only counts updates per level
+	if (exists $ea_actual_hierachy{$node}) {
+	  # there already exists an entry for this node, thus the HASH 
+	  # has been created, do nothing
+	} else {
+	  # create the hash
+	  $ea_actual_hierachy{$node} = ();
+	}
+	# update the hierachy
+	$ea_actual_hierachy{$node}->{$level} = $cell;
+      }
+
+      if($line =~ /^HLS_UD_(r |fr) \d+.\d+ \d+<-\d+ \[\d+.\d+ \d+.\d+ <\d+>\] <\d+ \d+.\d+ \d+.\d+ \((\d+)\)>/o) {
+	#	print "HLS_UD matches $1 $2\n";
+	incrHash(\%updates_received, "$2 $1", 1);
+      }
+      # handovers parsing
+      if($line =~ /^HLS_H_s   \d+\.\d+ \d+ <\d+ (\d+\.\d+) (\d+\.\d+)> -> <\d+ (\d+\.\d+) (\d+\.\d+)> (\d+)/o) {
+	$handovers{send}++;
+	my $srcx = $1;
+	my $srcy = $2;
+	my $dstx = $3;
+	my $dsty = $4;
+	my $numberOfInfos = $5;
+	#incrHash(\%handovers_number, $numberOfInfos, 1);
+	incrDistanceHash(\%handover_send_distance, distance($srcx, $srcy, $dstx, $dsty),
+			 $handover_distance_quant_step);
+      }
+
+      if($line =~ /^HLS_H_rr  \d+\.\d+ \d+<-\d+ \[\d+\.\d+ \d+\.\d+ <\d+>\] <\d+ \d+\.\d+ \d+\.\d+> (\d+)/o) {
+	$handovers{receive}++;
+	my $numberOfInfos = $1;
+	incrHash(\%handovers_number, $numberOfInfos, 1);
+      }
+
+      if($line =~ /^HLS_H_fr  \d+\.\d+ \d+<-\d+ \[\d+\.\d+ \d+\.\d+ <\d+>\] <\d+ \d+\.\d+ \d+\.\d+> (\d+)/o) {
+	$handovers{forcereceive}++;
+
+	my $numberOfInfos = $1;
+	incrHash(\%handovers_number, $numberOfInfos, 1);
+      }
+      
+      # GLS Update Packets need their arrival checked (for now)
+      if($line =~ /^LSCLS: (\d+.\d+) _(\d+)_/o) {
+	$stats{LOCS}{$LOCSTYPE[3]}{recv}++; 
+	next;
+      }
+
+      # MAC Collision Analysis
+      if (($line =~ /^MACDBG: \d+.\d+ _\d+_: COL (\S+) (\S+) (\d+) <-> (\S+) (\S+) (\d+)/o) ||
+	  ($line =~ /^MACCOL (\S+) (\S+) (\d+) <-> (\S+) (\S+) (\d+)/o) )
+	{
+	my ($ptype1, $psub1, $puid1, $ptype2, $psub2, $puid2) = ($1,$2,$3,$4,$5,$6);
+	my ($cause1, $cause2);
+
+	if ($psub1 == -1) { $cause1 = $ptype1; }
+	else {
+	  if (uc($ptype1) eq "CBF") { $cause1 = $CBFTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "GPSR") { $cause1 = $GPSRTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "LOCS") { $cause1 = $LOCSTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "HLS") { $cause1 = $HLSTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "PING") { $cause1 = $PINGTYPE[$psub1]; }
+	  else { $cause1 = "UK/$ptype1"; }
+	}
+	if ($psub2 == -1) { $cause2 = $ptype2; }
+	else {
+	  if (uc($ptype2) eq "CBF") { $cause2 = $CBFTYPE[$psub2]; }
+	  elsif (uc($ptype2) eq "GPSR") { $cause2 = $GPSRTYPE[$psub2]; }
+	  elsif (uc($ptype2) eq "LOCS") { $cause2 = $LOCSTYPE[$psub2]; }
+	  elsif (uc($ptype2) eq "HLS") { $cause2 = $HLSTYPE[$psub2];}
+	  elsif (uc($ptype2) eq "PING") { $cause2 = $PINGTYPE[$psub2]; }
+	  else { $cause2 = "UK/$ptype2"; }
+	}
+	my $reverse = 0;
+	if (exists $collisions{"$cause2<->$cause1"}) {
+	  $collisions{"$cause2<->$cause1"}++;
+	  $collisions{cols}++;
+	  $collisions{valid} = 1;
+	}else{
+	  $collisions{"$cause1<->$cause2"}++;
+	  $collisions{cols}++;
+	  $collisions{valid} = 1;
+	}
+      }
+
+      # Backwards Compatibility
+      if($line =~ /^([sf]) \d+.\d+ _\d+_ (\w+)\s+\S+ \d+ (\S+) (\d+).*/o) {
+	my ($op,$layer,$protocol,$size) = ($1,$2,$3,$4);
+
+	if ($layer eq "MAC") {
+	  $COMPAT{bw}{$layer}{$protocol}->{cnt} += 1;
+	  $COMPAT{bw}{$layer}{$protocol}->{bw} += $size;
+	}
+      }
+      if($line =~ /^[srfD] \d+.\d+ _\d+_ (\w+)\s+\S+ (\d+) (\S+) \d+ \[.*- \[.*\] \d+ \[(\d+)\] \d+.\d+/o) {
+	my ($layer,$uid,$protocol,$type) = ($1,$2,$3,$4);
+
+	if (($layer eq "AGT") && ($protocol eq "Ping") && ($type == 0))
+	  { $COMPAT{lookup}{$uid}{ping} = 1; }
+      }
+      if (($line =~ /^CBFDBG: (\d+.\d+) _(\S+)_: Sending (\d+) to Area (\d+)/o) ||
+	  ($line =~ /^CBFDBG: (\d+.\d+) _(\S+)_: Sent ACT \d+ for (\d+) to Area (\d+)/o))
+	{
+	  my ($time,$node,$uid,$area) = ($1,$2,$3,$4);
+
+	  if (exists $COMPAT{lookup}{$uid}->{ping}) {
+	    $COMPAT{area}{usage}{$area}++;
+	    $COMPAT{area}{sends}++;
+	    $COMPAT{area}{valid} = 1;
+	  }
+	}
+
+      # Line analysis
+      if($line =~ /^([srfD]) (\d+.\d+) _(\d+)_ (\w+)\s+(\S+) (\d+) (\S+) (\d+) \[\w+ \w+ (\w+).*- \[(\S+):\d+ (\S+):\d+ (\d+) (\S+)\] (.*)/o) {
+	my $op           = $1;
+	my $time         = $2;
+	my $node         = $3;
+	my $layer        = $4;
+	my $drop_rsn     = $5;
+	my $pkt_uid      = $6;
+	my $protocol     = $7;
+	my $pkt_size     = $8;
+	my $fromhex      = $9;
+	my $from         = hex($9);
+	my $pkt_src      = $10;
+	my $pkt_dst      = $11;
+	my $pkt_ttl      = $12;
+	my $pkt_nhop     = $13;
+	my $subline      = $14;
+
+	# Update Timestamp
+	if ($time > $duration) {
+	  $duration = $time;
+	}
+
+	# Measure Bandwidth Consumption
+	if ((($layer eq "RTR")||($layer eq "AGT")) &&
+	    (($op eq 's') || ($op eq 'f'))) {
+	  if ($protocol ne "Ping") {
+	    $bw{$layer}->{cnt} += 1;
+	    $bw{$layer}->{bw} += $pkt_size;
+	    $bw{$layer}{$protocol}->{cnt} += 1;
+	    $bw{$layer}{$protocol}->{bw} += $pkt_size;
+	  }
+	}
+	if (($protocol eq "HLS") && 
+	    ($subline =~ /^(\d+)/o)) {
+#($subline =~ /^(\d+) \[(\S+).*\]->\[(\S+).*\] : (\d+) (\d+) : (\w+) (\d+) \d+ \[.*\[.*\[(\S+)/o)) {
+	  #print "$subline\n";
+	  my $pkt_type     = $1;
+	#  my $locs_src     = $2;
+	 # my $locs_dst     = $3;
+	 # my $locs_seqno   = $4;
+	 # my $locs_maxhop  = $5;
+	 # my $locs_updrsn  = $6;
+	 # my $locs_cbk     = $7;
+	 # my $locs_nxt     = $8;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$HLSTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$HLSTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$HLSTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$HLSTYPE[$pkt_type]}{send}++; }
+	  }
+
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$HLSTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	## normal locservice
+	if (($protocol eq "LOCS") && 
+	    ($subline =~ /^(\d+) \[(\S+).*\]->\[(\S+).*\] : (\d+) (\d+) : (\w+) (\d+) \d+ \[.*\[.*\[(\S+)/o)) {
+	  my $pkt_type     = $1-1;
+	  my $locs_src     = $2;
+	  my $locs_dst     = $3;
+	  my $locs_seqno   = $4;
+	  my $locs_maxhop  = $5;
+	  my $locs_updrsn  = $6;
+	  my $locs_cbk     = $7;
+	  my $locs_nxt     = $8;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 's') {
+	    # GLS Update Reason
+	    if ($LOCSTYPE[$pkt_type] eq "UPDATE"){
+	      $gls_update{$locs_updrsn}++;
+	      $gls_update{valid} = 1;
+	    }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$LOCSTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	if (($protocol eq "DSR") &&
+	    ($subline =~ /^\d+ \[(\d+) (\d+)\] \[(\d+) \d+ \d+ (\d+)->(\d+)\] \[(\d+) \d+ (\d+) (\d+)->(\d+)\]/o)) {
+	  my $dsr_rreq       = $1;
+	  my $dsr_seqno      = $2;
+	  my $dsr_rrepl      = $3;
+	  my $dsr_rrepl_dst  = $4;
+	  my $dsr_rrepl_src  = $5;
+	  my $dsr_rerr       = $6;
+	  my $dsr_rerr_dst   = $7;
+	  my $dsr_rerr_blink = $8;
+
+	  # Packet Statistics
+	  my $pkt_type = 0;
+	  if (($dsr_rreq == 1) && ($dsr_rerr == 1)) { $pkt_type = 3; }
+	  elsif (($dsr_rrepl == 1) && ($dsr_rerr == 1)) { $pkt_type = 4; }
+	  elsif ($dsr_rreq == 1) { $pkt_type = 0; }
+	  elsif ($dsr_rrepl == 1) { $pkt_type = 1; }
+	  elsif ($dsr_rerr == 1) { $pkt_type = 2; }
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    if ($dsr_rreq == 1)  { $drops{$reason}{$DSRTYPE[0]}++; }
+	    if ($dsr_rrepl == 1) { $drops{$reason}{$DSRTYPE[1]}++; }
+	    if ($dsr_rerr == 1)  { $drops{$reason}{$DSRTYPE[2]}++; }
+	  }
+	  next;
+	}
+
+	if (($protocol eq "GPSR") && 
+	    ($subline =~ /^(\d+) \d+ \[\S+ \S+\]/o)) {
+	  my $pkt_type     = $1;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$GPSRTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	if (($protocol eq "CBF") && 
+	    ($subline =~ /^(\d+) \[(\d+)\] \[(\S+) (\S+) (\S+)\] \[.*\]->\[.*\] \[.*\]/o)) {
+	  my $pkt_type     = $1;
+	  my $cbf_retries  = $2;
+	  my $cbf_pid      = $3;
+	  my $cbf_area     = $4;
+	  my $cbf_sid      = $5;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$CBFTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	if (($protocol eq "Ping") &&
+	    ($subline =~ /^(\d+) \[(\d+)\] \d+.\d+/o)) {
+	  my $ping_seqno = $1; # seqno
+	  my $ping_type  = $2; # type
+	  my $flowid = "$pkt_src->$pkt_dst/$pkt_uid/$ping_seqno";
+
+	  # Bandwidth Consumption
+	  if ((($layer eq "RTR")||($layer eq "AGT")) &&
+	      (($op eq 's') || ($op eq 'f'))) {
+	    $bw{$layer}->{cnt} += 1;
+	    $bw{$layer}->{bw} += $pkt_size;
+	    $bw{$layer}{$PINGTYPE[$ping_type]}->{cnt} += 1;
+	    $bw{$layer}{$PINGTYPE[$ping_type]}->{bw} += $pkt_size;
+	  }
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$PINGTYPE[$ping_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$PINGTYPE[$ping_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$PINGTYPE[$ping_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$PINGTYPE[$ping_type]}{send}++; }
+	  }
+
+	  # Write RTE File
+	  if ( (($layer eq 'RTR') && (($op eq 's')||($op eq 'f')||($op eq 'D'))) ||
+	       (($layer eq 'AGT') && (($op eq 's')||($op eq 'r'))) ) {
+	    if ($write_file){ print RTEFILE "$op $time _$node\_ $layer $pkt_uid $protocol [x x $fromhex - [$pkt_src:x $pkt_dst:x] $ping_seqno [$ping_type] \n"; }
+	  }
+
+	  # Get Type for Lookup Table
+	  if ($ping_type == 0) { $LOOKUP{$pkt_uid}->{ping} = 1; }
+
+	  if ($layer eq "AGT") {
+	    if ($op eq 's') {
+
+	      if ($ping_type == 0) { $duplicates{sent}++; }
+
+	      if (not exists $PKT{$PINGTYPE[$ping_type]}{$flowid}) {
+		# Build Packet Tree
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{sends}    = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{bw}       = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{hops}     = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{taken}    = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{shortest} = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{src}      = $pkt_src;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{dst}      = $pkt_dst;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{uid}      = $pkt_uid;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{start}    = $time;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{startTTL} = $pkt_ttl;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{reached}  = 0;
+	      }
+
+	      my $key = "$pkt_src/$pkt_dst";
+	      if (($ping_type == 0) && (not exists $LAT{$key}{start})) {
+		$LAT{$key}{start} = $time;
+	      }
+
+	      if (($miss_analysis == 1) && ($noFiles == 1)) {
+		$delivery_count{$pkt_uid} = 0;
+	      }
+
+	    } elsif ($op eq 'r') {
+
+	      if ($ping_type == 0) { $duplicates{recv}++; }
+
+	      # Build Route Tree
+	      if ($node == $PKT{$PINGTYPE[$ping_type]}{$flowid}->{dst}) {
+		if ($PKT{$PINGTYPE[$ping_type]}{$flowid}->{reached} == 0) {
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}->{reached}  = 1;
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}->{taken}    = $LOOKUP{$pkt_uid}->{taken};
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}->{shortest} = $LOOKUP{$pkt_uid}->{shortest};
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}{end}    = $time;
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}{endTTL} = $pkt_ttl-1;
+		}
+	      }
+
+	      my $key = "$pkt_src/$pkt_dst";
+	      if (($ping_type == 0) && (not exists $LAT{$key}{end})) {
+		$LAT{$key}{end} = $time;
+	      }
+
+	      if (($miss_analysis == 1) && ($noFiles == 1)) {
+		$delivery_count{$pkt_uid}++;
+	      }
+	    }
+	  }
+	  if ($layer eq "RTR") {
+
+	    if (($ping_type == 0) && ($op eq 'D')) { $duplicates{recv}++; }
+
+	    # Build Packet Tree
+	    if (($op eq 's')||($op eq 'f')) {
+	      $PKT{$PINGTYPE[$ping_type]}{$flowid}->{sends}++;
+	      $PKT{$PINGTYPE[$ping_type]}{$flowid}->{bw} += $pkt_size;
+	      if (not exists $PKT{$PINGTYPE[$ping_type]}{$flowid}->{route}->{$node}) {
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}->{hops}++;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}->{route}->{$node} = 1;
+	      }
+	    }
+
+	    if ($op eq 'D') {
+	      my $reason = "$layer/$drop_rsn";
+	      $drops{$reason}{$PINGTYPE[$ping_type]}++;
+	    }
+	  }
+	  next;
+	}
+
+	# MAC layer packets should only be added to
+	# the drop statistic
+	if ($layer eq "MAC") {
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$protocol}++;
+	  }
+	  next;
+	}
+
+	# IFQ packets should only be added to
+	# the drop statistic
+	if ($layer eq "IFQ") {
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$protocol}++;
+	  }
+	  next;
+	}
+
+	# Catch unknown protocols
+	my $unknown = "UKN/$protocol";
+
+	# Packet Statistics
+	if ($layer eq "RTR") {
+	  if ($op eq 'D') { $stats{$protocol}{$unknown}{drop}++; }
+	  if ($op eq 'r') { $stats{$protocol}{$unknown}{recv}++; }
+	  if ($op eq 'f') { $stats{$protocol}{$unknown}{forw}++; }
+	  if ($op eq 's') { $stats{$protocol}{$unknown}{send}++; }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$unknown}++;
+	  }
+	}
+
+	# Debug
+	#print "Ignored: $line\n";
+      }
+    }
+    close(FILE);
+
+    if ($write_file) { close(RTEFILE); }
+
+    print " done\n";
+
+    # Compatibility Evals
+    if ($simulator_eval == 0) {
+      foreach my $protocol (keys %{$COMPAT{bw}{MAC}}) {
+	$bw{MAC}{$protocol}->{cnt} += $COMPAT{bw}{MAC}{$protocol}->{cnt};
+	$bw{MAC}{$protocol}->{bw} += $COMPAT{bw}{MAC}{$protocol}->{bw};
+	$bw{MAC}->{cnt} += $COMPAT{bw}{MAC}{$protocol}->{cnt};
+	$bw{MAC}->{bw} += $COMPAT{bw}{MAC}{$protocol}->{bw};
+      }
+      my $sends = 0;
+      for (my $i=0; $i < 3; $i++) {
+	$areausage{usage}{$i} += $COMPAT{area}{usage}{$i};
+      }
+      $areausage{sends} += $COMPAT{area}{sends}++;
+      if (exists $COMPAT{area}{valid}) {
+	$areausage{valid} = 1;
+      }
+    }else{
+      # Reset Variable for next file
+      $simulator_eval = 0;
+    }
+
+    # Intermediate Hash Evaluation
+    evalPacketFlows();
+    evalDelivery();
+    evalLatency();
+    # Intermediate Hash Evaluation HLS
+    evalRequestLocate();
+    calculateEA();
+  }
+
+  # Fill Hashes
+  padHash(\%latency_spectrum, $quant_step);
+
+  # Data Display
+  if (($latency_analysis == 0) && ($processed > 0)) {
+    printStatistics();
+    writeStatistics();
+  }
+}
+
+################################################################
+
+
+#################################
+#
+# Packet Delivery
+#
+sub evalDelivery {
+
+  my $debug = 0;
+
+  foreach my $type (keys %PKT) {
+
+    my ($sends,$recv) = (0,0);
+    foreach my $flowid (keys %{$PKT{$type}}) {
+      $delivery{$type}{sends}++;
+      $sends++;
+      if ($PKT{$type}{$flowid}->{reached}) {
+	$delivery{$type}{recv}++;
+	$recv++;
+      }
+    }
+
+    # Sample Delivery of this File
+    $delivery{$type}{dels}{$delivery{$type}{cnt}} = calcPercent($sends,$recv);
+
+    if ($debug) {
+      print "sends: $sends / $delivery{$type}{sends}\n";
+      print "recv: $recv / $delivery{$type}{recv}\n";
+      print "smaldel $delivery{$type}{cnt}: $delivery{$type}{dels}{$delivery{$type}{cnt}} %\n";
+    }
+
+    $delivery{$type}{cnt}++;
+  }
+}
+
+sub printDelivery {
+
+  my $debug = 0;
+
+  print "Delivery Statistics:\n\n";
+
+  foreach my $type (keys %delivery) {
+
+    my ($var,$cnt) = (0,0);
+    my $average = calcPercent($delivery{$type}{sends},$delivery{$type}{recv});
+    if ($debug) { print "Average is: $average %\n"; }
+
+    foreach my $no (keys %{$delivery{$type}{dels}}) {
+      if ($debug) { printf("$no: $delivery{$type}{dels}{$no} %s -> %f\n","%",($average - $delivery{$type}{dels}{$no})); }
+      $var += (($average - $delivery{$type}{dels}{$no}) * ($average - $delivery{$type}{dels}{$no}));
+      $cnt++;
+    }
+    if ($cnt > 1) { $var /= $cnt-1; }
+    else { $var = 0; }
+    my $deviation = sqrt($var);
+    if ($debug) { print "Deviation is: $deviation %\n"; }
+
+    printf("$type Packet Delivery: %i / %i -> %.2f %s (+/- %.2f)\n", 
+	   $delivery{$type}{recv}/$noFiles, $delivery{$type}{sends}/$noFiles, $average, "%", $deviation);
+  }
+
+  print "\n";
+}
+
+sub printDeliveryCount {
+
+  print "Packet Receives:\n\n";
+  foreach my $uid (sort keys %delivery_count) {
+    print "\t$uid \t:\t$delivery_count{$uid}\n";
+  }
+  print "\n";
+}
+
+# wk
+sub printHLS {
+  my $key;
+  my $value;
+
+  print "HLS statistics:\n\n";
+  print "Queries         : $lookup{queries}\n";
+  my $avgage = $cache_statistic{totalage} / $lookup{cache_lookups};
+  print "Cache Lookups   : $lookup{cache_lookups} min age $cache_statistic{minage}, max age $cache_statistic{maxage}, avg age $avgage\n";
+  print "Requests send   : $lookup{request_send}\n";
+  $avgage = $reply_statistic{totalage} / $lookup{reply_receive};
+  print "Replies received: $lookup{reply_receive} min age $reply_statistic{minage}, max age $reply_statistic{maxage}, avg age $avgage\n";
+  # requests sropped
+  print "Requests dropped: $lookup{request_drop} \n";
+  foreach $key (sort(keys %request_drop)) {
+    print "       $key : $request_drop{$key}\n"; 
+  }
+ 
+  print "Replies dropped : $lookup{reply_drop}\n";
+  my $total = $lookup{ifq_drop_request} + $lookup{ifq_drop_reply};
+  print "IFQ drops       : $total (req $lookup{ifq_drop_request}, reply $lookup{ifq_drop_reply})\n";
+  $total = $lookup{ttl_drop_request} + $lookup{ttl_drop_reply};
+  print "TTL drops       : $total (req $lookup{ttl_drop_request}, reply $lookup{ttl_drop_reply})\n";
+  $total = $lookup{cbk_drop_request} + $lookup{cbk_drop_reply};
+  print "CBK drops       : $total (req $lookup{cbk_drop_request}, reply $lookup{cbk_drop_reply})\n";
+  $total = $lookup{nrte_drop_request} + $lookup{nrte_drop_reply};
+  print "NRTE drops      : $total (req $lookup{nrte_drop_request}, reply $lookup{nrte_drop_reply})\n";
+  my $failure_rate = ($lookup{queries} - $lookup{cache_lookups} - $lookup{reply_receive}) / $lookup{queries};
+  # following code rounds $failure_rate to two decimals behind commma
+  $failure_rate = $failure_rate * 10000;
+  $failure_rate = int($failure_rate + 0.5);
+  $failure_rate = $failure_rate / 100;
+  # end rounding
+  print "failure rate    : $failure_rate %\n"; 
+  print "\n";
+  
+  printRequestDropLnrDeviation();
+  print "CAS info still exact : $request_drop_cas_deviation_still_exact\n";
+  print "Requests unforwordable distance to RC:\n";
+  my $index = 1;
+  my $cumulatet_distance;
+  my $number;
+  while($cumulatet_distance = $request_u_distance{$index}) {
+    $number = $request_u_distance{$index."count"};
+    my $avg = $cumulatet_distance / $number;
+
+    print "level $index avg distance to cell : $avg\n";
+    $index++;
+  }
+  print "Unanswered requests : \n";
+
+  my $counter = 0;
+  while (($key,$value) = each %unanswered_requests) {
+    if($unanswered_requests{$key} > 0) {
+      $counter++;
+      print "$key, ";
+    }
+  }
+
+  print "test-queries without cl or req_s : ";
+  while (($key,$value) = each %queries) {
+    if($queries{$key} > 0) {
+      print "$key, ";
+    }
+  }
+  print "\n";
+  
+  print "\nMissing replies: $counter";
+  print "\n\n";
+  #printConnectivityAnalisis();
+  printRequestTravelTime();
+  print "\n";
+  printRequestFirstLocate();
+  print "\n";
+  printCic();
+  print "\n";
+  printUpdateStats();
+  print "\n";
+  print "Query Source - Destination Distance : \n";
+  printDistanceHash(\%query_distance, $query_distance_quant_step);
+  print "\n";
+  print "Cache Lookup Deviation : \n";
+  my $cache_entries_above_rr = printCacheLookupHash(\%cl_deviation, $deviation_quant_step);
+  my $percentage_of_all_queries = ($cache_entries_above_rr / $lookup{queries})*100;
+  printf("This corresponds to %.2f percent of all queries\n", $percentage_of_all_queries);
+  print "\n";
+  printHandoverStats();
+  print "\n";
+  printEA();
+  print "\n------ HLS statistics end --------------------------------------\n";
+}
+
+# EA
+sub initializeRequestHash {
+  my $reqid = shift();
+  my $target_node = shift();
+  my $target_cell = shift();
+  # the rc value will be set to 1 when a REQ_u in the correct cell is found
+  $ea_requests{$reqid}->{rc1_v} = "0"; # responsible cell level 1 visited
+  $ea_requests{$reqid}->{rc2_v} = "0"; # responsible cell level 2 visited
+  $ea_requests{$reqid}->{rc3_v} = "0"; # responsible cell level 3 visited
+  $ea_requests{$reqid}->{status} = "";
+  $ea_requests{$reqid}->{cc_sa} = "false"; # set to true if at least one
+  # cellcast answer was sent for this request
+  
+  # responsible cell level 1 seen from sender
+  $ea_requests{$reqid}->{rc1_s} = $target_cell;
+  # responsible cell level 1 seen from target node
+  $ea_requests{$reqid}->{rc1_t} = $ea_actual_hierachy{$target_node}->{1};
+
+  $ea_requests{$reqid}->{level} = 1;
+}
+
+sub calculateEA {
+  # loop through the requests
+  # we only want to analyze the CTO drops here !
+  foreach my $key (keys(%ea_requests)) {
+    if($ea_requests{$key}->{status} eq "CTO")
+       {
+	 #print "status : $ea_requests{$key}->{status} \n";
+
+	 # if an cellcast answer has been send (but not received)
+	 if($ea_requests{$key}->{cc_sa} eq "true") {
+	   incrHash(\%ea_drop_reasons, "ctoaftercc_sa", 1);
+	 } else {
+	   # no cc answer send
+	   my $reachability = 
+	     "$ea_requests{$key}->{rc3_v}$ea_requests{$key}->{rc2_v}$ea_requests{$key}->{rc1_v}";
+	   incrHash(\%ea_reach_stats, $reachability, 1 );
+	   my $cells_reached = $ea_requests{$key}->{rc3_v} + $ea_requests{$key}->{rc2_v} +
+	     $ea_requests{$key}->{rc1_v};
+	   incrHash(\%ea_cells_reached_in_request_sender_hierachy, $cells_reached, 1);
+	 }
+       }
+  }
+
+  # loop through the requests
+  foreach my $reqid (keys(%ea_requests)) {
+    my $cells_reached = 0;
+    for (my $i=1; $i < 4; $i++) {
+      # if both cells are equal and the correct cell is reached, increment
+      if($ea_requests{$reqid}->{"rc$i"."_s"} == $ea_requests{$reqid}->{"rc$i"."_t"}) {
+	if($ea_requests{$reqid}->{"rc$i"."_s"} ne "") {
+	  #print "$reqid s $ea_requests{$reqid}->{\"rc$i\".\"_s\"} t $ea_requests{$reqid}->{\"rc$i\".\"_t\"} v $ea_requests{$reqid}->{\"rc$i\".\"_v\"} cc_sa: $ea_requests{$reqid}->{cc_sa}\n";
+	}
+	# same cell
+	if($ea_requests{$reqid}->{"rc$i"."_v"} eq "1") {
+	  $cells_reached = $cells_reached + 1;
+	}
+      }
+    }
+    # the reachability is only correct for CTO at the moment
+    if(($ea_requests{$reqid}->{status} eq "CTO") && !($ea_requests{$reqid}->{cc_sa} eq "true")){
+      incrHash(\%ea_correct_cells_reached, $cells_reached, 1);
+      #if($cells_reached == 0) {
+      #	print "0 cells : $reqid\n";
+      #}
+    }
+  }
+}
+
+sub printEA {
+  # loop through the cell reachability stats
+  print "Cells reached in given hierachy (seen from request sender)\n";
+  print "321 level\n";
+  foreach my $key (sort((keys(%ea_reach_stats)))) {
+    # the value in brackets shows the value for the successfull requests
+    print "$key : $ea_reach_stats{$key}\n";
+  }  
+  print "How much of the imagined hierachy has been reached:\n";
+  foreach my $key (sort((keys(%ea_cells_reached_in_request_sender_hierachy)))) {
+    print "$key : $ea_cells_reached_in_request_sender_hierachy{$key}\n";
+  }
+  
+  print "\n";
+  print "How much of the real hierachy has been reached:\n";
+  
+  for (my $i=0; $i < 4; $i++) {  
+    print "$i cells $ea_correct_cells_reached{$i}\n";
+  }
+  print "\n";
+  
+  print "Detailed drop reasons\n";
+  print " CTO after CC_sa : $ea_drop_reasons{ctoaftercc_sa}\n";
+}
+# end EA
+
+sub printRequestDropLnrDeviation {
+  print "Info still exact enough           : $request_drop_lnr_deviation{info_still_exact}\n";
+  print "Node reachable with exact info    : $request_drop_lnr_deviation{target_node_reachable}\n";
+  print "Node reachable without exact info : $request_drop_lnr_deviation{info_not_exact_but_node_reachable}\n";
+  print "Unnecessary LNR-drops             : ";
+  print  $request_drop_lnr_deviation{target_node_reachable} + 
+    $request_drop_lnr_deviation{info_not_exact_but_node_reachable} . "\n";
+}
+
+sub printRequestTravelTime {
+  my $key;
+  print "Request Travel Time : \n";
+  foreach $key (sort keys %request_time_hash) {
+    printf("$key s: %.2f % \n", calcPercent( $lookup{reply_receive},
+					     $request_time_hash{$key}));
+  }
+}
+
+
+sub printConnectivityAnalisis {
+  my $element;
+  my $counter = 0;
+  print "CBK reply drops connectivity : overall (greedy)\n";
+  foreach $element(@cbk_conana) {
+    print "$cbk_conana[$counter] ($cbk_gconana[$counter]), ";
+    $counter++;
+  }
+  print "\n";
+
+  print "LNR reply drops connectivity : overall (greedy)\n";
+  foreach $element(@lnr_conana) {
+    print "$lnr_conana[$counter] ($lnr_gconana[$counter]), ";
+    $counter++;
+  }
+  print "\n";
+  
+}
+
+sub printHandoverStats {
+  my $key;
+  my $totalnumber = 0;
+  my $value = 0;
+  print "Handovers: \n";
+  print "Send           : $handovers{send}\n";
+  print "Real receive   : $handovers{receive}\n";
+  print "Forced receive : $handovers{forcereceive}\n";
+  print "Handover Send Distance : \n";
+  printDistanceHash(\%handover_send_distance, $handover_distance_quant_step);
+  print "\n";
+
+  print "Handovers number of infos per Packet \n";
+  foreach $key (sort keys %handovers_number) {
+    print "$key     : $handovers_number{$key}\n";
+    $totalnumber += $handovers_number{$key};
+    $value += ($key * $handovers_number{$key});
+  }
+  printf("Average of %.2f infos per handover\n",  round($value/$totalnumber));
+  #print "P.S.: I know there is no plural of information...\n";
+}
+
+sub printRequestFirstLocate {
+  my $key;
+  print "Request first locate: \n";
+  print "Same cell \n";
+  foreach $key (keys %request_locate_same_cell) {
+    printf("Level $key : %.2f % \n", calcPercent($request_locate_counter, $request_locate_same_cell{$key}));
+  }
+
+  print "Not Same cell \n";
+  foreach $key (keys %request_locate_not_same_cell) {
+    printf("Level $key : %.2f % \n", calcPercent($request_locate_counter, $request_locate_not_same_cell{$key}));
+  }
+
+sub printCic {
+  my $key;
+  print "CIC results\n";
+  print "total cics : $cic_send{total}\n";
+  foreach $key (sort keys %cic_send) {
+    if($key != "total") {
+      print "Cell with $key neighbors: $cic_send{$key}\n";
+    }
+  }
+  print "\n";
+
+  print "CIC drops with respect to number of neighbors\n";
+  foreach $key (sort keys %request_drop_after_cic_send) {
+     print "Cell with $key neighbors: Dropping $request_drop_after_cic_send{$key} requests\n";
+  }
+  
+}
+
+sub printUpdateStats {
+  print "Update statistics :\n";
+
+  # updates send
+  print "send: \n";
+  foreach my $key (sort(keys %updates_send)) {
+    # contain the updates send by level + those by level and reason
+    print "$key : $updates_send{$key}\n"; 
+  }
+  print "\n";
+  print "received : \n";
+  my $send_key;
+  #updates received
+  foreach my $key (sort(keys %updates_received)) {
+    # parsing the level to calculate the percentage
+    if($key =~ /(\d+)/o) {
+      $send_key = $1;
+    } else {
+      $send_key = "0";
+    }
+    print "$key : $updates_received{$key} ("; 
+    print round(calcPercent($updates_send{$send_key}, $updates_received{$key})) . " %)\n";
+  }
+}
+  
+sub evalRequestLocate {
+  my $key;
+  my $value; 
+  # counting the total number of locates
+  # accumulate our knowledge about the first locate of a request
+  # (we accumulate it so that we can say: on level 1, 20 % of locates in
+  # correct cell, 80 % not in correct cell)
+  foreach $key (keys %request_first_locate_level) {
+    $request_locate_counter++;
+    if($request_first_locate_samecell{$key} == 1) {
+      # the locate was in the correct cell
+      incrHash(\%request_locate_same_cell, $request_first_locate_level{$key}, 1);
+    }
+    else {
+      incrHash(\%request_locate_not_same_cell, $request_first_locate_level{$key}, 1);
+    }
+  }
+}
+
+
+}
+
+sub distance {
+  my $x1 = shift();
+  my $y1 = shift();
+  my $x2 = shift();
+  my $y2 = shift();
+  my $deltax = $x2 - $x1;
+  my $deltay = $y2 - $y1;
+  my $distance = sqrt(($deltax*$deltax)+($deltay*$deltay));
+  return $distance;
+}
+
+sub normalize {
+  my $value = shift();
+  if($value < 0) {
+    return -$value;
+  }
+  return $value;
+    
+}
+
+sub incrDistanceHash {  
+  my $hRef = shift();
+  my $hKey = shift();
+  my $step = shift();
+  my $tmpQuantStep = $quant_step;
+  $quant_step = $step;
+  incrQuantHash($hRef, $hKey, 1);
+  # store the maximum (distance)
+  if($hRef->{max} < $hKey) {
+    $hRef->{max} = $hKey;
+  }
+  # remember the total number of elements in the hash
+  $hRef->{numberOfEntries}++;
+
+  $quant_step = $tmpQuantStep;
+}
+
+sub printCacheLookupHash {
+  my $hRef = shift();
+  my $step = shift();
+  my $value;
+  my $total = $hRef->{numberOfEntries};
+  my $max = $hRef->{max};
+  my $actual = 0;
+  my $next;
+  my $radiorange = 250;
+  my $lookup_abover_rr = 0;
+  while ($actual < $max) {
+    $value = $hRef->{$actual};
+    $next = $actual + $step;
+    print "$actual to $next m : " ;
+    print round(calcPercent($total, $value)) . " %\n";
+    $actual = $next;
+    if($next > $radiorange) {
+      $lookup_abover_rr += $value;
+    }
+  }
+  print "Entries above radiorange: " .
+    round(calcPercent($total, $lookup_abover_rr)) . " %\n";
+  return $lookup_abover_rr;
+}
+
+sub printDistanceHash {
+  my $hRef = shift();
+  my $step = shift();
+  my $value;
+  my $total = $hRef->{numberOfEntries};
+  my $max = $hRef->{max};
+  my $actual = 0;
+  my $next;
+  while ($actual < $max) {
+    $value = $hRef->{$actual};
+    $next = $actual + $step;
+    print "$actual to $next m : " ;
+    print round(calcPercent($total, $value)) . " %\n";
+    $actual = $next;
+  }
+}
+
+sub round {
+  my $input = shift();
+  $input = $input * 100;
+  $input = int($input + 0.5);
+  $input = $input / 100;
+}
+#end wk
+
+#################################
+#
+# Packet Statistics
+#
+sub printPktStats {
+
+  print "Packet Statistics:\n\n";
+
+  print"\t\t\t    Sent       Forw       Recv       Drop\n";
+
+  foreach my $protocol (sort keys %stats) {
+    printf("\tRTR/$protocol\n");
+    foreach my $type (sort keys %{$stats{$protocol}}) {
+      printf("\t\t$type\t%8i   %8i   %8i   %8i\n",
+	     $stats{$protocol}{$type}{send}/$noFiles,
+	     $stats{$protocol}{$type}{forw}/$noFiles,
+	     $stats{$protocol}{$type}{recv}/$noFiles,
+	     $stats{$protocol}{$type}{drop}/$noFiles);
+    }
+  }
+  print "\n";
+}
+
+#################################
+#
+# Packet Drops
+#
+sub printDrops {
+
+  printf("Packet Drops:\n\n");
+  foreach my $reason (sort keys %drops) {
+    printf("\t$reason:\n");
+    foreach my $type (sort keys %{$drops{$reason}}) {
+      printf("\t\t$type\t: %.2f\n",$drops{$reason}{$type}/$noFiles);
+    }
+  }
+  print("\n");
+}
+
+#################################
+#
+# Reachability Information
+#
+sub printReachability {
+
+  printf("No-Route Drop Reachability:\n\n");
+  foreach my $proto (sort keys %reachability) {
+    printf("\t$proto:\n");
+    printf("\t   Dijkstra Reachable\t: %.2f / %.2f -> %.2f %s\n",
+	   $reachability{$proto}{shortest}/$noFiles,
+	   $reachability{$proto}{drops}/$noFiles,
+	   calcPercent($reachability{$proto}{drops},$reachability{$proto}{shortest}),
+	  "%");
+    printf("\t   Greedy Reachable\t: %i / %i -> %.2f %s\n",
+	   $reachability{$proto}{greedy}/$noFiles,
+	   $reachability{$proto}{drops}/$noFiles,
+	   calcPercent($reachability{$proto}{drops},$reachability{$proto}{greedy}),
+	   "%");
+  }
+  printf("\n");
+
+}
+
+#################################
+#
+# Bandwidth
+#
+sub printBW {
+
+  my $bwfac = 1;
+  my $fac = 1 / $noFiles;
+  my $unit = shift();
+
+  if ($unit eq "kbps") { # Kilobit/sec
+    $bwfac = 8 / (1024 * $duration * $noFiles);
+  }elsif ($unit eq "mbps") { # Megabit/sec
+    $bwfac = 8 / (1024 * 1024 * $duration * $noFiles);
+  }else{ # Default: Kilobyte/run
+    $unit = "kB/Run";
+    $bwfac = 1 / (1024 * $noFiles);
+  }
+
+  printf("Bandwidth Consumption ($unit):\n\n");
+
+  foreach my $l (sort keys %bw) {
+    printf("\t$l\t:\t%.2f $unit\t(%.2f s/f)\n",$bwfac*$bw{$l}->{bw},$fac*$bw{$l}->{cnt});
+    foreach my $p (sort keys %{$bw{$l}}) {
+      if (($p ne "bw") && ($p ne "cnt")) {
+	printf("\t  $p\t:\t%.2f $unit\t(%.2f s/f)\n", $bwfac*$bw{$l}->{$p}->{bw},$fac*$bw{$l}->{$p}->{cnt});
+      }
+    }
+  }
+  printf("\n");
+}
+
+#################################
+#
+# Packet Flow Information
+#
+sub evalPacketFlows {
+
+  my $debug = 0;
+
+  foreach my $type (keys %PKT) {
+
+    foreach my $flowid (keys %{$PKT{$type}}) {
+
+      if ($PKT{$type}{$flowid}->{reached}) {
+
+	$packetflow{$type}{reached}{cnt}++;
+
+	# Judge Route Quality
+	$packetflow{$type}{taken} += $PKT{$type}{$flowid}->{taken};
+	$packetflow{$type}{shortest} += $PKT{$type}{$flowid}->{shortest};
+
+	# Aquire optimal route
+	my $optimal;
+	if ($PKT{$type}{$flowid}->{taken} < $PKT{$type}{$flowid}->{shortest}) {
+	  $optimal = $PKT{$type}{$flowid}->{taken};
+	}else{
+	  $optimal = $PKT{$type}{$flowid}->{shortest};
+	}
+
+	# Count All
+	$packetflow{$type}{reached}{sends} += $PKT{$type}{$flowid}->{sends};
+	$packetflow{$type}{reached}{bw} += $PKT{$type}{$flowid}->{bw};
+
+	my $sendbw = 0;
+	if ($PKT{$type}{$flowid}->{sends} != 0) {
+	  $sendbw = $PKT{$type}{$flowid}->{bw} / $PKT{$type}{$flowid}->{sends};
+	}
+
+	# Necessary is: Optimal Route with 1 Send/Hop
+	$packetflow{$type}{nec}{sends} += $optimal;
+	$packetflow{$type}{nec}{bw} += $optimal * $sendbw;
+
+	# Redundant is: Everything that is not necessary
+	$packetflow{$type}{red}{sends} += $PKT{$type}{$flowid}->{sends} - $optimal;
+	$packetflow{$type}{red}{bw} += ($PKT{$type}{$flowid}->{sends} - $optimal) * $sendbw;
+      }else{
+	$packetflow{$type}{dropped}{cnt}++;
+	# Count All
+	$packetflow{$type}{dropped}{sends} += $PKT{$type}{$flowid}->{sends};
+	$packetflow{$type}{dropped}{bw} += $PKT{$type}{$flowid}->{bw};
+      }
+
+      # Calculate Load
+      $packetflow{$type}{flows}++;
+      $packetflow{$type}{sends} += $PKT{$type}{$flowid}->{sends};
+      $packetflow{$type}{bw} += $PKT{$type}{$flowid}->{bw};
+    }
+  }
+}
+
+sub printPacketFlows {
+
+  my $bwfac = 1;
+  my $fac = 1 / $noFiles;
+  my $unit = shift();
+
+  if ($unit eq "kbps") { # Kilobit/sec
+    $bwfac = 8 / (1024 * $duration * $noFiles);
+  }elsif ($unit eq "mbps") { # Megabit/sec
+    $bwfac = 8 / (1024 * 1024 * $duration * $noFiles);
+  }else{ # Default: Kilobyte/run
+    $unit = "kB/Run";
+    $bwfac = 1 / (1024 * $noFiles);
+  }
+
+  foreach my $type (sort keys %packetflow) {
+
+    printf("$type Flow Information:\n\n");
+
+    if ($packetflow{$type}{reached}{cnt} != 0) {
+      printf("\tAvg Taken Route (Reached)   :\t%.2f\n",$packetflow{$type}{taken}/$packetflow{$type}{reached}{cnt});
+      printf("\tAvg Shortest Route (Reached):\t%.2f\n",$packetflow{$type}{shortest}/$packetflow{$type}{reached}{cnt});
+    }
+    printf("\n");
+
+    printf("\tDropped Targets         :\t%.2f \n",$packetflow{$type}{dropped}{cnt}*$fac);
+    printf("\tDropped Transmissions   :\t%.2f \n",($packetflow{$type}{dropped}{sends}*$fac));
+    printf("\tDropped Traffic         :\t%.2f $unit\n",($packetflow{$type}{dropped}{bw}*$bwfac));
+    printf("\tReached Targets         :\t%.2f \n",$packetflow{$type}{reached}{cnt}*$fac);
+    printf("\tReached Transmissions   :\t%.2f \n",($packetflow{$type}{reached}{sends}*$fac));
+    printf("\tReached Traffic         :\t%.2f $unit\n",($packetflow{$type}{reached}{bw}*$bwfac));
+    printf("\t   Nec. Transmissions   :\t%.2f \n",($packetflow{$type}{nec}{sends}*$fac));
+    printf("\t   Nec. Traffic         :\t%.2f $unit\n",($packetflow{$type}{nec}{bw}*$bwfac));
+    printf("\t   Red. Transmissions   :\t%.2f \n",($packetflow{$type}{red}{sends}*$fac));
+    printf("\t   Red. Traffic         :\t%.2f $unit\n",($packetflow{$type}{red}{bw}*$bwfac));
+    printf("\n");
+    printf("\tTotal Targets           :\t%.2f \n",$packetflow{$type}{flows}*$fac);
+    printf("\tTotal Load Transmissions:\t%.2f \n",($packetflow{$type}{sends}*$fac));
+    printf("\tTotal Load Traffic      :\t%.2f $unit\n",($packetflow{$type}{bw}*$bwfac));
+    printf("\n");
+  }
+
+}
+
+#################################
+#
+# Latency
+#
+sub printLatency {
+
+  printf("Data Delivery Latency:\n\n");
+  foreach my $type (keys %latency) {
+    printf("\tAvg Hop Latency ($type)    \t: %.7f secs\n",$latency{$type}{shop}/$noFiles);
+    printf("\tAvg Pkt Latency ($type)    \t: %.7f secs\n",$latency{$type}{avg}/$noFiles);
+    if (exists $latency{$type}{fp}) {
+      printf("\tAvg 1st Pkt Latency ($type)\t: %.7f secs\n",$latency{$type}{fp}/$noFiles);
+    }
+  }
+  printf("\n");
+}
+
+sub evalLatency {
+
+  foreach my $type (keys %PKT) {
+    my ($avg,$avg_cnt) = (0,0);
+    my ($shop,$shop_cnt) = (0,0);
+    my ($rlen,$rlen_cnt) = (0,0);
+
+    if ($latency_analysis == 1) { print "$type:\n"; }
+
+    foreach my $flowid (keys %{$PKT{$type}}) {
+
+      if ($PKT{$type}{$flowid}{reached} == 1) {
+
+	my $lat = $PKT{$type}{$flowid}{end} - $PKT{$type}{$flowid}{start};
+
+	if ($type eq $PINGTYPE[0]) {
+	  incrQuantHash(\%latency_spectrum, $lat, 1);
+	}
+
+	$avg += $lat; $avg_cnt++;
+
+	my $len = ($PKT{$type}{$flowid}{startTTL} - $PKT{$type}{$flowid}{endTTL});
+	if ($len != 0) {
+	  $shop += $lat / $len; $shop_cnt++;
+	}
+
+	## for now we'll update the old route length vals
+	$rlen += $len; $rlen_cnt++;
+
+	if ($latency_analysis == 1) {
+	  printf (" $PKT{$type}{$flowid}{end} - $PKT{$type}{$flowid}{start} / $PKT{$type}{$flowid}{endTTL} - $PKT{$type}{$flowid}{startTTL} evals to %.2f\n", $lat/$len);
+	}
+
+      }
+    }
+    if ($avg_cnt != 0) {
+      $latency{$type}{avg} += $avg/$avg_cnt;
+    }
+    if ($shop_cnt != 0) {
+      $latency{$type}{shop} += $shop/$shop_cnt;
+    }
+  }
+
+  my ($fp,$fp_cnt) = (0,0);
+  foreach my $key (keys %LAT) {
+    $fp += $LAT{$key}{end} - $LAT{$key}{start};
+    $fp_cnt++;
+  }
+  if ($fp_cnt != 0) {
+    $latency{$PINGTYPE[0]}{fp} += $fp/$fp_cnt;
+  }
+}
+
+sub printLatencySpectrum {
+
+  print "Ping Latency Spectrum (Quantization: $quant_step):\n\n";
+  foreach my $delay (sort keys %latency_spectrum) {
+    if ($delay eq "valid") { next; }
+    printf("\t$delay\t: %.2f\n",$latency_spectrum{$delay}/$noFiles);
+  }
+  print "\n";
+}
+
+#################################
+#
+# MAC Collisions
+#
+sub printCollisions {
+
+  if ($collisions{valid}) {
+    printf("MAC Collision Statistics:\n\n");
+
+    printf("\tMAC Collisions\t: %.2f\n",$collisions{cols}/$noFiles);
+    foreach my $type (sort keys %collisions) {
+      if (($type eq "valid") || ($type eq "cols")) { next; }
+      printf("\t$type\t: %.2f %\n",calcPercent($collisions{cols},$collisions{$type}));
+    }
+    printf("\n");
+  }
+}
+
+#################################
+#
+# CBF Specials
+#
+sub printAreaUsage {
+
+  if ($areausage{valid}) {
+
+    printf("CBF Area Usage:\n\n");
+    printf("\tCounted Sends  :\t%.2f\n",$areausage{sends}/$noFiles);
+    foreach my $area (sort keys %{$areausage{usage}}) {
+      printf("\t  Usage Area $area :\t%.2f %\n",calcPercent($areausage{sends},$areausage{usage}{$area}));
+    }
+    printf("\n");
+  }
+}
+
+sub printDuplication {
+
+  printf("Ping Duplication Information:\n\n");
+  printf("\tDuplicates/Run    :\t%.2f\n",($duplicates{recv}-$duplicates{sent})/$noFiles);
+  if ($duplicates{sent} != 0) {
+    printf("\tAvg Dupes/Pkt     :\t%.2f\n",($duplicates{recv}-$duplicates{sent})/$duplicates{sent});
+  }
+  printf("\n");
+
+}
+
+#################################
+#
+# LOCS Specials
+#
+sub printUpdateReasons {
+
+  if ($gls_update{valid} == 1) {
+    print "Update Packets (Reason Keyed):\n\n";
+    foreach my $reason (sort keys %gls_update) {
+      if ($reason eq "valid") { next; }
+      printf("\t$reason\t: %.2f\n",$gls_update{$reason}/$noFiles);
+      print "\n";
+    }
+  }
+}
+
+#################################
+#
+# Useful Functions / Generics
+#
+sub calcPercent {
+  my $total = shift();
+  my $fraction = shift();
+  my $rate;
+
+  if($total > 0){
+    $rate = ($fraction*100)/$total;
+  }else{
+    $rate = 0;
+  }
+
+  return $rate;
+}
+
+sub incrQuantHash {
+  my $hRef = shift();
+  my $hKey = shift();
+  my $incrValue = shift();
+
+  # Quantize Key
+  #print "got key: $hKey ->";
+  my $index = $quant_step;
+  for ($index = $quant_step; ($hKey / $index) >= 1; $index += $quant_step) {}
+  $hKey = $index - $quant_step;
+  #print " selected bucket: $hKey\n";
+
+  if (exists $hRef->{$hKey}){
+    $hRef->{$hKey} += $incrValue;
+    #print " $hKey : $hRef->{$hKey}\n";
+  }else{
+    $hRef->{$hKey} = $incrValue;
+  }
+}
+
+sub incrHash {
+  my $hRef = shift();
+  my $hKey = shift();
+  my $incrValue = shift();
+  if (ref($hRef) ne 'HASH'){
+    die "expected a Hash-Ref!\n";
+  }
+  if (exists $hRef->{$hKey}){
+    $hRef->{$hKey} += $incrValue;
+  }else{
+    $hRef->{$hKey} = $incrValue;
+  }
+}
+
+sub padHash {
+  my $hRef = shift();
+  my $step = shift();
+  my $biggest = 0;
+
+  foreach my $k (sort keys %$hRef){
+    if ($k > $biggest) {
+      $biggest = $k;
+    }
+  }
+
+  for (my $i = 0; $i < $biggest; $i += $step) {
+    if (not exists $hRef->{$i}){
+      $hRef->{$i} = 0;
+    }
+  }
+}
+
+
+#################################
+#
+# Usage
+#
+sub usage {
+  print "\nUsage: evaluate.pl [Options] -f files\n\n";
+  print "  Options are:\n\n";
+  print "  -tag/-t [String]   - Identifer tag for .lat and .dat files\n";
+  print "  -quant/-q [Value]  - Quantization step size for latency spectrum\n";
+  print "  -help/-h           - Display this usage message\n";
+  print "  -dat/-d            - Write/Append dat file X.dat\n";
+  print "                       (X is TAG or the ROUTING protocol read from the file/s)\n";
+  print "  -lat/-l            - Write Latency Spectrum to lat file X-NN-SP.lat\n";
+  print "                       (X is TAG or the ROUTING protocol read from the file/s)\n";
+  print "                       (NN is the number of nodes as read from the file/s)\n";
+  print "                       (SP is the max movement speed as read from the file/s)\n";
+  print "  -latana/-la        - Show details of single hop latency calculation\n";
+  print "  -missana/-ma       - Activate packet analysis (Parses only the first file)\n";
+  print "  -genrte/-rte       - Generate Route Files for Traces that don't have 'em yet\n";
+  print "\n";
+  exit;
+}
+
+#################################
+#
+# Command Line Parsing
+#
+sub parseCmdLine {
+
+  for (my $i = 0; $i <= $#ARGV; $i++) {
+
+    if ((($ARGV[$i] eq "-tag") || ($ARGV[$i] eq "-t")) &&
+	($ARGV[$i+1] !~ /^-/o) && ($ARGV[$i+1] ne "")) 
+      {
+	$filemark = $ARGV[$i+1];
+	$i++;
+	next;
+      }
+
+    if ((($ARGV[$i] eq "-quant") || ($ARGV[$i] eq "-q")) &&
+	($ARGV[$i+1] !~ /^-/o) && ($ARGV[$i+1] ne "")) 
+      {
+	if (($ARGV[$i+1] =~ /\d+.\d+/o) || ($ARGV[$i+1] =~ /\d+/o)) {
+	  $quant_step = $ARGV[$i+1];
+	  $i++;
+	}
+	next;
+      }
+
+    if (($ARGV[$i] eq "-files") || ($ARGV[$i] eq "-f")) {
+      while (($ARGV[$i+1] !~ /^-/o) && ($ARGV[$i+1] ne "")) {
+	$filelist[$noFiles] = $ARGV[$i+1];
+	$noFiles++;
+	$i++;
+      }
+      next;
+    }
+
+    if (($ARGV[$i] eq "-help") || ($ARGV[$i] eq "-h")) { usage(); exit; }
+    if (($ARGV[$i] eq "-dat") || ($ARGV[$i] eq "-d")) { $bDatfile = 1; next; }
+    if (($ARGV[$i] eq "-lat") || ($ARGV[$i] eq "-l")) { $bLatfile = 1; next; }
+    if (($ARGV[$i] eq "-missana") || ($ARGV[$i] eq "-ma")) { $miss_analysis = 1; next; }
+    if (($ARGV[$i] eq "-latana") || ($ARGV[$i] eq "-la")) { $latency_analysis = 1; next; }
+    if (($ARGV[$i] eq "-genrte") || ($ARGV[$i] eq "-rte")) { $gen_rte = 1; next; }
+  }
+}
+
+#################################
+#
+# File I/O
+#
+sub writeStatistics {
+
+  if ($filemark eq "") { $filemark = "$routing"; }
+
+  my $proto = lc($filemark);
+
+  if ($bLatfile == 1) {
+    my $specfile = "$proto-$nn-$speed{max}.lat";
+    open(LATSPEC, "> $specfile") or die "\tCan not open $specfile\n";
+    foreach my $k (sort keys %latency_spectrum){
+      printf(LATSPEC "$k %.2f\n",$latency_spectrum{$k}/$noFiles);
+    }
+    close(LATSPEC);
+  }
+
+  # Direct-to-File Output should be rwritten someday
+
+  #if ($bDatfile == 1) {
+  #  my $datfile = "$proto.dat";
+  #  open(OUT, ">> $datfile") or die "\tCan not open $datfile\n";
+  #  # NN SP PDEL EDEL PHLAT EHLAT PALAT EALAT FPLAT BO ABW PRLEN ERLEN NRTEREC
+  #  # 
+  #  close(OUT);
+  #}
+}
+
+#################################
+#
+# Header / Structuring
+#
+sub printSpeed {
+
+  if ($speed{cnt} != 0) {
+    $speed{avg} /= $speed{cnt};
+  }
+  my $s = 0;
+  for (my $j = $#SPEEDS; $j >= 0; $j--) {
+    if ($speed{max} <= $SPEEDS[$j]) {
+      $s = $SPEEDS[$j];
+    }
+  }
+  $speed{max} = $s;
+
+  printf ("Nodes moved at max. %i m/s (Average: %7.3f m/s)\n",$speed{max},$speed{avg});
+}
+
+sub printStatistics {
+
+  print "\nStatistics:\n";
+  print "----------\n";
+  print "$noFiles $routing Runs evaluated ($mac)\n";
+  printf ("%i Nodes in an Area of %ix%i sqm for %7.3f secs\n",$nn, $x, $y, $duration);
+  printSpeed();
+  print "----------\n\n";
+
+  #wk
+  printHLS();
+  #end wk
+  printDelivery();
+  printPktStats();
+  printDrops();
+  printReachability();
+  printBW();
+  printPacketFlows();
+  printLatency();
+  #printCollisions();
+
+  # Specials
+  printAreaUsage();
+  printDuplication();
+  printUpdateReasons();
+
+  # Enduring Plots
+  printLatencySpectrum();
+  if ($miss_analysis == 1) { printDeliveryCount(); }
+}
diff -u -r --new-file ./hls/utils/evFromdirectory.pl ../../ns-2.33-hls_working/ns-2.33/hls/utils/evFromdirectory.pl
--- ./hls/utils/evFromdirectory.pl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/evFromdirectory.pl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,164 @@
+#!/usr/bin/perl
+use strict;
+
+my $locs      = "3";
+my $mode      = "";
+my $nohup     = "";
+my $recursive = "false";
+
+##############
+# main program
+##############
+parseCmdLine();
+if($mode eq "") {
+    printHelp();
+    exit;
+}
+print "test all\n";
+if($recursive eq "true") {
+    print "recursive\n";
+    opendir(DIRECTORY, '.');
+    my @entries = readdir(DIRECTORY);
+    foreach my $entry (@entries) {
+	if(( -d $entry) && (!($entry =~ /\.+/o)) && ($entry =~ /\d+-\d{2}/o) &&
+	   (!($entry =~ /\d+-\d{2}-/o))) { # last one necessary because I'm too stupid to exclude those with trailing "-" in the third regexp
+	    # select all directories which are != "." or ".."
+	    print "processing $entry ...\n";
+	    if($mode eq "entire") {
+		processEntireDirectory($entry);
+	    }
+	    if ($mode eq "single") {
+		processSingleDirectories($entry);
+	    }
+	} else {
+	    #print "Don't process $entry\n";
+	}
+    }
+} else {
+    print "non-recursive\n";
+    if($mode eq "entire") {
+	processEntireDirectory(".");
+    }
+    if ($mode eq "single") {
+	processSingleDirectories(".");
+    }
+}
+    
+
+
+
+# generates for each tracefile an evaluation file
+sub processSingleDirectories {
+    my $entry = shift();
+    chdir $entry;
+
+    opendir(WORKING_DIRECTORY, '.');
+
+    my @dirs = readdir(WORKING_DIRECTORY);
+    foreach my $dir (@dirs) {
+	if(( -d $dir) && (!($dir =~ /\.+/o))) {
+#	    print "$dir\n";
+	    #opendir(ACTUAL_DIRECTORY, '$dir');
+	    
+	    chdir $dir;
+	    
+	    if($locs eq "3") {
+		if(containsEnoughQueries("hls_evaluated_auto", 1200) eq "false") {
+		    my $command = "$nohup evaluate.pl -f hls_trace* > hls_evaluated_auto";
+		    print "execute in $dir : $command\n";
+		    system($command);
+		} else {
+		    print "$dir contained enough queries\n";
+		}
+	    } else {		
+		if(containsEnoughQueries("gls_evaluated_auto", 1200)  eq "false") {
+		    my $command = "$nohup gls_evaluate.pl -f gls_trace* > gls_evaluated_auto";
+		    print "execute  in $dir : $command\n";
+		    system("$command");
+		} else {
+		    print "$dir contained enough queries\n";
+		}
+	    }
+	    chdir "..";	    
+	}
+    }
+
+    chdir "..";
+}
+
+
+# generates one big evaluation file
+sub processEntireDirectory {
+    my $entry = shift();
+    chdir $entry;
+
+    opendir(WORKING_DIRECTORY, '.');
+    print "$entry\n";
+    if($locs eq "3") {
+	my $command = "$nohup evaluate.pl -f */hls_trace* > hls_evaluated_auto";
+	print "execute $command\n";
+	system($command);
+    } else {
+	my $command = "$nohup gls_evaluate.pl -f */gls_trace* > gls_evaluated_auto";
+	print "execute $command\n";
+	system($command);
+    }	    
+
+    chdir "..";
+}
+
+
+##### helper functions
+# input : filename, nr of queries
+# parses the file and returns true if the file contains a line with
+# "Queries : $queries" where the latter is the input
+sub containsEnoughQueries {
+    my $filename = shift();
+    my $queries_necessary = shift();
+    open(FILE, "$filename");
+    my $queries = 0;
+    while (my $line = <FILE>) {
+	if($line =~ /Queries         : (\d+)/o){
+	    $queries = $1;
+	}
+    }
+    if($queries_necessary == $queries) {
+	return "true";
+    } else {
+	return "false";
+    }
+}
+
+
+sub parseCmdLine {
+  for (my $i = 0; $i <= $#ARGV; $i++) {
+      if ($ARGV[$i] eq "-gls") {
+	  $locs = "2";
+      }
+      if ($ARGV[$i] eq "-help") {
+	  printHelp();
+	  exit;
+      }  
+      if ($ARGV[$i] eq "-mode") {
+	  $mode      = $ARGV[$i+1];
+	  $i++;
+	  next;
+      }
+      if ($ARGV[$i] eq "-nohup") {
+	  $nohup = "nohup";
+      }          
+      if ($ARGV[$i] eq "-r") {
+	  $recursive = "true";
+      }  
+  }
+}
+
+
+sub printHelp {
+
+    print "This script is designed to evaluate.pl recursively\n";
+    print "-gls    : launch GLS evaluation (DEFAULT : HLS)\n";
+    print "-mode   : entire: one big evaluate file; single: one eval file for each trace\n";
+    print "-nohup  : nohup\n";
+    print "-r      : recursive (DEFAULT :false)\n";
+}
diff -u -r --new-file ./hls/utils/gls_evaluate.pl ../../ns-2.33-hls_working/ns-2.33/hls/utils/gls_evaluate.pl
--- ./hls/utils/gls_evaluate.pl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/gls_evaluate.pl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,1483 @@
+#!/usr/bin/perl
+# -*- cperl -*-
+# $Id: gls_evaluate.pl,v 1.3 2003/01/29 18:41:05 kiess Exp $
+
+use strict;
+
+# Switches - to check
+my $miss_analysis = 0;
+my $latency_analysis = 0;
+my $bDatfile = 0;
+my $bLatfile = 0;
+my $noFiles = 0;
+my $filemark = "";
+my @filelist = ();
+my $quant_step = 0.25; # Quantization step size for latency spectrum
+
+my $gen_rte = 0; # Generate RTE Files only
+my $write_file;
+my $actfile = "";
+my $processed = 0;
+
+#################################
+#
+# Intermediate Hashes
+#
+my %PKT = ();
+my %LAT = ();
+my %LOOKUP = ();
+
+#################################
+#
+# Compatibility
+#
+my $simulator_eval = 0;
+my %COMPAT = ();
+
+#################################
+#
+# Data Hashes
+#
+my %speed = ('max' => 0, 'avg' => 0, 'cnt' => 0);
+my %duplicates = ('sent' => 0, 'recv' => 0);
+my %collisions = ('valid' => 0, 'cols' => 0);
+my %areausage = ('valid' => 0, 'sends' => 0, 'usage' => ());
+my %packetflow = ();
+my %reachability = ();
+my %delivery = ();
+my %drops = ();
+my %bw = ();
+my %stats = ();
+my %latency = ();
+my %latency_spectrum = ();
+my %gls_update = ();
+my %delivery_count = ();
+
+# wk stuff
+my %query_distance = ( 'max' => 0 , 'numberOfEntries' => 0);
+my %cl_deviation   = ( 'max' => 0 , 'numberOfEntries' => 0);
+my $query_distance_quant_step = 250;
+my %lookup =('queries' => 0, 'cache_lookups' => 0, 'request_send' => 0, 
+	     'reply_receive' => 0, 'request_drop' => 0, 'reply_drop' => 0, 'ifq_drop' => 0);
+# the following two variables contain the position of a node when a test query 
+# is launchend (that value is from GOD). If GLS does a cache lookup, we can 
+# determine the deviation
+my $dstx; 
+my $dsty;
+my $target_node;
+
+my %cache_statistic = ('maxage' => 0,'minage' => 0,'totalage' => 0);
+my $query_distance_quant_step = 250;
+my $deviation_quant_step = 50;
+
+my %query_list = (); # stores the send time of a query
+my %request_time_hash = ();
+my %reply_duplicate_list = ();
+my %reply_statistic = ('maxage' => 0,'minage' => 0,'totalage' => 0);
+
+#################################
+#
+# Data Variables
+#
+my $duration = 1; # Init value determines lowest runtime
+my ($nn, $x, $y) = (0,0,0);
+my $routing = "NONE";
+my $mac = "NONE";
+
+#################################
+#
+# Lookup Tables
+#
+my @LOCSTYPE = ("QUERY ", "REPLY ", "DATA  ", "UPDATE", "UPDACK", "BEACON", "BCNREQ");
+my @GPSRTYPE = ("GREEDY", "PERI  ", "PROBE ", "BEACON", "BCNREQ");
+my @CBFTYPE  = ("DATA  ", "RCPT  ", "RTF   ", "CTF   ", "REC   ", "ACT   ");
+my @DSRTYPE  = ("RTREQ ", "RTRPLY", "RTERR ", "RTRQER", "RTRPER");
+my @PINGTYPE = ("Ping", "Echo", "TOTAL ");
+my @SPEEDS   = (0,10,30,50);
+
+#################################
+#
+# Main
+#
+parseCmdLine();
+if ($noFiles == 0){ usage(); }else{
+
+  #
+  # Setup
+  #
+  printf ("Parser started for %i Files\n",$noFiles);
+
+  for (my $i = 0; $i < $noFiles; $i++){
+
+    if (($miss_analysis == 1) && ($i >= 1)) { last; }
+
+    $actfile = $filelist[$i];
+    print "Processing file $actfile...";
+
+    # Reset Intermediate Hashes
+    %PKT = (); %LAT = (); %LOOKUP = ();
+    %COMPAT = ();
+    # wk stuff
+    %reply_duplicate_list = ();
+    %query_list = ();
+    $simulator_eval = 0;
+
+    # Generate RTE File
+    my $write_file = 0;
+
+    if ($gen_rte) {
+      my $basename = $actfile;
+      $basename =~ s/\.gz//;
+      $basename =~ s/\.rte//;
+      $basename = "$basename.rte";
+      if (-e $basename) { 
+	print "(rte exists) ";
+      }else{
+	print "(rte create) ";
+	$write_file = open(RTEFILE, ">$basename");
+	print RTEFILE "# This is the mangled route file for $actfile\n";
+      }
+    }
+
+    # Zip or no zip
+    my $zipped = 0;
+    if ($actfile =~ /\.gz$/){
+      $zipped = 1;
+      if (not open(FILE, "zcat $actfile |")) { print " not found\n"; next; }
+      else{ print " found\n"; }
+    }elsif ($actfile =~ /\.bz$/){
+      $zipped = 2;
+      if (not open(FILE, "bzcat $actfile |")) { print " not found\n"; next; }
+      else{ print " found\n"; }
+    }else{
+      if (not open(FILE, "< $actfile")) { print " not found\n"; next; }
+      else{ print " found\n"; }
+    }
+
+    print "Parsing";
+    my $filesize = (stat($actfile))[7];
+
+    $processed++;
+
+    my $parsedsize = 0;
+    my $step = 0;
+    if ($zipped) { $step = 0.9 * $filesize; }
+    else { $step = 0.1 * $filesize; }
+    my $mark = $step;
+
+    #
+    # Parse through Tracefile
+    #
+    while (my $line = <FILE>) {
+
+      # Progress Indicator
+      if ($parsedsize >= $mark) {
+	print ".";
+	$mark += $step;
+      }
+      $parsedsize += length($line);
+
+      next if $line =~ /^V/o;
+
+      # Parameter
+      if ($line =~ /^M \d+.\d+ nn (\d+) x (\d+) y (\d+) rp (\S+)/o) {
+	$nn += $1/$noFiles; $x += $2/$noFiles; $y += $3/$noFiles; $routing = $4;
+	next;
+      }
+      if ($line =~ /^M \d+.\d+ prop.*mac (\S+)/o) {
+	$mac = $1;
+	next;
+      }
+
+      # Speeds
+      if ($line =~ /^M \d+.\d+ \d+ \(\d+.\d+, \d+.\d+, \d+.\d+\), \(\d+.\d+, \d+.\d+\), (\d+.\d+)/o) {
+	if ($1 > $speed{max}) {
+	  $speed{max} = $1;
+	}
+	$speed{avg} += $1;
+	$speed{cnt}++;
+	next;
+      }
+
+      # Route Information
+      if($line =~ /^CBFDBG: (\d+.\d+) _(\S+)_: RouteInfo (\d+) \((\d+)->(\d+)\) : (\d+) (\d+)/o) {
+	my $time = $1; my $node = $2;
+	my $pkt_uid  = $3;
+	my $pkt_src  = $4;
+	my $pkt_dst  = $5;
+	my $taken    = $6;
+	my $shortest = $7;
+
+	$LOOKUP{$pkt_uid}->{taken} = $taken;
+	$LOOKUP{$pkt_uid}->{shortest} = $shortest;
+      }
+
+      # Simulator Evaluation
+      if ($line =~ /^## (\S+): (\d+) (\d+) (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)/o) {
+	my ($protocol, $mactrans, $mactraf) = ($1,$2,$3);
+	my @area = ($4,$5,$6);
+	my ($shortest, $greedy, $drops) = ($7,$8,$9);
+
+	# Remember the comment
+	$simulator_eval = 1;
+
+	# Bandwidth Consumption
+	$bw{MAC}{$protocol}->{cnt} += $mactrans;
+	$bw{MAC}{$protocol}->{bw} += $mactraf;
+	$bw{MAC}->{cnt} += $mactrans;
+	$bw{MAC}->{bw} += $mactraf;
+
+	# Area Information 
+	if ($protocol eq "Ping") {
+	  my $sends = 0;
+	  for (my $i=0; $i < 3; $i++) {
+	    $areausage{usage}{$i} += $area[$i];
+	    $sends += $area[$i];
+	  }
+	  $areausage{sends} += $sends;
+	  $areausage{valid} = 1;
+	}
+
+	# Connectivity
+	if (($protocol eq "Ping") || ($protocol eq "Echo")) {
+	  $reachability{$protocol}{drops} += $drops;
+	  $reachability{$protocol}{shortest} += $shortest;
+	  $reachability{$protocol}{greedy} += $greedy;
+	}
+
+      }
+
+      # wk : gls performance evaluation
+      #HLS result parsing wk
+      if($line =~ /^TESTQ (\d+\.\d+) (\d+) \((\d+\.\d+) (\d+\.\d+)\) (\d+) \((\d+\.\d+) (\d+\.\d+)\)/o) {
+	$lookup{queries}++;
+	my $actual_time = $1;
+	my $source_node = $2;
+	my $srcx = $3;
+	my $srcy = $4;
+	$target_node = $5;
+	$dstx = $6;
+	$dsty = $7;
+	#print "$srcx, $srcy, $dstx, $dsty   +++ ";
+	#print distance($srcx, $srcy, $dstx, $dsty)."\n";
+	incrDistanceHash(\%query_distance, distance($srcx, $srcy, $dstx, $dsty),
+			 $query_distance_quant_step);
+      }
+
+      if($line =~ /LSIIC: (\d+.\d+) _(\d+)_ \[(\d+) (\d+.\d+) (\d+.\d+) (\d+.\d+)\]/o) {
+	#print "LSIIC match\n";
+	$lookup{cache_lookups}++;
+	my $actual_time = $1;
+	my $node_id = $2;
+	my $node = $3;
+	if($node != $target_node) {
+	  print "\n";
+	  print "#########################error, wrong node######################\n";
+	  print "\n";
+	}
+	  
+	my $cache_entry_timestamp = $4;
+	my $x = $5;
+	my $y = $6;
+	# now start calculating
+	my $deviation = distance($x, $y, $dstx, $dsty);
+
+	my $age = $actual_time - $cache_entry_timestamp;
+	if($cache_statistic{maxage} <= $age){
+	  $cache_statistic{maxage} = $age
+	}
+	if($cache_statistic{minage} >= $age){
+	  $cache_statistic{minage} = $age
+	}
+	$cache_statistic{totalage} += $age;
+	# deviation
+	incrDistanceHash(\%cl_deviation, $deviation,
+			 $deviation_quant_step);
+
+	}
+
+      if($line =~ /LSRR: (\d+.\d+) _(\d+)_ \((\d+)->(\d+)\)/o) {
+#	print $line;
+	
+	my $actual_time = $1;
+	my $reply_receiver = $4;
+	my $reply_sender = $3;
+	#print "$reply_sender->$reply_receiver\n";
+	
+	my $key = "$reply_receiver - $reply_sender";
+	my $overall_time = $actual_time - $query_list{$key};
+	#print "$overall_time\n";
+
+	if(!(exists $reply_duplicate_list{$key})) {
+	  $lookup{reply_receive}++;
+	  incrQuantHash(\%request_time_hash, $overall_time, 1);
+	  $reply_duplicate_list{$key} = 1;
+	}
+      }
+
+      # parse the receiving of a reply packet at the request sender =>
+      # the age is in the packet and can be determined
+      if($line =~ /r (\d+.\d+) _(\d+)_ RTR  --- \d+ LOCS .* ------- \[(\d+):255 (\d+):255 \d+ \d+\] (\d+) \[(\d+) (\d+.\d+).*\]->\[(\d+) (\d+.\d+)/o) {
+	my $actual_time = $1;
+	my $actual_node = $2;
+	my $sender      = $3;
+	my $target      = $4;
+	my $pkt_type    = $5;
+	# $6 is once again the sender
+	my $sender_timestamp = $7;
+	# $8 is the target 
+	my $target_last_position_timestamp = $9;
+	if(($actual_node == $target) &&
+	   ($pkt_type == 2)
+	  ) {
+	  # it's a reply packet arriving at it's target
+	  my $age = $actual_time - $sender_timestamp;
+	  
+	  #print "stt: $sender_target_travel_time \n";
+	  if($reply_statistic{maxage} <= $age){
+	    $reply_statistic{maxage} = $age
+	  }
+	  if($reply_statistic{minage} >= $age){
+	    $reply_statistic{minage} = $age
+	  }
+	  $reply_statistic{totalage} += $age;
+	}
+      }
+      
+      if($line =~ /LSSRC: (\d+.\d+) _(\d+)_ \((\d+)->(\d+)\)/o) {
+	$lookup{request_send}++;
+	my $actual_time = $1;
+	my $request_receiver = $4;
+	my $request_sender = $3;
+	#print "$reply_sender->$reply_receiver\n";
+	
+	my $key = "$request_sender - $request_receiver";
+	$query_list{$key} = $actual_time;
+      }
+
+
+      # GLS Update Packets need their arrival checked (for now)
+      if($line =~ /^LSCLS: (\d+.\d+) _(\d+)_/o) {
+	$stats{LOCS}{$LOCSTYPE[3]}{recv}++; 
+	next;
+      }
+
+      # MAC Collision Analysis
+      if (($line =~ /^MACDBG: \d+.\d+ _\d+_: COL (\S+) (\S+) (\d+) <-> (\S+) (\S+) (\d+)/o) ||
+	  ($line =~ /^MACCOL (\S+) (\S+) (\d+) <-> (\S+) (\S+) (\d+)/o) )
+	{
+	my ($ptype1, $psub1, $puid1, $ptype2, $psub2, $puid2) = ($1,$2,$3,$4,$5,$6);
+	my ($cause1, $cause2);
+
+	if ($psub1 == -1) { $cause1 = $ptype1; }
+	else {
+	  if (uc($ptype1) eq "CBF") { $cause1 = $CBFTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "GPSR") { $cause1 = $GPSRTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "LOCS") { $cause1 = $LOCSTYPE[$psub1]; }
+	  elsif (uc($ptype1) eq "PING") { $cause1 = $PINGTYPE[$psub1]; }
+	  else { $cause1 = "UK/$ptype1"; }
+	}
+	if ($psub2 == -1) { $cause2 = $ptype2; }
+	else {
+	  if (uc($ptype2) eq "CBF") { $cause2 = $CBFTYPE[$psub2]; }
+	  elsif (uc($ptype2) eq "GPSR") { $cause2 = $GPSRTYPE[$psub2]; }
+	  elsif (uc($ptype2) eq "LOCS") { $cause2 = $LOCSTYPE[$psub2]; }
+	  elsif (uc($ptype2) eq "PING") { $cause2 = $PINGTYPE[$psub2]; }
+	  else { $cause2 = "UK/$ptype2"; }
+	}
+	my $reverse = 0;
+	if (exists $collisions{"$cause2<->$cause1"}) {
+	  $collisions{"$cause2<->$cause1"}++;
+	  $collisions{cols}++;
+	  $collisions{valid} = 1;
+	}else{
+	  $collisions{"$cause1<->$cause2"}++;
+	  $collisions{cols}++;
+	  $collisions{valid} = 1;
+	}
+      }
+
+      # Backwards Compatibility
+      if($line =~ /^([sf]) \d+.\d+ _\d+_ (\w+)\s+\S+ \d+ (\S+) (\d+).*/o) {
+	my ($op,$layer,$protocol,$size) = ($1,$2,$3,$4);
+
+	if ($layer eq "MAC") {
+	  $COMPAT{bw}{$layer}{$protocol}->{cnt} += 1;
+	  $COMPAT{bw}{$layer}{$protocol}->{bw} += $size;
+	}
+      }
+      if($line =~ /^[srfD] \d+.\d+ _\d+_ (\w+)\s+\S+ (\d+) (\S+) \d+ \[.*- \[.*\] \d+ \[(\d+)\] \d+.\d+/o) {
+	my ($layer,$uid,$protocol,$type) = ($1,$2,$3,$4);
+
+	if (($layer eq "AGT") && ($protocol eq "Ping") && ($type == 0))
+	  { $COMPAT{lookup}{$uid}{ping} = 1; }
+      }
+      if (($line =~ /^CBFDBG: (\d+.\d+) _(\S+)_: Sending (\d+) to Area (\d+)/o) ||
+	  ($line =~ /^CBFDBG: (\d+.\d+) _(\S+)_: Sent ACT \d+ for (\d+) to Area (\d+)/o))
+	{
+	  my ($time,$node,$uid,$area) = ($1,$2,$3,$4);
+
+	  if (exists $COMPAT{lookup}{$uid}->{ping}) {
+	    $COMPAT{area}{usage}{$area}++;
+	    $COMPAT{area}{sends}++;
+	    $COMPAT{area}{valid} = 1;
+	  }
+	}
+
+      # Line analysis
+      if($line =~ /^([srfD]) (\d+.\d+) _(\d+)_ (\w+)\s+(\S+) (\d+) (\S+) (\d+) \[\w+ \w+ (\w+).*- \[(\S+):\d+ (\S+):\d+ (\d+) (\S+)\] (.*)/o) {
+	my $op           = $1;
+	my $time         = $2;
+	my $node         = $3;
+	my $layer        = $4;
+	my $drop_rsn     = $5;
+	my $pkt_uid      = $6;
+	my $protocol     = $7;
+	my $pkt_size     = $8;
+	my $fromhex      = $9;
+	my $from         = hex($9);
+	my $pkt_src      = $10;
+	my $pkt_dst      = $11;
+	my $pkt_ttl      = $12;
+	my $pkt_nhop     = $13;
+	my $subline      = $14;
+
+	# Update Timestamp
+	if ($time > $duration) {
+	  $duration = $time;
+	}
+
+	# Measure Bandwidth Consumption
+	if ((($layer eq "RTR")||($layer eq "AGT")) &&
+	    (($op eq 's') || ($op eq 'f'))) {
+	  if ($protocol ne "Ping") {
+	    $bw{$layer}->{cnt} += 1;
+	    $bw{$layer}->{bw} += $pkt_size;
+	    $bw{$layer}{$protocol}->{cnt} += 1;
+	    $bw{$layer}{$protocol}->{bw} += $pkt_size;
+	  }
+	}
+
+	if (($protocol eq "LOCS") && 
+	    ($subline =~ /^(\d+) \[(\S+).*\]->\[(\S+).*\] : (\d+) (\d+) : (\w+) (\d+) \d+ \[.*\[.*\[(\S+)/o)) {
+	  my $pkt_type     = $1-1;
+	  my $locs_src     = $2;
+	  my $locs_dst     = $3;
+	  my $locs_seqno   = $4;
+	  my $locs_maxhop  = $5;
+	  my $locs_updrsn  = $6;
+	  my $locs_cbk     = $7;
+	  my $locs_nxt     = $8;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$LOCSTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 's') {
+	    # GLS Update Reason
+	    if ($LOCSTYPE[$pkt_type] eq "UPDATE"){
+	      $gls_update{$locs_updrsn}++;
+	      $gls_update{valid} = 1;
+	    }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$LOCSTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	if (($protocol eq "DSR") &&
+	    ($subline =~ /^\d+ \[(\d+) (\d+)\] \[(\d+) \d+ \d+ (\d+)->(\d+)\] \[(\d+) \d+ (\d+) (\d+)->(\d+)\]/o)) {
+	  my $dsr_rreq       = $1;
+	  my $dsr_seqno      = $2;
+	  my $dsr_rrepl      = $3;
+	  my $dsr_rrepl_dst  = $4;
+	  my $dsr_rrepl_src  = $5;
+	  my $dsr_rerr       = $6;
+	  my $dsr_rerr_dst   = $7;
+	  my $dsr_rerr_blink = $8;
+
+	  # Packet Statistics
+	  my $pkt_type = 0;
+	  if (($dsr_rreq == 1) && ($dsr_rerr == 1)) { $pkt_type = 3; }
+	  elsif (($dsr_rrepl == 1) && ($dsr_rerr == 1)) { $pkt_type = 4; }
+	  elsif ($dsr_rreq == 1) { $pkt_type = 0; }
+	  elsif ($dsr_rrepl == 1) { $pkt_type = 1; }
+	  elsif ($dsr_rerr == 1) { $pkt_type = 2; }
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$DSRTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    if ($dsr_rreq == 1)  { $drops{$reason}{$DSRTYPE[0]}++; }
+	    if ($dsr_rrepl == 1) { $drops{$reason}{$DSRTYPE[1]}++; }
+	    if ($dsr_rerr == 1)  { $drops{$reason}{$DSRTYPE[2]}++; }
+	  }
+	  next;
+	}
+
+	if (($protocol eq "GPSR") && 
+	    ($subline =~ /^(\d+) \d+ \[\S+ \S+\]/o)) {
+	  my $pkt_type     = $1;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$GPSRTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$GPSRTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	if (($protocol eq "CBF") && 
+	    ($subline =~ /^(\d+) \[(\d+)\] \[(\S+) (\S+) (\S+)\] \[.*\]->\[.*\] \[.*\]/o)) {
+	  my $pkt_type     = $1;
+	  my $cbf_retries  = $2;
+	  my $cbf_pid      = $3;
+	  my $cbf_area     = $4;
+	  my $cbf_sid      = $5;
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$CBFTYPE[$pkt_type]}{send}++; }
+	  }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$CBFTYPE[$pkt_type]}++;
+	  }
+	  next;
+	}
+
+	if (($protocol eq "Ping") &&
+	    ($subline =~ /^(\d+) \[(\d+)\] \d+.\d+/o)) {
+	  my $ping_seqno = $1; # seqno
+	  my $ping_type  = $2; # type
+	  my $flowid = "$pkt_src->$pkt_dst/$pkt_uid/$ping_seqno";
+
+	  # Bandwidth Consumption
+	  if ((($layer eq "RTR")||($layer eq "AGT")) &&
+	      (($op eq 's') || ($op eq 'f'))) {
+	    $bw{$layer}->{cnt} += 1;
+	    $bw{$layer}->{bw} += $pkt_size;
+	    $bw{$layer}{$PINGTYPE[$ping_type]}->{cnt} += 1;
+	    $bw{$layer}{$PINGTYPE[$ping_type]}->{bw} += $pkt_size;
+	  }
+
+	  # Packet Statistics
+	  if ($layer eq "RTR") {
+	    if ($op eq 'D') { $stats{$protocol}{$PINGTYPE[$ping_type]}{drop}++; }
+	    if ($op eq 'r') { $stats{$protocol}{$PINGTYPE[$ping_type]}{recv}++; }
+	    if ($op eq 'f') { $stats{$protocol}{$PINGTYPE[$ping_type]}{forw}++; }
+	    if ($op eq 's') { $stats{$protocol}{$PINGTYPE[$ping_type]}{send}++; }
+	  }
+
+	  # Write RTE File
+	  if ( (($layer eq 'RTR') && (($op eq 's')||($op eq 'f')||($op eq 'D'))) ||
+	       (($layer eq 'AGT') && (($op eq 's')||($op eq 'r'))) ) {
+	    if ($write_file){ print RTEFILE "$op $time _$node\_ $layer $pkt_uid $protocol [x x $fromhex - [$pkt_src:x $pkt_dst:x] $ping_seqno [$ping_type] \n"; }
+	  }
+
+	  # Get Type for Lookup Table
+	  if ($ping_type == 0) { $LOOKUP{$pkt_uid}->{ping} = 1; }
+
+	  if ($layer eq "AGT") {
+	    if ($op eq 's') {
+
+	      if ($ping_type == 0) { $duplicates{sent}++; }
+
+	      if (not exists $PKT{$PINGTYPE[$ping_type]}{$flowid}) {
+		# Build Packet Tree
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{sends}    = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{bw}       = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{hops}     = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{taken}    = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{shortest} = 0;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{src}      = $pkt_src;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{dst}      = $pkt_dst;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{uid}      = $pkt_uid;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{start}    = $time;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{startTTL} = $pkt_ttl;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}{reached}  = 0;
+	      }
+
+	      my $key = "$pkt_src/$pkt_dst";
+	      if (($ping_type == 0) && (not exists $LAT{$key}{start})) {
+		$LAT{$key}{start} = $time;
+	      }
+
+	      if (($miss_analysis == 1) && ($noFiles == 1)) {
+		$delivery_count{$pkt_uid} = 0;
+	      }
+
+	    } elsif ($op eq 'r') {
+
+	      if ($ping_type == 0) { $duplicates{recv}++; }
+
+	      # Build Route Tree
+	      if ($node == $PKT{$PINGTYPE[$ping_type]}{$flowid}->{dst}) {
+		if ($PKT{$PINGTYPE[$ping_type]}{$flowid}->{reached} == 0) {
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}->{reached}  = 1;
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}->{taken}    = $LOOKUP{$pkt_uid}->{taken};
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}->{shortest} = $LOOKUP{$pkt_uid}->{shortest};
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}{end}    = $time;
+		  $PKT{$PINGTYPE[$ping_type]}{$flowid}{endTTL} = $pkt_ttl-1;
+		}
+	      }
+
+	      my $key = "$pkt_src/$pkt_dst";
+	      if (($ping_type == 0) && (not exists $LAT{$key}{end})) {
+		$LAT{$key}{end} = $time;
+	      }
+
+	      if (($miss_analysis == 1) && ($noFiles == 1)) {
+		$delivery_count{$pkt_uid}++;
+	      }
+	    }
+	  }
+	  if ($layer eq "RTR") {
+
+	    if (($ping_type == 0) && ($op eq 'D')) { $duplicates{recv}++; }
+
+	    # Build Packet Tree
+	    if (($op eq 's')||($op eq 'f')) {
+	      $PKT{$PINGTYPE[$ping_type]}{$flowid}->{sends}++;
+	      $PKT{$PINGTYPE[$ping_type]}{$flowid}->{bw} += $pkt_size;
+	      if (not exists $PKT{$PINGTYPE[$ping_type]}{$flowid}->{route}->{$node}) {
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}->{hops}++;
+		$PKT{$PINGTYPE[$ping_type]}{$flowid}->{route}->{$node} = 1;
+	      }
+	    }
+
+	    if ($op eq 'D') {
+	      my $reason = "$layer/$drop_rsn";
+	      $drops{$reason}{$PINGTYPE[$ping_type]}++;
+	    }
+	  }
+	  next;
+	}
+
+	# MAC layer packets should only be added to
+	# the drop statistic
+	if ($layer eq "MAC") {
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$protocol}++;
+	  }
+	  next;
+	}
+
+	# IFQ packets should only be added to
+	# the drop statistic
+	if ($layer eq "IFQ") {
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$protocol}++;
+	  }
+	  next;
+	}
+
+	# Catch unknown protocols
+	my $unknown = "UKN/$protocol";
+
+	# Packet Statistics
+	if ($layer eq "RTR") {
+	  if ($op eq 'D') { $stats{$protocol}{$unknown}{drop}++; }
+	  if ($op eq 'r') { $stats{$protocol}{$unknown}{recv}++; }
+	  if ($op eq 'f') { $stats{$protocol}{$unknown}{forw}++; }
+	  if ($op eq 's') { $stats{$protocol}{$unknown}{send}++; }
+
+	  if ($op eq 'D') {
+	    my $reason = "$layer/$drop_rsn";
+	    $drops{$reason}{$unknown}++;
+	  }
+	}
+
+	# Debug
+	#print "Ignored: $line\n";
+      }
+    }
+    close(FILE);
+
+    if ($write_file) { close(RTEFILE); }
+
+    print " done\n";
+
+    # Compatibility Evals
+    if ($simulator_eval == 0) {
+      foreach my $protocol (keys %{$COMPAT{bw}{MAC}}) {
+	$bw{MAC}{$protocol}->{cnt} += $COMPAT{bw}{MAC}{$protocol}->{cnt};
+	$bw{MAC}{$protocol}->{bw} += $COMPAT{bw}{MAC}{$protocol}->{bw};
+	$bw{MAC}->{cnt} += $COMPAT{bw}{MAC}{$protocol}->{cnt};
+	$bw{MAC}->{bw} += $COMPAT{bw}{MAC}{$protocol}->{bw};
+      }
+      my $sends = 0;
+      for (my $i=0; $i < 3; $i++) {
+	$areausage{usage}{$i} += $COMPAT{area}{usage}{$i};
+      }
+      $areausage{sends} += $COMPAT{area}{sends}++;
+      if (exists $COMPAT{area}{valid}) {
+	$areausage{valid} = 1;
+      }
+    }else{
+      # Reset Variable for next file
+      $simulator_eval = 0;
+    }
+
+    # Intermediate Hash Evaluation
+    evalPacketFlows();
+    evalDelivery();
+    evalLatency();
+  }
+
+  # Fill Hashes
+  padHash(\%latency_spectrum, $quant_step);
+
+  # Data Display
+  if (($latency_analysis == 0) && ($processed > 0)) {
+    printStatistics();
+    writeStatistics();
+  }
+}
+
+################################################################
+
+
+#################################
+#
+# Packet Delivery
+#
+sub evalDelivery {
+
+  my $debug = 0;
+
+  foreach my $type (keys %PKT) {
+
+    my ($sends,$recv) = (0,0);
+    foreach my $flowid (keys %{$PKT{$type}}) {
+      $delivery{$type}{sends}++;
+      $sends++;
+      if ($PKT{$type}{$flowid}->{reached}) {
+	$delivery{$type}{recv}++;
+	$recv++;
+      }
+    }
+
+    # Sample Delivery of this File
+    $delivery{$type}{dels}{$delivery{$type}{cnt}} = calcPercent($sends,$recv);
+
+    if ($debug) {
+      print "sends: $sends / $delivery{$type}{sends}\n";
+      print "recv: $recv / $delivery{$type}{recv}\n";
+      print "smaldel $delivery{$type}{cnt}: $delivery{$type}{dels}{$delivery{$type}{cnt}} %\n";
+    }
+
+    $delivery{$type}{cnt}++;
+  }
+}
+
+sub printDelivery {
+
+  my $debug = 0;
+
+  print "Delivery Statistics:\n\n";
+
+  foreach my $type (keys %delivery) {
+
+    my ($var,$cnt) = (0,0);
+    my $average = calcPercent($delivery{$type}{sends},$delivery{$type}{recv});
+    if ($debug) { print "Average is: $average %\n"; }
+
+    foreach my $no (keys %{$delivery{$type}{dels}}) {
+      if ($debug) { printf("$no: $delivery{$type}{dels}{$no} %s -> %f\n","%",($average - $delivery{$type}{dels}{$no})); }
+      $var += (($average - $delivery{$type}{dels}{$no}) * ($average - $delivery{$type}{dels}{$no}));
+      $cnt++;
+    }
+    if ($cnt > 1) { $var /= $cnt-1; }
+    else { $var = 0; }
+    my $deviation = sqrt($var);
+    if ($debug) { print "Deviation is: $deviation %\n"; }
+
+    printf("$type Packet Delivery: %i / %i -> %.2f %s (+/- %.2f)\n", 
+	   $delivery{$type}{recv}/$noFiles, $delivery{$type}{sends}/$noFiles, $average, "%", $deviation);
+  }
+
+  print "\n";
+}
+
+sub printDeliveryCount {
+
+  print "Packet Receives:\n\n";
+  foreach my $uid (sort keys %delivery_count) {
+    print "\t$uid \t:\t$delivery_count{$uid}\n";
+  }
+  print "\n";
+}
+
+#################################
+#
+# Packet Statistics
+#
+sub printPktStats {
+
+  print "Packet Statistics:\n\n";
+
+  print"\t\t\t    Sent       Forw       Recv       Drop\n";
+
+  foreach my $protocol (sort keys %stats) {
+    printf("\tRTR/$protocol\n");
+    foreach my $type (sort keys %{$stats{$protocol}}) {
+      printf("\t\t$type\t%8i   %8i   %8i   %8i\n",
+	     $stats{$protocol}{$type}{send}/$noFiles,
+	     $stats{$protocol}{$type}{forw}/$noFiles,
+	     $stats{$protocol}{$type}{recv}/$noFiles,
+	     $stats{$protocol}{$type}{drop}/$noFiles);
+    }
+  }
+  print "\n";
+}
+
+#################################
+#
+# Packet Drops
+#
+sub printDrops {
+
+  printf("Packet Drops:\n\n");
+  foreach my $reason (sort keys %drops) {
+    printf("\t$reason:\n");
+    foreach my $type (sort keys %{$drops{$reason}}) {
+      printf("\t\t$type\t: %.2f\n",$drops{$reason}{$type}/$noFiles);
+    }
+  }
+  print("\n");
+}
+
+#################################
+#
+# Reachability Information
+#
+sub printReachability {
+
+  printf("No-Route Drop Reachability:\n\n");
+  foreach my $proto (sort keys %reachability) {
+    printf("\t$proto:\n");
+    printf("\t   Dijkstra Reachable\t: %.2f / %.2f -> %.2f %s\n",
+	   $reachability{$proto}{shortest}/$noFiles,
+	   $reachability{$proto}{drops}/$noFiles,
+	   calcPercent($reachability{$proto}{drops},$reachability{$proto}{shortest}),
+	  "%");
+    printf("\t   Greedy Reachable\t: %i / %i -> %.2f %s\n",
+	   $reachability{$proto}{greedy}/$noFiles,
+	   $reachability{$proto}{drops}/$noFiles,
+	   calcPercent($reachability{$proto}{drops},$reachability{$proto}{greedy}),
+	   "%");
+  }
+  printf("\n");
+
+}
+
+#################################
+#
+# Bandwidth
+#
+sub printBW {
+
+  my $bwfac = 1;
+  my $fac = 1 / $noFiles;
+  my $unit = shift();
+
+  if ($unit eq "kbps") { # Kilobit/sec
+    $bwfac = 8 / (1024 * $duration * $noFiles);
+  }elsif ($unit eq "mbps") { # Megabit/sec
+    $bwfac = 8 / (1024 * 1024 * $duration * $noFiles);
+  }else{ # Default: Kilobyte/run
+    $unit = "kB/Run";
+    $bwfac = 1 / (1024 * $noFiles);
+  }
+
+  printf("Bandwidth Consumption ($unit):\n\n");
+
+  foreach my $l (sort keys %bw) {
+    printf("\t$l\t:\t%.2f $unit\t(%.2f s/f)\n",$bwfac*$bw{$l}->{bw},$fac*$bw{$l}->{cnt});
+    foreach my $p (sort keys %{$bw{$l}}) {
+      if (($p ne "bw") && ($p ne "cnt")) {
+	printf("\t  $p\t:\t%.2f $unit\t(%.2f s/f)\n", $bwfac*$bw{$l}->{$p}->{bw},$fac*$bw{$l}->{$p}->{cnt});
+      }
+    }
+  }
+  printf("\n");
+}
+
+#################################
+#
+# Packet Flow Information
+#
+sub evalPacketFlows {
+
+  my $debug = 0;
+
+  foreach my $type (keys %PKT) {
+
+    foreach my $flowid (keys %{$PKT{$type}}) {
+
+      if ($PKT{$type}{$flowid}->{reached}) {
+
+	$packetflow{$type}{reached}{cnt}++;
+
+	# Judge Route Quality
+	$packetflow{$type}{taken} += $PKT{$type}{$flowid}->{taken};
+	$packetflow{$type}{shortest} += $PKT{$type}{$flowid}->{shortest};
+
+	# Aquire optimal route
+	my $optimal;
+	if ($PKT{$type}{$flowid}->{taken} < $PKT{$type}{$flowid}->{shortest}) {
+	  $optimal = $PKT{$type}{$flowid}->{taken};
+	}else{
+	  $optimal = $PKT{$type}{$flowid}->{shortest};
+	}
+
+	# Count All
+	$packetflow{$type}{reached}{sends} += $PKT{$type}{$flowid}->{sends};
+	$packetflow{$type}{reached}{bw} += $PKT{$type}{$flowid}->{bw};
+
+	my $sendbw = 0;
+	if ($PKT{$type}{$flowid}->{sends} != 0) {
+	  $sendbw = $PKT{$type}{$flowid}->{bw} / $PKT{$type}{$flowid}->{sends};
+	}
+
+	# Necessary is: Optimal Route with 1 Send/Hop
+	$packetflow{$type}{nec}{sends} += $optimal;
+	$packetflow{$type}{nec}{bw} += $optimal * $sendbw;
+
+	# Redundant is: Everything that is not necessary
+	$packetflow{$type}{red}{sends} += $PKT{$type}{$flowid}->{sends} - $optimal;
+	$packetflow{$type}{red}{bw} += ($PKT{$type}{$flowid}->{sends} - $optimal) * $sendbw;
+      }else{
+	$packetflow{$type}{dropped}{cnt}++;
+	# Count All
+	$packetflow{$type}{dropped}{sends} += $PKT{$type}{$flowid}->{sends};
+	$packetflow{$type}{dropped}{bw} += $PKT{$type}{$flowid}->{bw};
+      }
+
+      # Calculate Load
+      $packetflow{$type}{flows}++;
+      $packetflow{$type}{sends} += $PKT{$type}{$flowid}->{sends};
+      $packetflow{$type}{bw} += $PKT{$type}{$flowid}->{bw};
+    }
+  }
+}
+
+sub printPacketFlows {
+
+  my $bwfac = 1;
+  my $fac = 1 / $noFiles;
+  my $unit = shift();
+
+  if ($unit eq "kbps") { # Kilobit/sec
+    $bwfac = 8 / (1024 * $duration * $noFiles);
+  }elsif ($unit eq "mbps") { # Megabit/sec
+    $bwfac = 8 / (1024 * 1024 * $duration * $noFiles);
+  }else{ # Default: Kilobyte/run
+    $unit = "kB/Run";
+    $bwfac = 1 / (1024 * $noFiles);
+  }
+
+  foreach my $type (sort keys %packetflow) {
+
+    printf("$type Flow Information:\n\n");
+
+    if ($packetflow{$type}{reached}{cnt} != 0) {
+      printf("\tAvg Taken Route (Reached)   :\t%.2f\n",$packetflow{$type}{taken}/$packetflow{$type}{reached}{cnt});
+      printf("\tAvg Shortest Route (Reached):\t%.2f\n",$packetflow{$type}{shortest}/$packetflow{$type}{reached}{cnt});
+    }
+    printf("\n");
+
+    printf("\tDropped Targets         :\t%.2f \n",$packetflow{$type}{dropped}{cnt}*$fac);
+    printf("\tDropped Transmissions   :\t%.2f \n",($packetflow{$type}{dropped}{sends}*$fac));
+    printf("\tDropped Traffic         :\t%.2f $unit\n",($packetflow{$type}{dropped}{bw}*$bwfac));
+    printf("\tReached Targets         :\t%.2f \n",$packetflow{$type}{reached}{cnt}*$fac);
+    printf("\tReached Transmissions   :\t%.2f \n",($packetflow{$type}{reached}{sends}*$fac));
+    printf("\tReached Traffic         :\t%.2f $unit\n",($packetflow{$type}{reached}{bw}*$bwfac));
+    printf("\t   Nec. Transmissions   :\t%.2f \n",($packetflow{$type}{nec}{sends}*$fac));
+    printf("\t   Nec. Traffic         :\t%.2f $unit\n",($packetflow{$type}{nec}{bw}*$bwfac));
+    printf("\t   Red. Transmissions   :\t%.2f \n",($packetflow{$type}{red}{sends}*$fac));
+    printf("\t   Red. Traffic         :\t%.2f $unit\n",($packetflow{$type}{red}{bw}*$bwfac));
+    printf("\n");
+    printf("\tTotal Targets           :\t%.2f \n",$packetflow{$type}{flows}*$fac);
+    printf("\tTotal Load Transmissions:\t%.2f \n",($packetflow{$type}{sends}*$fac));
+    printf("\tTotal Load Traffic      :\t%.2f $unit\n",($packetflow{$type}{bw}*$bwfac));
+    printf("\n");
+  }
+
+}
+
+#################################
+#
+# Latency
+#
+sub printLatency {
+
+  printf("Data Delivery Latency:\n\n");
+  foreach my $type (keys %latency) {
+    printf("\tAvg Hop Latency ($type)    \t: %.7f secs\n",$latency{$type}{shop}/$noFiles);
+    printf("\tAvg Pkt Latency ($type)    \t: %.7f secs\n",$latency{$type}{avg}/$noFiles);
+    if (exists $latency{$type}{fp}) {
+      printf("\tAvg 1st Pkt Latency ($type)\t: %.7f secs\n",$latency{$type}{fp}/$noFiles);
+    }
+  }
+  printf("\n");
+}
+
+sub evalLatency {
+
+  foreach my $type (keys %PKT) {
+    my ($avg,$avg_cnt) = (0,0);
+    my ($shop,$shop_cnt) = (0,0);
+    my ($rlen,$rlen_cnt) = (0,0);
+
+    if ($latency_analysis == 1) { print "$type:\n"; }
+
+    foreach my $flowid (keys %{$PKT{$type}}) {
+
+      if ($PKT{$type}{$flowid}{reached} == 1) {
+
+	my $lat = $PKT{$type}{$flowid}{end} - $PKT{$type}{$flowid}{start};
+
+	if ($type eq $PINGTYPE[0]) {
+	  incrQuantHash(\%latency_spectrum, $lat, 1);
+	}
+
+	$avg += $lat; $avg_cnt++;
+
+	my $len = ($PKT{$type}{$flowid}{startTTL} - $PKT{$type}{$flowid}{endTTL});
+	if ($len != 0) {
+	  $shop += $lat / $len; $shop_cnt++;
+	}
+
+	## for now we'll update the old route length vals
+	$rlen += $len; $rlen_cnt++;
+
+	if ($latency_analysis == 1) {
+	  printf (" $PKT{$type}{$flowid}{end} - $PKT{$type}{$flowid}{start} / $PKT{$type}{$flowid}{endTTL} - $PKT{$type}{$flowid}{startTTL} evals to %.2f\n", $lat/$len);
+	}
+
+      }
+    }
+    if ($avg_cnt != 0) {
+      $latency{$type}{avg} += $avg/$avg_cnt;
+    }
+    if ($shop_cnt != 0) {
+      $latency{$type}{shop} += $shop/$shop_cnt;
+    }
+  }
+
+  my ($fp,$fp_cnt) = (0,0);
+  foreach my $key (keys %LAT) {
+    $fp += $LAT{$key}{end} - $LAT{$key}{start};
+    $fp_cnt++;
+  }
+  if ($fp_cnt != 0) {
+    $latency{$PINGTYPE[0]}{fp} += $fp/$fp_cnt;
+  }
+}
+
+sub printLatencySpectrum {
+
+  print "Ping Latency Spectrum (Quantization: $quant_step):\n\n";
+  foreach my $delay (sort keys %latency_spectrum) {
+    if ($delay eq "valid") { next; }
+    printf("\t$delay\t: %.2f\n",$latency_spectrum{$delay}/$noFiles);
+  }
+  print "\n";
+}
+
+#################################
+#
+# MAC Collisions
+#
+sub printCollisions {
+
+  if ($collisions{valid}) {
+    printf("MAC Collision Statistics:\n\n");
+
+    printf("\tMAC Collisions\t: %.2f\n",$collisions{cols}/$noFiles);
+    foreach my $type (sort keys %collisions) {
+      if (($type eq "valid") || ($type eq "cols")) { next; }
+      printf("\t$type\t: %.2f %\n",calcPercent($collisions{cols},$collisions{$type}));
+    }
+    printf("\n");
+  }
+}
+
+#################################
+#
+# CBF Specials
+#
+sub printAreaUsage {
+
+  if ($areausage{valid}) {
+
+    printf("CBF Area Usage:\n\n");
+    printf("\tCounted Sends  :\t%.2f\n",$areausage{sends}/$noFiles);
+    foreach my $area (sort keys %{$areausage{usage}}) {
+      printf("\t  Usage Area $area :\t%.2f %\n",calcPercent($areausage{sends},$areausage{usage}{$area}));
+    }
+    printf("\n");
+  }
+}
+
+sub printDuplication {
+
+  printf("Ping Duplication Information:\n\n");
+  printf("\tDuplicates/Run    :\t%.2f\n",($duplicates{recv}-$duplicates{sent})/$noFiles);
+  if ($duplicates{sent} != 0) {
+    printf("\tAvg Dupes/Pkt     :\t%.2f\n",($duplicates{recv}-$duplicates{sent})/$duplicates{sent});
+  }
+  printf("\n");
+
+}
+
+#################################
+#
+# LOCS Specials
+#
+sub printUpdateReasons {
+
+  if ($gls_update{valid} == 1) {
+    print "Update Packets (Reason Keyed):\n\n";
+    foreach my $reason (sort keys %gls_update) {
+      if ($reason eq "valid") { next; }
+      printf("\t$reason\t: %.2f\n",$gls_update{$reason}/$noFiles);
+      print "\n";
+    }
+  }
+}
+
+#################################
+#
+# Useful Functions / Generics
+#
+sub calcPercent {
+  my $total = shift();
+  my $fraction = shift();
+  my $rate;
+
+  if($total > 0){
+    $rate = ($fraction*100)/$total;
+  }else{
+    $rate = 0;
+  }
+
+  return $rate;
+}
+
+sub incrQuantHash {
+  my $hRef = shift();
+  my $hKey = shift();
+  my $incrValue = shift();
+
+  # Quantize Key
+  #print "got key: $hKey ->";
+  my $index = $quant_step;
+  for ($index = $quant_step; ($hKey / $index) >= 1; $index += $quant_step) {}
+  $hKey = $index - $quant_step;
+  #print " selected bucket: $hKey\n";
+
+  if (exists $hRef->{$hKey}){
+    $hRef->{$hKey} += $incrValue;
+  }else{
+    $hRef->{$hKey} = $incrValue;
+  }
+}
+
+sub padHash {
+  my $hRef = shift();
+  my $step = shift();
+  my $biggest = 0;
+
+  foreach my $k (sort keys %$hRef){
+    if ($k > $biggest) {
+      $biggest = $k;
+    }
+  }
+
+  for (my $i = 0; $i < $biggest; $i += $step) {
+    if (not exists $hRef->{$i}){
+      $hRef->{$i} = 0;
+    }
+  }
+}
+
+
+#################################
+#
+# Usage
+#
+sub usage {
+  print "\nUsage: evaluate.pl [Options] -f files\n\n";
+  print "  Options are:\n\n";
+  print "  -tag/-t [String]   - Identifer tag for .lat and .dat files\n";
+  print "  -quant/-q [Value]  - Quantization step size for latency spectrum\n";
+  print "  -help/-h           - Display this usage message\n";
+  print "  -dat/-d            - Write/Append dat file X.dat\n";
+  print "                       (X is TAG or the ROUTING protocol read from the file/s)\n";
+  print "  -lat/-l            - Write Latency Spectrum to lat file X-NN-SP.lat\n";
+  print "                       (X is TAG or the ROUTING protocol read from the file/s)\n";
+  print "                       (NN is the number of nodes as read from the file/s)\n";
+  print "                       (SP is the max movement speed as read from the file/s)\n";
+  print "  -latana/-la        - Show details of single hop latency calculation\n";
+  print "  -missana/-ma       - Activate packet analysis (Parses only the first file)\n";
+  print "  -genrte/-rte       - Generate Route Files for Traces that don't have 'em yet\n";
+  print "\n";
+  exit;
+}
+
+#################################
+#
+# Command Line Parsing
+#
+sub parseCmdLine {
+
+  for (my $i = 0; $i <= $#ARGV; $i++) {
+
+    if ((($ARGV[$i] eq "-tag") || ($ARGV[$i] eq "-t")) &&
+	($ARGV[$i+1] !~ /^-/o) && ($ARGV[$i+1] ne "")) 
+      {
+	$filemark = $ARGV[$i+1];
+	$i++;
+	next;
+      }
+
+    if ((($ARGV[$i] eq "-quant") || ($ARGV[$i] eq "-q")) &&
+	($ARGV[$i+1] !~ /^-/o) && ($ARGV[$i+1] ne "")) 
+      {
+	if (($ARGV[$i+1] =~ /\d+.\d+/o) || ($ARGV[$i+1] =~ /\d+/o)) {
+	  $quant_step = $ARGV[$i+1];
+	  $i++;
+	}
+	next;
+      }
+
+    if (($ARGV[$i] eq "-files") || ($ARGV[$i] eq "-f")) {
+      while (($ARGV[$i+1] !~ /^-/o) && ($ARGV[$i+1] ne "")) {
+	$filelist[$noFiles] = $ARGV[$i+1];
+	$noFiles++;
+	$i++;
+      }
+      next;
+    }
+
+    if (($ARGV[$i] eq "-help") || ($ARGV[$i] eq "-h")) { usage(); exit; }
+    if (($ARGV[$i] eq "-dat") || ($ARGV[$i] eq "-d")) { $bDatfile = 1; next; }
+    if (($ARGV[$i] eq "-lat") || ($ARGV[$i] eq "-l")) { $bLatfile = 1; next; }
+    if (($ARGV[$i] eq "-missana") || ($ARGV[$i] eq "-ma")) { $miss_analysis = 1; next; }
+    if (($ARGV[$i] eq "-latana") || ($ARGV[$i] eq "-la")) { $latency_analysis = 1; next; }
+    if (($ARGV[$i] eq "-genrte") || ($ARGV[$i] eq "-rte")) { $gen_rte = 1; next; }
+  }
+}
+
+#################################
+#
+# File I/O
+#
+sub writeStatistics {
+
+  if ($filemark eq "") { $filemark = "$routing"; }
+
+  my $proto = lc($filemark);
+
+  if ($bLatfile == 1) {
+    my $specfile = "$proto-$nn-$speed{max}.lat";
+    open(LATSPEC, "> $specfile") or die "\tCan not open $specfile\n";
+    foreach my $k (sort keys %latency_spectrum){
+      printf(LATSPEC "$k %.2f\n",$latency_spectrum{$k}/$noFiles);
+    }
+    close(LATSPEC);
+  }
+
+  # Direct-to-File Output should be rwritten someday
+
+  #if ($bDatfile == 1) {
+  #  my $datfile = "$proto.dat";
+  #  open(OUT, ">> $datfile") or die "\tCan not open $datfile\n";
+  #  # NN SP PDEL EDEL PHLAT EHLAT PALAT EALAT FPLAT BO ABW PRLEN ERLEN NRTEREC
+  #  # 
+  #  close(OUT);
+  #}
+}
+
+#################################
+#
+# Header / Structuring
+#
+sub printSpeed {
+
+  if ($speed{cnt} != 0) {
+    $speed{avg} /= $speed{cnt};
+  }
+  my $s = 0;
+  for (my $j = $#SPEEDS; $j >= 0; $j--) {
+    if ($speed{max} <= $SPEEDS[$j]) {
+      $s = $SPEEDS[$j];
+    }
+  }
+  $speed{max} = $s;
+
+  printf ("Nodes moved at max. %i m/s (Average: %7.3f m/s)\n",$speed{max},$speed{avg});
+}
+
+######################
+# wk's subs
+sub distance {
+  my $x1 = shift();
+  my $y1 = shift();
+  my $x2 = shift();
+  my $y2 = shift();
+  my $deltax = $x2 - $x1;
+  my $deltay = $y2 - $y1;
+  my $distance = sqrt(($deltax*$deltax)+($deltay*$deltay));
+  return $distance;
+}
+
+sub printRequestTravelTime {
+  my $key;
+  print "Request Travel Time : \n";
+  foreach $key (sort keys %request_time_hash) {
+    printf("$key s: %.2f % \n", calcPercent( $lookup{reply_receive},
+					     $request_time_hash{$key}));
+  }
+}
+
+sub round {
+  my $input = shift();
+  $input = $input * 100;
+  $input = int($input + 0.5);
+  $input = $input / 100;
+}
+
+sub incrDistanceHash {  
+  my $hRef = shift();
+  my $hKey = shift();
+  my $step = shift();
+  my $tmpQuantStep = $quant_step;
+  $quant_step = $step;
+  incrQuantHash($hRef, $hKey, 1);
+  # store the maximum (distance)
+  if($hRef->{max} < $hKey) {
+    $hRef->{max} = $hKey;
+  }
+  # remember the total number of elements in the hash
+  $hRef->{numberOfEntries}++;
+
+  $quant_step = $tmpQuantStep;
+}
+
+sub printCacheLookupHash {
+  my $hRef = shift();
+  my $step = shift();
+  my $value;
+  my $total = $hRef->{numberOfEntries};
+  my $max = $hRef->{max};
+  my $actual = 0;
+  my $next;
+  my $radiorange = 250;
+  my $lookup_abover_rr = 0;
+  while ($actual < $max) {
+    $value = $hRef->{$actual};
+    $next = $actual + $step;
+    print "$actual to $next m : " ;
+    print round(calcPercent($total, $value)) . " %\n";
+    $actual = $next;
+    if($next > $radiorange) {
+      $lookup_abover_rr += $value;
+    }
+  }
+  print "Entries above radiorange: " .
+    round(calcPercent($total, $lookup_abover_rr)) . " %\n";
+  return $lookup_abover_rr;
+}
+
+sub printWKGLSstats {
+
+  print "GLS statistics:\n\n";
+  print "Queries         : $lookup{queries}\n";
+  my $avgage = -1;
+  if($lookup{cache_lookups} != 0) {
+    $avgage = $cache_statistic{totalage} / $lookup{cache_lookups};
+  }
+  print "Cache Lookups   : $lookup{cache_lookups} min age $cache_statistic{minage}, max age $cache_statistic{maxage}, avg age $avgage\n";
+  $avgage = $reply_statistic{totalage} / $lookup{reply_receive};
+  print "Requests send   : $lookup{request_send} \n";
+  print "Replies received: $lookup{reply_receive} min age $reply_statistic{minage}, max age $reply_statistic{maxage}, avg age $avgage\n";
+  my $failure_rate = ($lookup{queries} - $lookup{cache_lookups} - $lookup{reply_receive}) / $lookup{queries};
+  # following code rounds $failure_rate to two decimals behind commma
+  $failure_rate = $failure_rate * 10000;
+  $failure_rate = int($failure_rate + 0.5);
+  $failure_rate = $failure_rate / 100;
+  # end rounding
+  print "failure rate    : $failure_rate %\n"; 
+  print "\n";
+
+  print "Cache Lookup deviation:\n";
+  my $cache_entries_above_rr = printCacheLookupHash(\%cl_deviation,$deviation_quant_step);
+  my $percentage_of_all_queries = ($cache_entries_above_rr / $lookup{queries})*100;
+  printf("This corresponds to %.2f percent of all queries\n", $percentage_of_all_queries);
+  print "\n";
+  # requests sropped
+
+  printRequestTravelTime();
+}
+#################
+# end wk's subs
+
+
+
+sub printStatistics {
+
+  print "\nStatistics:\n";
+  print "----------\n";
+  print "$noFiles $routing Runs evaluated ($mac)\n";
+  printf ("%i Nodes in an Area of %ix%i sqm for %7.3f secs\n",$nn, $x, $y, $duration);
+  printSpeed();
+  print "----------\n\n";
+
+  printWKGLSstats();
+
+  printDelivery();
+  printPktStats();
+  printDrops();
+  printReachability();
+  printBW();
+  printPacketFlows();
+  printLatency();
+  printCollisions();
+
+  # Specials
+  printAreaUsage();
+  printDuplication();
+  printUpdateReasons();
+
+  # Enduring Plots
+  printLatencySpectrum();
+  if ($miss_analysis == 1) { printDeliveryCount(); }
+}
diff -u -r --new-file ./hls/utils/hls.tcl ../../ns-2.33-hls_working/ns-2.33/hls/utils/hls.tcl
--- ./hls/utils/hls.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/hls.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,161 @@
+# author: Thomas Ogilvie
+# sample tcl script showing the use of GPSR and HLS (hierarchical location service)
+
+
+## GPSR Options
+Agent/GPSR set bdesync_                0.5 ;# beacon desync random component
+Agent/GPSR set bexp_                   [expr 3*([Agent/GPSR set bint_]+[Agent/GPSR set bdesync_]*[Agent/GPSR set bint_])] ;# beacon timeout interval
+Agent/GPSR set pint_                   1.5 ;# peri probe interval
+Agent/GPSR set pdesync_                0.5 ;# peri probe desync random component
+Agent/GPSR set lpexp_                  8.0 ;# peris unused timeout interval
+Agent/GPSR set drop_debug_             1   ;#
+Agent/GPSR set peri_proact_            1 	 ;# proactively generate peri probes
+Agent/GPSR set use_implicit_beacon_    1   ;# all packets act as beacons; promisc.
+Agent/GPSR set use_timed_plnrz_        0   ;# replanarize periodically
+Agent/GPSR set use_congestion_control_ 0
+Agent/GPSR set use_reactive_beacon_    0   ;# only use reactive beaconing
+
+set val(bint)           0.5  ;# beacon interval
+set val(use_mac)        1    ;# use link breakage feedback from MAC
+set val(use_peri)       1    ;# probe and use perimeters
+set val(use_planar)     1    ;# planarize graph
+set val(verbose)        1    ;#
+set val(use_beacon)     1    ;# use beacons at all
+set val(use_reactive)   0    ;# use reactive beaconing
+set val(locs)           0    ;# default to OmniLS
+set val(use_loop)       0    ;# look for unexpected loops in peris
+
+set val(agg_mac)          1 ;# Aggregate MAC Traces
+set val(agg_rtr)          0 ;# Aggregate RTR Traces
+set val(agg_trc)          0 ;# Shorten Trace File
+
+
+set val(chan)		Channel/WirelessChannel
+set val(prop)		Propagation/TwoRayGround
+set val(netif)		Phy/WirelessPhy
+set val(mac)		Mac/802_11
+set val(ifq)		Queue/DropTail/PriQueue
+set val(ll)		LL
+set val(ant)		Antenna/OmniAntenna
+set val(x)		2000      ;# X dimension of the topography
+set val(y)		2000      ;# Y dimension of the topography
+set val(ifqlen)		512       ;# max packet in ifq
+set val(seed)		1.0
+set val(adhocRouting)	GPSR      ;# AdHoc Routing Protocol
+set val(nn)		40       ;# how many nodes are simulated
+set val(stop)		40.0     ;# simulation time
+set val(use_gk)		0	  ;# > 0: use GridKeeper with this radius
+set val(zip)		0         ;# should trace files be zipped
+
+set val(agttrc)         ON ;# Trace Agent
+set val(rtrtrc)         ON ;# Trace Routing Agent
+set val(mactrc)         ON ;# Trace MAC Layer
+set val(movtrc)         ON ;# Trace Movement
+
+
+set val(lt)		""
+set val(cp)		"cp-n40-a40-t40-c4-m0"
+set val(sc)		"sc-x2000-y2000-n40-s25-t40"
+
+set val(out)            "hls_test.tr"
+
+Agent/GPSR set locservice_type_ 3
+
+add-all-packet-headers
+remove-all-packet-headers
+add-packet-header Common Flags IP LL Mac Message GPSR  LOCS SR RTP Ping HLS
+
+Agent/GPSR set bint_                  $val(bint)
+# Recalculating bexp_ here
+Agent/GPSR set bexp_                 [expr 3*([Agent/GPSR set bint_]+[Agent/GPSR set bdesync_]*[Agent/GPSR set bint_])] ;# beacon timeout interval
+Agent/GPSR set use_peri_              $val(use_peri)
+Agent/GPSR set use_planar_            $val(use_planar)
+Agent/GPSR set use_mac_               $val(use_mac)
+Agent/GPSR set use_beacon_            $val(use_beacon)
+Agent/GPSR set verbose_               $val(verbose)
+Agent/GPSR set use_reactive_beacon_   $val(use_reactive)
+Agent/GPSR set use_loop_detect_       $val(use_loop)
+
+CMUTrace set aggregate_mac_           $val(agg_mac)
+CMUTrace set aggregate_rtr_           $val(agg_rtr)
+
+# seeding RNG
+ns-random $val(seed)
+
+# create simulator instance
+set ns_		[new Simulator]
+
+set loadTrace  $val(lt)
+
+set topo	[new Topography]
+$topo load_flatgrid $val(x) $val(y)
+
+set tracefd	[open $val(out) w]
+
+$ns_ trace-all $tracefd
+
+set chanl [new $val(chan)]
+
+# Create God
+set god_ [create-god $val(nn)]
+
+# Attach Trace to God
+set T [new Trace/Generic]
+$T attach $tracefd
+$T set src_ -5
+$god_ tracetarget $T
+
+#
+# Define Nodes
+#
+puts "Configuring Nodes ($val(nn))"
+$ns_ node-config -adhocRouting $val(adhocRouting) \
+                 -llType $val(ll) \
+                 -macType $val(mac) \
+                 -ifqType $val(ifq) \
+                 -ifqLen $val(ifqlen) \
+                 -antType $val(ant) \
+                 -propType $val(prop) \
+                 -phyType $val(netif) \
+                 -channel $chanl \
+		 -topoInstance $topo \
+                 -wiredRouting OFF \
+		 -mobileIP OFF \
+		 -agentTrace $val(agttrc) \
+                 -routerTrace $val(rtrtrc) \
+                 -macTrace $val(mactrc) \
+                 -movementTrace $val(movtrc)
+
+#
+#  Create the specified number of nodes [$val(nn)] and "attach" them
+#  to the channel. 
+for {set i 0} {$i < $val(nn) } {incr i} {
+    set node_($i) [$ns_ node]
+    $node_($i) random-motion 0		;# disable random motion
+	set ragent [$node_($i) set ragent_]
+	$ragent install-tap [$node_($i) set mac_(0)]
+
+    if { $val(mac) == "Mac/802_11" } {      
+	# bind MAC load trace file
+	[$node_($i) set mac_(0)] load-trace $loadTrace
+    }
+
+    # Bring Nodes to God's Attention
+    $god_ new_node $node_($i)
+}
+
+source $val(sc)
+
+source $val(cp)
+
+#
+# Tell nodes when the simulation ends
+#
+for {set i 0} {$i < $val(nn) } {incr i} {
+    $ns_ at $val(stop).0 "$node_($i) reset";
+}
+
+$ns_ at  $val(stop).0002 "puts \"NS EXITING... $val(out)\" ; $ns_ halt"
+
+puts "Starting Simulation..."
+$ns_ run
diff -u -r --new-file ./hls/utils/README.txt ../../ns-2.33-hls_working/ns-2.33/hls/utils/README.txt
--- ./hls/utils/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/README.txt	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,4 @@
+This directory contains some sample files showing the use of GPSR and HLS. For information on the functionality of HLS visit:
+
+http://www.cn.uni-duesseldorf.de/publications/library/Kiess2003b.pdf
+
diff -u -r --new-file ./hls/utils/runfromdirectory.pl ../../ns-2.33-hls_working/ns-2.33/hls/utils/runfromdirectory.pl
--- ./hls/utils/runfromdirectory.pl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/runfromdirectory.pl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,184 @@
+#!/usr/bin/perl
+my $recursive = "false";
+my $use_peri  = "1";
+my $mac_emu   = "1";
+my $locs      = "3";
+my $necessary_queries = "1200";
+
+my $run_tcl = "/home/stud/kiess/space/ns-util/run.tcl";
+
+##############
+# main program
+##############
+parseCmdLine();
+
+# recursive part
+if($recursive eq "true") {
+    print "recursive\n";
+
+    opendir(DIRECTORY, '.');
+    @entries = readdir(DIRECTORY);
+    foreach $entry (@entries) {
+	if(( -d $entry) && (!($entry =~ /\.+/o)) ) {
+	    # select all directories which are != "." or ".."
+	    print "processing $entry ...\n";
+	    processDirectory($entry);
+	}
+    }
+# end of recursive part
+} else {
+    print "non recursive\n";
+    processDirectory(".");
+}
+
+
+sub processDirectory {
+    my $entry = shift();
+    chdir $entry;
+    print "process $entry\n";
+    opendir(WORKING_DIRECTORY, '.');
+
+    
+    my $numberOfNodes;
+    my $connections;
+    my $startuptime;
+    my $communicationEndTime;
+    my $x;
+    my $y;
+    my $speed;
+    my $overallTime;
+    my $sc = "";
+    my $cp = "";
+
+    my $hls_queries = 0;
+    my $gls_queries = 0;
+    
+    
+    @files = readdir(WORKING_DIRECTORY);
+    foreach $file (@files) {
+	if( -f $file) {
+#	    print "$entry / $file\n";
+	    
+#cp-n400-c300-15-78.tcl
+#sc-x2000-y2000-n400-s30-t80-MRD
+	    # it is the communication pattern file
+	    if($file =~ /cp-n(\d+)-(c(\d+)?)-(\d+)-(\d+)/o) {
+		$numberOfNodes        = $1;
+
+		$startuptime          = $4;
+		$communicationEndTime = $5;
+		$cp = $file;
+
+		#print "$1 $2 $3 $4 $5\n";
+		if($2 =~ /c(\d+)/o) {
+		    $connections          = $1;
+		} else {
+		    $connections = 0;
+		}
+		print "matched $file\n";  
+		}
+	    if($file =~ /sc-x(\d+)-y(\d+)-n(\d+)-s(\d+)-t(\d+)/o) {
+		$x = $1;
+		$y = $2;
+		$speed = $4;
+		$overallTime = $5;
+		$sc = $file;
+		print "matched $file\n";
+	    }
+
+	    # match the evaluated file
+	    if($file =~ /evaluated/o) {
+		open(FILE, "$file");
+		my $queries = 0;
+		while (my $line = <FILE>) {
+		    if($line =~ /Queries         : (\d+)/o){
+			$queries = $1;
+		    }
+		}
+#		print $queries . "\n";
+		if(($file =~ /peri_evaluated/o) || ($file =~ /hls_evaluated/o)) {
+		    $hls_queries = $queries;
+		}
+		if($file =~ /gls_evaluated/o) {
+		    $gls_queries = $queries;
+		}
+
+#		print $file . "\n";
+	    }
+	}
+    }
+    
+    # we have the information we need, now run ns...
+    if(($sc ne "") &&($cp ne "")){
+	my $filename;
+	if($locs eq "3") {
+	    $filename = "hls_trace.txt";
+	    if($necessary_queries == $hls_queries) {
+		print "$hls_queries queries in evaluated file, thus don't run simulations\n";
+		chdir "..";
+		return;
+	    }
+	} else {
+	    $filename = "gls_trace.txt";	    
+	    if($necessary_queries == $gls_queries) {
+		print "$gls_queries queries in evaluated file, thus don't run simulations\n";
+		chdir "..";
+		return;
+	    }
+	}
+	
+	print "executing ... -out $filename -sc $sc -cp $cp -nn $numberOfNodes -locs $locs -x $x -y $y -stop $overallTime -mac_emu $mac_emu\n";
+	system("nohup ns $run_tcl -out $filename -sc $sc -cp $cp -nn $numberOfNodes -locs $locs -x $x -y $y -stop $overallTime -zip 1 -use_peri $use_peri -mac_emu $mac_emu");
+    }
+    chdir "..";
+}
+
+
+sub parseCmdLine {
+  for (my $i = 0; $i <= $#ARGV; $i++) {
+      if ($ARGV[$i] eq "-r") {
+	  $recursive = "true";
+      }
+      if ($ARGV[$i] eq "-gls") {
+	  $locs = "2";
+      }
+      if ($ARGV[$i] eq "-no_peri") {
+	  $use_peri = "0";
+      }
+      if ($ARGV[$i] eq "-help") {
+	  printHelp();
+	  exit;
+      }  
+
+      if ($ARGV[$i] eq "-queries") {
+	  $necessary_queries = $ARGV[$i+1];
+	  $i++;
+      }   
+
+      if ($ARGV[$i] eq "-run_tcl") {
+	  $run_tcl = $ARGV[$i+1];
+	  $i++;
+      }    
+
+      if ($ARGV[$i] eq "-no_mac_emu") {
+	  $mac_emu = "0";
+      }         
+  }
+}
+
+
+sub printHelp {
+
+    print "This script is designed to run an ns simulation from an\n";
+    print "existing directory\n";
+    print "Options:\n";
+    print "  -r (recursive)                      DEFAULT : false\n";
+    print "  -gls (use GLS)                      DEFAULT : HLS\n";
+    print "  -no_peri (don't use perimeter mode) DEFAULT : use it\n";
+    print "  -queries (nr of queries which must be in the evaluated file to\n";
+    print "            avoid running the sim     DEFAULT : 1200\n";
+    print "  -run_tcl <full path to run.tcl>     DEFAULT : /home/stud/kiess/space/ns-util/run.tcl\n";
+    print "  -no_mac_emu (no mac emulation)      DEFAULT : mac emulation\n";
+    print "  -help (show this help)\n";
+    print "\n";
+}
diff -u -r --new-file ./hls/utils/run_small.bat ../../ns-2.33-hls_working/ns-2.33/hls/utils/run_small.bat
--- ./hls/utils/run_small.bat	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/run_small.bat	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,72 @@
+#!/bin/bash
+
+############################
+# configuration
+############################
+nn="100"
+speed="30"
+x="2000"
+y="2000"
+stop="100"
+trafficStop=`expr $stop - 2`
+startup="15"
+mode="0" 
+# test-query, ...
+MRD="1"
+mrdString="-MRD"
+runs="1"
+active="100"
+connectionsPerNode="4"
+totalConnections=`expr $active \* $connectionsPerNode`
+
+peri="1"
+macemu="0"
+#reactive="0"
+
+
+cp="cp-n$nn-c$totalConnections-$startup-$trafficStop.tcl"
+sc="sc-x$x-y$y-n$nn-s$speed-t$stop$mrdString"
+
+
+
+# local variables
+counter="0"
+while [ $counter -lt $runs ]
+do
+  echo "Run Configuration: -n $nn -s $speed -t $stop -x $x -y $y -mrd $MRD -c $totalConnections"
+  counter=$((counter+1))
+  date=$(date +%j:%T)
+  
+  directory="$nn-$speed-$date";
+  #./scengen -n $nn -s $speed -t $stop -x $x -y $y -m $MRD > $sc
+  #./trafgen -n $nn -a $active -t $trafficStop -c $connectionsPerNode -m $mode -w $startup > $cp
+  
+
+  sc="sc-x2000-y2000-n100-s30-t100-MRD"
+  cp="cp-n100-c400-15-98.tcl"
+  
+  perl ./namable.pl $sc $sc
+  
+  mkdir $directory
+  # HLS
+  #ns run.tcl -out $directory/hls_trace.txt -sc $sc -cp $cp -nn $nn -locs 3 -use_peri 0 -x $x -y $y -mac_emu $macemu -stop $stop -zip 1 
+  # GLS
+  #ns run.tcl -out $directory/gls_trace.txt -sc $sc -cp $cp -nn $nn -locs 2 -use_peri $peri -x $x -y $y -mac_emu $macemu -stop $stop -zip 1 
+  # HLS with peri
+  ../../ns run.tcl -out $directory/hls_trace_peri.txt -sc $sc -cp $cp -nn $nn -locs 3 -use_peri 1 -x $x -y $y -mac_emu $macemu -stop $stop #-zip 1
+# end of simulation, now copying the input files
+  cp $sc $directory
+  cp $cp $directory
+  cd $directory
+  #evaluate.pl -f hls_trace.txt.gz > evaluated
+  #gls_evaluate.pl -f gls_trace.txt.gz > gls_evaluated
+  perl ../evaluate.pl -f hls_trace_peri.txt > peri_evaluated
+  cd ..
+done
+
+
+
+
+	
+#cd $directory
+#evaluate.pl -f hls_trace.txt.gz > evaluated
diff -u -r --new-file ./hls/utils/run.tcl ../../ns-2.33-hls_working/ns-2.33/hls/utils/run.tcl
--- ./hls/utils/run.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/run.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,532 @@
+# Copyrighi (c) 1999 Regents of the University of Southern California.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. All advertising materials mentioning features or use of this software
+#    must display the following acknowledgement:
+#      This product includes software developed by the Computer Systems
+#      Engineering Group at Lawrence Berkeley Laboratory.
+# 4. Neither the name of the University nor of the Laboratory may be used
+#    to endorse or promote products derived from this software without
+#    specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+# wireless1.tcl
+# $Id: run.tcl,v 1.50 2002/11/28 16:54:38 mikael Exp $
+
+set PI 3.1415926535897
+
+# ======================================================================
+# Define Protocol Defaults
+# ======================================================================
+
+## GPSR Options
+Agent/GPSR set bdesync_                0.5 ;# beacon desync random component
+Agent/GPSR set bexp_                   [expr 3*([Agent/GPSR set bint_]+[Agent/GPSR set bdesync_]*[Agent/GPSR set bint_])] ;# beacon timeout interval
+Agent/GPSR set pint_                   1.5 ;# peri probe interval
+Agent/GPSR set pdesync_                0.5 ;# peri probe desync random component
+Agent/GPSR set lpexp_                  8.0 ;# peris unused timeout interval
+Agent/GPSR set drop_debug_             1   ;#
+Agent/GPSR set peri_proact_            1 	 ;# proactively generate peri probes
+Agent/GPSR set use_implicit_beacon_    1   ;# all packets act as beacons; promisc.
+Agent/GPSR set use_timed_plnrz_        0   ;# replanarize periodically
+Agent/GPSR set use_congestion_control_ 0
+Agent/GPSR set use_reactive_beacon_    0   ;# only use reactive beaconing
+
+set val(bint)           0.5  ;# beacon interval
+set val(use_mac)        1    ;# use link breakage feedback from MAC
+set val(use_peri)       1    ;# probe and use perimeters
+set val(use_planar)     1    ;# planarize graph
+set val(verbose)        1    ;#
+set val(use_beacon)     1    ;# use beacons at all
+set val(use_reactive)   0    ;# use reactive beaconing
+set val(locs)           0    ;# default to OmniLS
+set val(use_loop)       0    ;# look for unexpected loops in peris
+
+set val(agg_mac)          1 ;# Aggregate MAC Traces
+set val(agg_rtr)          0 ;# Aggregate RTR Traces
+set val(agg_trc)          0 ;# Shorten Trace File
+
+# ======================================================================
+# Define NS Object Defaults
+# ======================================================================
+
+# In case normal MovementTrace Option is a no-go
+Node/MobileNode set movtrace_   1
+
+# Should ARP Lookup be used in LL
+LL set useARP_                  0
+
+# Routing Protocol Prefered (might break Protocol)
+Queue/DropTail/PriQueue set Prefer_Routing_Protocols  0
+
+# ======================================================================
+# Define Options
+# ======================================================================
+
+set val(chan)		Channel/WirelessChannel
+set val(prop)		Propagation/TwoRayGround
+set val(netif)		Phy/WirelessPhy
+set val(mac)		Mac/802_11
+set val(ifq)		Queue/DropTail/PriQueue
+set val(ll)		LL
+set val(ant)		Antenna/OmniAntenna
+set val(x)		1000      ;# X dimension of the topography
+set val(y)		1000      ;# Y dimension of the topography
+set val(ifqlen)		512       ;# max packet in ifq
+set val(seed)		1.0
+set val(adhocRouting)	GPSR      ;# AdHoc Routing Protocol
+set val(nn)		15       ;# how many nodes are simulated
+set val(stop)		40.0     ;# simulation time
+set val(use_gk)		0	  ;# > 0: use GridKeeper with this radius
+set val(zip)		0         ;# should trace files be zipped
+set val(bw)		""
+set val(bs)		""
+set val(rr)		""
+
+set path                ./
+set val(cp)             ""
+set val(sc)             ""
+set val(out)            ""
+set val(on_off)		""
+set val(pingLog)        ""
+set val(lt)		"" ;# MAC load trace file
+
+set val(cc)		"" ;# congestion control
+set val(smooth_cc)	""
+
+set val(agttrc)         ON ;# Trace Agent
+set val(rtrtrc)         ON ;# Trace Routing Agent
+set val(mactrc)         ON ;# Trace MAC Layer
+set val(movtrc)         ON ;# Trace Movement
+
+set val(mac_trace)      "" ;# dummy
+
+set val(ed)             " "
+set val(ve)             " "
+
+# =====================================================================
+# User defined Procedures
+# ======================================================================
+proc usage {} {
+    global argv0
+    puts "\nUsage: ns $argv0 -out tracefile\n"
+    puts "    NS Options:"
+    puts "     -nn           \[number of nodes\]"
+    puts "     -stop         \[simulation duration in secs\]"
+    puts "     -x / -y       \[dimension in meters\]"
+    puts "     -adhocRouting \[routing protocol to use\]"
+    puts "     -use_gk       \[radius for gridkeeper usage\]"
+    puts "     -zip          \[(0/1) should tracefiles be zipped on-the-fly\]"
+    puts "     -cc           \[alpha for congestion control ((MAC802_11 only)\]"
+    puts "     -ifqlen       \[max packets in interface queue\]"
+    puts ""
+    puts "    File Options:"
+    puts "     -cp      \[traffic pattern\]"
+    puts "     -sc      \[scenario file\]"
+    puts "     -on_off  \[wake/sleep pattern\]"
+    puts "     -lt      \[load trace file (MAC802_11 only)\]"
+    puts "     -pingLog \[log file for ping statistics (Ping Traffic only)\]"
+    puts ""
+    puts "    MAC Options:"
+    puts "     -rr           \[radio range in meters\]"
+    puts "     -bw           \[link/dataRate bandwidth in bits/sec\]"
+    puts "     -bs           \[basicRate bandwidth in bits/sec\]"
+    puts ""
+    puts "    GPSR Options:"
+    puts "     -bint         \[beacon interval (and beacon expiry)\]"
+    puts "     -use_planar   \[(0/1) planarize graph\]"
+    puts "     -use_peri     \[(0/1) use perimeter mode\]"
+    puts "     -use_mac      \[(0/1) use mac callback\]"
+    puts "     -verbose      \[(0/1) be verbose\]"
+    puts "     -use_beacon   \[(0/1) use beacons at all (disable beacons with 0)\]"
+    puts "     -use_reactive \[(0/1) use reactive beaconing\]"
+    puts "     -locs         \[locservice to use (0-Omni/1-RLS/2-GLS/3-HLS)\]"
+    puts "     -use_loop     \[(0/1) use loop detection\]"
+    puts ""
+    puts "     -ed           \[topology file (edges)\]"
+    puts "     -ve           \[topology file (verteces)\]"
+    puts ""
+}
+
+proc getopt {argc argv} {
+    global val
+    lappend optlist cp sc on_off om out pingLog nn stop x y adhocRouting mac_emu rr bw lt use_gk ifqlen ora
+    # HGPS
+    lappend optlist upd bint cval mgrid tper tqo
+    # GPSR
+    lappend optlist bint use_planar use_peri use_mac verbose use_beacon cc smooth_cc use_reactive use_loop
+    # CBF & LOCS
+    lappend optlist locs supt use_rec pkt_ret rev_ord use_la use_lazy use_uctf 
+    lappend use_randa use_sdd agg_mac agg_rtr agg_trc
+    # GSR
+    lappend optlist ed ve
+    lappend optlist seed mac_trace zip no_echo
+
+    for {set i 0} {$i < $argc} {incr i} {
+	set arg [lindex $argv $i]
+	if {[string range $arg 0 0] != "-"} continue
+	set name [string range $arg 1 end]
+	set val($name) [lindex $argv [expr $i+1]]
+    }
+    if { $val(out) == "" } {
+	usage
+	exit
+    }
+}
+
+proc printparams {} {
+    global val  
+    puts "\nParameterset:"
+    puts "Tracefile: \"$val(out)\""
+    puts "Protocol: $val(adhocRouting) nn: $val(nn) stop: $val(stop) x: $val(x) y: $val(y)"
+    puts "Radio Range: $val(rr)"
+
+    if { ($val(adhocRouting) == "GPSR") } {
+	if { $val(locs) == "0" } {
+	    puts "$val(adhocRouting)/OMNI: Omnipotent Location Service selected."
+	} elseif { $val(locs) == "1" } {
+	    puts "$val(adhocRouting)/RLS: Reactive Location Service selected."
+	} elseif { $val(locs) == "2" } {
+	    puts "$val(adhocRouting)/GLS: Grid Location Service selected."
+	} elseif { $val(locs) == "3" } {
+	    puts "$val(adhocRouting)/HLS: Cell Location Service selected."
+	} else {
+	    puts "$val(adhocRouting)/UKN: Unknown Location Service. Defaulting to Omnipotent Location Service."
+	}
+    }
+    if { $val(cc) != "" } {
+	puts "Using congestion control with alpha = $val(cc) ..."
+    }
+    puts ""
+}
+
+proc changeActiveState {nId on} {
+    global node_ val
+    if {$on == 0} {
+	#puts "Turning off node $nId"
+	if { ($val(adhocRouting) == "DSR")||($val(adhocRouting) == "GPSR")||($val(adhocRouting) == "AODV") } {
+	    set r [$node_($nId) set ragent_]
+	    $r sleep
+	}
+    } else {
+	#puts "Turning on node $nId"
+	if { ($val(adhocRouting) == "DSR")||($val(adhocRouting) == "GPSR")||($val(adhocRouting) == "AODV") } {
+	    set r [$node_($nId) set ragent_]
+	    $r wake
+	}
+    }
+}
+
+proc estimEnd {startTime simTime simEndTime} {
+    set now         [clock seconds]
+    set realGone    [expr $now - $startTime]
+    set simToGo     [expr $simEndTime - $simTime]
+    set percSimGone [expr ($simTime / $simEndTime) * 100]
+    set percSimToGo [expr 100 - $percSimGone]
+    if {$percSimGone == 0} {
+	set ete 0
+	set eteString "unknown"
+    } else {
+	set ete [expr $startTime + ($realGone / $percSimGone) * 100]
+    }
+    set eteString   [clock format [expr round($ete)]]
+    set sTimeString [clock format $startTime]
+    if {$ete != 0} {
+	puts "$simTime\tRun: $realGone ETE:\t$eteString"
+    } else {
+	puts "$simTime\tBeginn: $sTimeString!"
+    }
+}
+
+proc instEstim {startTime simEndTime step} {
+    global ns_
+    for {set t 1} {$t < $simEndTime } { set t [expr  $t + $step]} {
+	$ns_ at $t "estimEnd $startTime $t $simEndTime"
+    }
+}
+
+proc create_gridkeeper {} {
+    global gkeeper val node_
+ 
+    set gkeeper [new GridKeeper]
+ 
+    puts "Initializing GridKeeper with radius $val(use_gk) ..."
+    #initialize the gridkeeper
+ 
+    $gkeeper dimension $val(x) $val(y)
+ 
+    #
+    # add mobile node into the gridkeeper, must be added after
+    # scenario file
+    #
+
+    for {set i 0} {$i < $val(nn) } {incr i} {
+        $gkeeper addnode $node_($i)
+ 
+        $node_($i) radius $val(use_gk)
+    }
+ 
+}
+
+# =====================================================================
+# Main Program
+# ======================================================================
+getopt $argc $argv
+
+if { $val(adhocRouting) == "GPSR" } {
+    Agent/GPSR set locservice_type_ $val(locs)
+}
+
+# create trace object for ping
+if { $val(pingLog) != "" } {
+    set pingLog  [open $val(pingLog) w] 
+} else {
+    set pingLog  $val(pingLog)
+}
+
+# create trace object for MAC load
+if { $val(mac) == "Mac/802_11" } {
+    if { $val(lt) != "" } {
+	set loadTrace  [open $val(lt) w]
+        puts $loadTrace "# x=$val(x), y=$val(y), n=$val(nn), stop=$val(stop)"
+    } else {
+	set loadTrace  $val(lt)
+    }
+}
+
+# set up MAC load scanning
+if { $val(cc) != "" || $val(lt) != "" } {
+    Mac/802_11 set scan_int_	0.001	;# scanning interval
+    Mac/802_11 set scan_len_	200	;# scan count for each probe
+    if { $val(smooth_cc) == "1" } {
+	Mac/802_11 set smooth_scan_ 1	;# smooth the scanned values
+    }
+}
+
+# set up congestion control
+if { $val(cc) != "" } {
+    Agent/GPSR set use_congestion_control_ 1
+    Agent/GPSR set cc_alpha_ $val(cc)
+} else {
+    Agent/GPSR set cc_alpha_ 0
+}
+
+# set up headers as needed to save on memory
+add-all-packet-headers
+remove-all-packet-headers
+add-packet-header Common Flags IP LL Mac Message GPSR  LOCS SR RTP Ping HLS
+# PKT Types of special Interest: 
+# ARP TCP GPSR LOCS HGPS SR DSDV AODV TORA IMEP Message Ping RTP 
+puts "\n !Warning! Don't forget to check header-inclusion "
+puts "           (Not needed for GPSR/DSR & CBR/Ping)\n"
+
+# set dynamic options
+if { $val(mac_emu) == "1" } {
+    set val(mac)        Mac/Emu
+    set val(netif)      Phy/EmuPhy
+    if { $val(rr) != "" } {
+	God set rrange_ $val(rr)
+    } else {
+	set val(rr) [God set rrange_]
+    }
+    if { $val(bw) != "" } {
+	God set bandwidth_ $val(bw)
+    } else {
+	set val(bw) [God set bandwidth_]
+    }
+} else {
+    if { $val(bw) != "" } {
+	Phy/WirelessPhy set bandwidth_ $val(bw)
+	Mac/802_11 set dataRate_ $val(bw)
+    }
+    if { $val(bs) != "" } {
+	Mac/802_11 set basicRate_ $val(bs)
+    }
+    if { $val(rr) != "" } {
+	God set rrange_ $val(rr)
+	Mac/802_11 set rrange_ $val(rr)
+	if { $val(rr) >= [expr 9 * $PI * [Phy/WirelessPhy set freq_] / 3e8] } {
+	    Phy/WirelessPhy set Pt_ [expr [Phy/WirelessPhy set RXThresh_] * $val(rr)*$val(rr)*$val(rr)*$val(rr) / 5.0625]
+	} else {
+	    Phy/WirelessPhy set Pt_ [expr [Phy/WirelessPhy set RXThresh_] * 16 * $PI*$PI * $val(rr)*$val(rr) * [Phy/WirelessPhy set freq_]*[Phy/WirelessPhy set freq_] / 9e16]
+	}
+    } else {
+	set val(rr) 250			;# (Pt/Pr)^0.25 * 1.5
+    }
+}
+
+Agent/GPSR set bint_                  $val(bint)
+# Recalculating bexp_ here
+Agent/GPSR set bexp_                 [expr 3*([Agent/GPSR set bint_]+[Agent/GPSR set bdesync_]*[Agent/GPSR set bint_])] ;# beacon timeout interval
+Agent/GPSR set use_peri_              $val(use_peri)
+Agent/GPSR set use_planar_            $val(use_planar)
+Agent/GPSR set use_mac_               $val(use_mac)
+Agent/GPSR set use_beacon_            $val(use_beacon)
+Agent/GPSR set verbose_               $val(verbose)
+Agent/GPSR set use_reactive_beacon_   $val(use_reactive)
+Agent/GPSR set use_loop_detect_       $val(use_loop)
+
+CMUTrace set aggregate_mac_           $val(agg_mac)
+CMUTrace set aggregate_rtr_           $val(agg_rtr)
+God set shorten_trace_                $val(agg_trc)
+
+if { $val(movtrc) == "OFF" || $val(agg_trc) == 1} {
+Node/MobileNode set movtrace_ 0
+}
+
+# seeding RNG
+ns-random $val(seed)
+
+# set MACTRACE option
+if { $val(mac_trace) != "" } {
+    set val(mactrc)         $val(mac_trace)
+    puts "MAC trace is $val(mactrc)"
+}
+
+# create simulator instance
+set ns_		[new Simulator]
+
+# setup topography object
+set topo	[new Topography]
+$topo load_flatgrid $val(x) $val(y)
+
+# create trace object for ns and nam
+if { $val(zip) == "1" } {
+    set tracefd [open "|gzip -9c > $val(out).gz" w]
+} else {
+    set tracefd	[open $val(out) w]
+}
+$ns_ trace-all $tracefd
+
+# create channel
+set chanl [new $val(chan)]
+
+# Create God
+set god_ [create-god $val(nn)]
+
+# Attach Trace to God
+set T [new Trace/Generic]
+$T attach $tracefd
+$T set src_ -5
+$god_ tracetarget $T    
+
+#
+# Define Nodes
+#
+puts "Configuring Nodes ($val(nn))"
+$ns_ node-config -adhocRouting $val(adhocRouting) \
+                 -llType $val(ll) \
+                 -macType $val(mac) \
+                 -ifqType $val(ifq) \
+                 -ifqLen $val(ifqlen) \
+                 -antType $val(ant) \
+                 -propType $val(prop) \
+                 -phyType $val(netif) \
+                 -channel $chanl \
+		 -topoInstance $topo \
+                 -wiredRouting OFF \
+		 -mobileIP OFF \
+		 -agentTrace $val(agttrc) \
+                 -routerTrace $val(rtrtrc) \
+                 -macTrace $val(mactrc) \
+                 -movementTrace $val(movtrc)
+
+#
+#  Create the specified number of nodes [$val(nn)] and "attach" them
+#  to the channel. 
+for {set i 0} {$i < $val(nn) } {incr i} {
+    set node_($i) [$ns_ node]
+    $node_($i) random-motion 0		;# disable random motion
+
+    if { $val(adhocRouting) == "GPSR" || $val(adhocRouting) == "GSR" || $val(adhocRouting) == "CBF" || $val(adhocRouting) == "AODV" } {
+	set ragent [$node_($i) set ragent_]
+	$ragent install-tap [$node_($i) set mac_(0)]
+    }
+
+    if { $val(mac) == "Mac/802_11" } {      
+	# bind MAC load trace file
+	[$node_($i) set mac_(0)] load-trace $loadTrace
+    }
+
+    # Bring Nodes to God's Attention
+    $god_ new_node $node_($i)
+}
+
+
+# 
+# Define node movement model
+#
+puts "Loading scenario file ($val(sc))..."
+if {$val(sc) == ""} {
+    puts "  no scenario file specified"
+    exit
+} else {
+    source $val(sc)
+}
+
+# 
+# Define traffic model
+#
+puts "Loading connection pattern ($val(cp))..."
+if {$val(cp) == ""} {
+    puts "  no connection pattern specified"
+} else {
+    source $val(cp)
+}
+
+#
+# Define inactive pattern 
+#
+puts "Loading inactive pattern ($val(on_off))..."
+if { $val(on_off) == "" } {
+    puts "  no inactive pattern specified"
+} else {
+    source $val(on_off)
+}
+
+#
+# Tell nodes when the simulation ends
+#
+for {set i 0} {$i < $val(nn) } {incr i} {
+    $ns_ at $val(stop).0 "$node_($i) reset";
+}
+
+$ns_ at  $val(stop).0002 "puts \"NS EXITING... $val(out)\" ; $ns_ halt"
+
+# Print Parameterset
+printparams
+
+# start GridKeeper
+if { $val(use_gk) > 0 } {
+    create_gridkeeper
+}
+
+set startTime [clock seconds]
+puts "Installing Time Estimator ($startTime)!"
+instEstim $startTime $val(stop) 2.5
+
+puts $tracefd "M 0.0 nn $val(nn) x $val(x) y $val(y) rp $val(adhocRouting)"
+puts $tracefd "M 0.0 sc $val(sc) cp $val(cp) seed $val(seed)"
+puts $tracefd "M 0.0 prop $val(prop) ant $val(ant) mac $val(mac)"
+puts $tracefd "M 0.0 on_off $val(on_off)"
+
+puts "Starting Simulation..."
+$ns_ run
diff -u -r --new-file ./hls/utils/sc-x2000-y2000-n100-s30-t100-MRD ../../ns-2.33-hls_working/ns-2.33/hls/utils/sc-x2000-y2000-n100-s30-t100-MRD
--- ./hls/utils/sc-x2000-y2000-n100-s30-t100-MRD	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/sc-x2000-y2000-n100-s30-t100-MRD	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,980 @@
+#
+# nodes: 100, pause: 0.00, max speed: 30.00  max x = 2000.00, max y: 2000.00
+# model (mrd): 1 distribution 1 change rate 25.000
+#
+$node_(0) set X_ 488.915171465326
+$node_(0) set Y_ 1188.697251411754
+$node_(0) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(0) setdest 488.915171465326 1188.697251411754 0.000000000000"
+$node_(1) set X_ 1399.740184100674
+$node_(1) set Y_ 1439.993421732049
+$node_(1) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(1) setdest 1399.740184100674 1439.993421732049 0.000000000000"
+$node_(2) set X_ 960.716496786373
+$node_(2) set Y_ 761.502340829707
+$node_(2) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(2) setdest 960.716496786373 761.502340829707 0.000000000000"
+$node_(3) set X_ 1529.964491382856
+$node_(3) set Y_ 122.116028960622
+$node_(3) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(3) setdest 1529.964491382856 122.116028960622 0.000000000000"
+$node_(4) set X_ 1253.502810708121
+$node_(4) set Y_ 1626.000683342159
+$node_(4) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(4) setdest 1253.502810708121 1626.000683342159 0.000000000000"
+$node_(5) set X_ 1169.859971974685
+$node_(5) set Y_ 1839.404016278079
+$node_(5) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(5) setdest 1169.859971974685 1839.404016278079 0.000000000000"
+$node_(6) set X_ 1648.952922711547
+$node_(6) set Y_ 1962.679475732010
+$node_(6) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(6) setdest 1648.952922711547 1962.679475732010 0.000000000000"
+$node_(7) set X_ 1283.645180991917
+$node_(7) set Y_ 229.326069920626
+$node_(7) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(7) setdest 1283.645180991917 229.326069920626 0.000000000000"
+$node_(8) set X_ 149.213945112781
+$node_(8) set Y_ 1824.475642790987
+$node_(8) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(8) setdest 149.213945112781 1824.475642790987 0.000000000000"
+$node_(9) set X_ 1820.219253285181
+$node_(9) set Y_ 438.777578811263
+$node_(9) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(9) setdest 1820.219253285181 438.777578811263 0.000000000000"
+$node_(10) set X_ 1373.626517532525
+$node_(10) set Y_ 547.161387721834
+$node_(10) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(10) setdest 1373.626517532525 547.161387721834 0.000000000000"
+$node_(11) set X_ 224.521091919863
+$node_(11) set Y_ 1512.958096233771
+$node_(11) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(11) setdest 224.521091919863 1512.958096233771 0.000000000000"
+$node_(12) set X_ 1284.201087812350
+$node_(12) set Y_ 1572.460001355268
+$node_(12) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(12) setdest 1284.201087812350 1572.460001355268 0.000000000000"
+$node_(13) set X_ 403.905594936753
+$node_(13) set Y_ 431.316460306872
+$node_(13) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(13) setdest 403.905594936753 431.316460306872 0.000000000000"
+$node_(14) set X_ 536.662800929455
+$node_(14) set Y_ 1683.907697354893
+$node_(14) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(14) setdest 536.662800929455 1683.907697354893 0.000000000000"
+$node_(15) set X_ 1551.204279843722
+$node_(15) set Y_ 1099.596709521690
+$node_(15) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(15) setdest 1551.204279843722 1099.596709521690 0.000000000000"
+$node_(16) set X_ 1207.480964953165
+$node_(16) set Y_ 136.067039055938
+$node_(16) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(16) setdest 1207.480964953165 136.067039055938 0.000000000000"
+$node_(17) set X_ 106.713354780803
+$node_(17) set Y_ 1516.339895553825
+$node_(17) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(17) setdest 106.713354780803 1516.339895553825 0.000000000000"
+$node_(18) set X_ 1456.500759796474
+$node_(18) set Y_ 1415.943191397630
+$node_(18) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(18) setdest 1456.500759796474 1415.943191397630 0.000000000000"
+$node_(19) set X_ 980.348387300401
+$node_(19) set Y_ 715.016227510092
+$node_(19) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(19) setdest 980.348387300401 715.016227510092 0.000000000000"
+$node_(20) set X_ 450.189673858240
+$node_(20) set Y_ 328.608934811379
+$node_(20) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(20) setdest 450.189673858240 328.608934811379 0.000000000000"
+$node_(21) set X_ 763.161927127769
+$node_(21) set Y_ 458.529913428180
+$node_(21) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(21) setdest 763.161927127769 458.529913428180 0.000000000000"
+$node_(22) set X_ 1427.941636306929
+$node_(22) set Y_ 1422.274677284147
+$node_(22) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(22) setdest 1427.941636306929 1422.274677284147 0.000000000000"
+$node_(23) set X_ 655.201017405767
+$node_(23) set Y_ 1957.704119887109
+$node_(23) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(23) setdest 655.201017405767 1957.704119887109 0.000000000000"
+$node_(24) set X_ 1057.315761154835
+$node_(24) set Y_ 306.962667293844
+$node_(24) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(24) setdest 1057.315761154835 306.962667293844 0.000000000000"
+$node_(25) set X_ 722.124885475789
+$node_(25) set Y_ 748.280832183919
+$node_(25) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(25) setdest 722.124885475789 748.280832183919 0.000000000000"
+$node_(26) set X_ 1574.139137957274
+$node_(26) set Y_ 566.143044365392
+$node_(26) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(26) setdest 1574.139137957274 566.143044365392 0.000000000000"
+$node_(27) set X_ 1394.009833738894
+$node_(27) set Y_ 1129.898886217646
+$node_(27) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(27) setdest 1394.009833738894 1129.898886217646 0.000000000000"
+$node_(28) set X_ 1018.106103884102
+$node_(28) set Y_ 1309.592883249198
+$node_(28) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(28) setdest 1018.106103884102 1309.592883249198 0.000000000000"
+$node_(29) set X_ 1579.366603502440
+$node_(29) set Y_ 424.244466611642
+$node_(29) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(29) setdest 1579.366603502440 424.244466611642 0.000000000000"
+$node_(30) set X_ 1583.054947341510
+$node_(30) set Y_ 414.301373132886
+$node_(30) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(30) setdest 1583.054947341510 414.301373132886 0.000000000000"
+$node_(31) set X_ 1282.252732200162
+$node_(31) set Y_ 826.415225632291
+$node_(31) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(31) setdest 1282.252732200162 826.415225632291 0.000000000000"
+$node_(32) set X_ 571.390057420537
+$node_(32) set Y_ 1345.491573798809
+$node_(32) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(32) setdest 571.390057420537 1345.491573798809 0.000000000000"
+$node_(33) set X_ 212.357533927678
+$node_(33) set Y_ 1079.834910814229
+$node_(33) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(33) setdest 212.357533927678 1079.834910814229 0.000000000000"
+$node_(34) set X_ 1455.118309673886
+$node_(34) set Y_ 181.081979896580
+$node_(34) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(34) setdest 1455.118309673886 181.081979896580 0.000000000000"
+$node_(35) set X_ 723.207455617043
+$node_(35) set Y_ 943.055197188776
+$node_(35) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(35) setdest 723.207455617043 943.055197188776 0.000000000000"
+$node_(36) set X_ 1101.089144073788
+$node_(36) set Y_ 6.945424981765
+$node_(36) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(36) setdest 1101.089144073788 6.945424981765 0.000000000000"
+$node_(37) set X_ 304.153584218570
+$node_(37) set Y_ 1897.594231232830
+$node_(37) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(37) setdest 304.153584218570 1897.594231232830 0.000000000000"
+$node_(38) set X_ 738.926029441789
+$node_(38) set Y_ 1125.389483629580
+$node_(38) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(38) setdest 738.926029441789 1125.389483629580 0.000000000000"
+$node_(39) set X_ 969.272025324074
+$node_(39) set Y_ 554.414481567284
+$node_(39) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(39) setdest 969.272025324074 554.414481567284 0.000000000000"
+$node_(40) set X_ 1408.017734548135
+$node_(40) set Y_ 560.923799596375
+$node_(40) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(40) setdest 1408.017734548135 560.923799596375 0.000000000000"
+$node_(41) set X_ 100.828890244749
+$node_(41) set Y_ 616.046432909112
+$node_(41) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(41) setdest 100.828890244749 616.046432909112 0.000000000000"
+$node_(42) set X_ 1202.057510218661
+$node_(42) set Y_ 983.971311381932
+$node_(42) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(42) setdest 1202.057510218661 983.971311381932 0.000000000000"
+$node_(43) set X_ 1807.435149162562
+$node_(43) set Y_ 1576.123578557867
+$node_(43) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(43) setdest 1807.435149162562 1576.123578557867 0.000000000000"
+$node_(44) set X_ 1645.136467198495
+$node_(44) set Y_ 1819.447664479254
+$node_(44) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(44) setdest 1645.136467198495 1819.447664479254 0.000000000000"
+$node_(45) set X_ 1626.280709408693
+$node_(45) set Y_ 910.410474613050
+$node_(45) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(45) setdest 1626.280709408693 910.410474613050 0.000000000000"
+$node_(46) set X_ 1515.823610881401
+$node_(46) set Y_ 456.099428433529
+$node_(46) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(46) setdest 1515.823610881401 456.099428433529 0.000000000000"
+$node_(47) set X_ 776.205119343729
+$node_(47) set Y_ 1675.679498572652
+$node_(47) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(47) setdest 776.205119343729 1675.679498572652 0.000000000000"
+$node_(48) set X_ 144.165927553241
+$node_(48) set Y_ 982.360515162139
+$node_(48) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(48) setdest 144.165927553241 982.360515162139 0.000000000000"
+$node_(49) set X_ 49.260011755068
+$node_(49) set Y_ 1897.037611020019
+$node_(49) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(49) setdest 49.260011755068 1897.037611020019 0.000000000000"
+$node_(50) set X_ 1001.167971817534
+$node_(50) set Y_ 630.123225442979
+$node_(50) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(50) setdest 1001.167971817534 630.123225442979 0.000000000000"
+$node_(51) set X_ 1871.340438941495
+$node_(51) set Y_ 1633.402949769242
+$node_(51) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(51) setdest 1871.340438941495 1633.402949769242 0.000000000000"
+$node_(52) set X_ 1502.994371186643
+$node_(52) set Y_ 834.851867236890
+$node_(52) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(52) setdest 1502.994371186643 834.851867236890 0.000000000000"
+$node_(53) set X_ 1843.751739566159
+$node_(53) set Y_ 1949.668524008711
+$node_(53) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(53) setdest 1843.751739566159 1949.668524008711 0.000000000000"
+$node_(54) set X_ 1859.602854430625
+$node_(54) set Y_ 359.624065233899
+$node_(54) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(54) setdest 1859.602854430625 359.624065233899 0.000000000000"
+$node_(55) set X_ 402.728593437438
+$node_(55) set Y_ 649.432260270723
+$node_(55) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(55) setdest 402.728593437438 649.432260270723 0.000000000000"
+$node_(56) set X_ 1535.463898191367
+$node_(56) set Y_ 550.738264467337
+$node_(56) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(56) setdest 1535.463898191367 550.738264467337 0.000000000000"
+$node_(57) set X_ 1871.922907986527
+$node_(57) set Y_ 1422.970190150289
+$node_(57) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(57) setdest 1871.922907986527 1422.970190150289 0.000000000000"
+$node_(58) set X_ 1820.014666134427
+$node_(58) set Y_ 1000.277335891182
+$node_(58) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(58) setdest 1820.014666134427 1000.277335891182 0.000000000000"
+$node_(59) set X_ 1192.645396736544
+$node_(59) set Y_ 794.422009112400
+$node_(59) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(59) setdest 1192.645396736544 794.422009112400 0.000000000000"
+$node_(60) set X_ 1099.227310104942
+$node_(60) set Y_ 715.069908889633
+$node_(60) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(60) setdest 1099.227310104942 715.069908889633 0.000000000000"
+$node_(61) set X_ 722.920925200150
+$node_(61) set Y_ 127.334480243599
+$node_(61) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(61) setdest 722.920925200150 127.334480243599 0.000000000000"
+$node_(62) set X_ 765.468374980629
+$node_(62) set Y_ 1223.036978447651
+$node_(62) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(62) setdest 765.468374980629 1223.036978447651 0.000000000000"
+$node_(63) set X_ 768.600023169834
+$node_(63) set Y_ 1856.700097161786
+$node_(63) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(63) setdest 768.600023169834 1856.700097161786 0.000000000000"
+$node_(64) set X_ 624.555997929732
+$node_(64) set Y_ 906.347759030977
+$node_(64) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(64) setdest 624.555997929732 906.347759030977 0.000000000000"
+$node_(65) set X_ 964.139793004904
+$node_(65) set Y_ 296.899888739337
+$node_(65) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(65) setdest 964.139793004904 296.899888739337 0.000000000000"
+$node_(66) set X_ 1216.491111631976
+$node_(66) set Y_ 1569.752277739761
+$node_(66) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(66) setdest 1216.491111631976 1569.752277739761 0.000000000000"
+$node_(67) set X_ 771.261736702177
+$node_(67) set Y_ 592.165437687175
+$node_(67) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(67) setdest 771.261736702177 592.165437687175 0.000000000000"
+$node_(68) set X_ 982.105001481266
+$node_(68) set Y_ 238.460766899453
+$node_(68) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(68) setdest 982.105001481266 238.460766899453 0.000000000000"
+$node_(69) set X_ 176.203540175886
+$node_(69) set Y_ 1439.053892350725
+$node_(69) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(69) setdest 176.203540175886 1439.053892350725 0.000000000000"
+$node_(70) set X_ 1099.277367711967
+$node_(70) set Y_ 1556.388110175916
+$node_(70) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(70) setdest 1099.277367711967 1556.388110175916 0.000000000000"
+$node_(71) set X_ 1724.827087006270
+$node_(71) set Y_ 1181.034844497872
+$node_(71) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(71) setdest 1724.827087006270 1181.034844497872 0.000000000000"
+$node_(72) set X_ 1683.524558149936
+$node_(72) set Y_ 1008.738319449582
+$node_(72) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(72) setdest 1683.524558149936 1008.738319449582 0.000000000000"
+$node_(73) set X_ 1232.347635612548
+$node_(73) set Y_ 70.618833366533
+$node_(73) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(73) setdest 1232.347635612548 70.618833366533 0.000000000000"
+$node_(74) set X_ 524.425521378600
+$node_(74) set Y_ 11.746275365003
+$node_(74) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(74) setdest 524.425521378600 11.746275365003 0.000000000000"
+$node_(75) set X_ 703.507423092313
+$node_(75) set Y_ 1844.276536518406
+$node_(75) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(75) setdest 703.507423092313 1844.276536518406 0.000000000000"
+$node_(76) set X_ 1150.178305112768
+$node_(76) set Y_ 1049.299050616727
+$node_(76) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(76) setdest 1150.178305112768 1049.299050616727 0.000000000000"
+$node_(77) set X_ 594.902857424611
+$node_(77) set Y_ 525.517263175400
+$node_(77) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(77) setdest 594.902857424611 525.517263175400 0.000000000000"
+$node_(78) set X_ 1031.225810692342
+$node_(78) set Y_ 1812.725220942581
+$node_(78) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(78) setdest 1031.225810692342 1812.725220942581 0.000000000000"
+$node_(79) set X_ 918.648675789744
+$node_(79) set Y_ 1726.926813119170
+$node_(79) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(79) setdest 918.648675789744 1726.926813119170 0.000000000000"
+$node_(80) set X_ 654.901646857372
+$node_(80) set Y_ 926.179312798227
+$node_(80) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(80) setdest 654.901646857372 926.179312798227 0.000000000000"
+$node_(81) set X_ 1093.093872559918
+$node_(81) set Y_ 1630.281084182583
+$node_(81) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(81) setdest 1093.093872559918 1630.281084182583 0.000000000000"
+$node_(82) set X_ 530.446871569842
+$node_(82) set Y_ 1212.678944855092
+$node_(82) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(82) setdest 530.446871569842 1212.678944855092 0.000000000000"
+$node_(83) set X_ 687.104949051000
+$node_(83) set Y_ 167.621309715339
+$node_(83) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(83) setdest 687.104949051000 167.621309715339 0.000000000000"
+$node_(84) set X_ 926.789916138793
+$node_(84) set Y_ 556.891366868867
+$node_(84) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(84) setdest 926.789916138793 556.891366868867 0.000000000000"
+$node_(85) set X_ 1526.656464844163
+$node_(85) set Y_ 524.057990193069
+$node_(85) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(85) setdest 1526.656464844163 524.057990193069 0.000000000000"
+$node_(86) set X_ 521.247200005222
+$node_(86) set Y_ 593.644950151467
+$node_(86) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(86) setdest 521.247200005222 593.644950151467 0.000000000000"
+$node_(87) set X_ 1832.443033328811
+$node_(87) set Y_ 1884.052782868825
+$node_(87) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(87) setdest 1832.443033328811 1884.052782868825 0.000000000000"
+$node_(88) set X_ 1097.125997019961
+$node_(88) set Y_ 1398.264887729463
+$node_(88) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(88) setdest 1097.125997019961 1398.264887729463 0.000000000000"
+$node_(89) set X_ 66.715290897902
+$node_(89) set Y_ 1268.208180158956
+$node_(89) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(89) setdest 66.715290897902 1268.208180158956 0.000000000000"
+$node_(90) set X_ 854.471607728754
+$node_(90) set Y_ 1101.865855148755
+$node_(90) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(90) setdest 854.471607728754 1101.865855148755 0.000000000000"
+$node_(91) set X_ 659.280957781641
+$node_(91) set Y_ 529.332020889097
+$node_(91) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(91) setdest 659.280957781641 529.332020889097 0.000000000000"
+$node_(92) set X_ 544.923227165853
+$node_(92) set Y_ 517.031459895197
+$node_(92) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(92) setdest 544.923227165853 517.031459895197 0.000000000000"
+$node_(93) set X_ 1032.640805849768
+$node_(93) set Y_ 1594.572833076636
+$node_(93) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(93) setdest 1032.640805849768 1594.572833076636 0.000000000000"
+$node_(94) set X_ 733.533744180055
+$node_(94) set Y_ 497.161084916551
+$node_(94) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(94) setdest 733.533744180055 497.161084916551 0.000000000000"
+$node_(95) set X_ 797.166731342845
+$node_(95) set Y_ 1977.844386290162
+$node_(95) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(95) setdest 797.166731342845 1977.844386290162 0.000000000000"
+$node_(96) set X_ 1277.147213911020
+$node_(96) set Y_ 1017.883335472221
+$node_(96) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(96) setdest 1277.147213911020 1017.883335472221 0.000000000000"
+$node_(97) set X_ 823.856799395518
+$node_(97) set Y_ 558.268171319651
+$node_(97) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(97) setdest 823.856799395518 558.268171319651 0.000000000000"
+$node_(98) set X_ 1885.314589585691
+$node_(98) set Y_ 497.188839232854
+$node_(98) set Z_ 0.000000000000
+$ns_ at 0.000000000 "$node_(98) setdest 1885.314589585691 497.188839232854 0.000000000000"
+$node_(99) set X_ 1832.607423706101
+$node_(99) set Y_ 646.965854200275
+$node_(99) set Z_ 0.000000000000
+$ns_ at 0.000000000000 "$node_(0) setdest 496.023898074811 1224.657754149097 20.973466331417"
+$ns_ at 0.000000000000 "$node_(1) setdest 1643.770515243558 1422.202932132454 10.064531834295"
+$ns_ at 0.000000000000 "$node_(2) setdest 960.169153844240 764.110899085324 29.723332764746"
+$ns_ at 0.000000000000 "$node_(3) setdest 1708.512559338687 614.864899918389 25.629337151872"
+$ns_ at 0.000000000000 "$node_(4) setdest 1581.258838788419 1870.492661023789 11.330496408067"
+$ns_ at 0.000000000000 "$node_(5) setdest 830.111602227688 1977.126746937763 9.724080454848"
+$ns_ at 0.000000000000 "$node_(6) setdest 1606.587327009956 1999.999000000000 23.658743738652"
+$ns_ at 0.000000000000 "$node_(7) setdest 1679.373802254217 679.059001052293 15.148671792555"
+$ns_ at 0.000000000000 "$node_(8) setdest 296.712526344143 1813.327323256085 6.198269694809"
+$ns_ at 0.000000000000 "$node_(9) setdest 1755.697122555210 1247.723638577176 19.579036644362"
+$ns_ at 0.000000000000 "$node_(10) setdest 1819.278315029562 746.417274163060 19.983617364298"
+$ns_ at 0.000000000000 "$node_(11) setdest 589.374474633191 1999.999000000000 28.213049543563"
+$ns_ at 0.000000000000 "$node_(12) setdest 1312.101164844468 1625.100285978156 2.321377919083"
+$ns_ at 0.000000000000 "$node_(13) setdest 0.001000000000 262.240555514965 28.353422393622"
+$ns_ at 0.000000000000 "$node_(14) setdest 382.577622530081 746.068611324700 19.734568683197"
+$ns_ at 0.000000000000 "$node_(15) setdest 1434.208050265566 1128.240807607630 7.076230927498"
+$ns_ at 0.000000000000 "$node_(16) setdest 966.939829300527 245.399225898200 10.501879914343"
+$ns_ at 0.000000000000 "$node_(17) setdest 16.403283659221 1476.141215433361 21.617941548660"
+$ns_ at 0.000000000000 "$node_(18) setdest 1999.999000000000 918.926032041159 16.121798136409"
+$ns_ at 0.000000000000 "$node_(19) setdest 838.174001794215 550.709548930245 6.220084436012"
+$ns_ at 0.000000000000 "$node_(20) setdest 203.681039089615 392.658641021266 15.567312219088"
+$ns_ at 0.000000000000 "$node_(21) setdest 761.371203229891 639.197105395385 7.865400284982"
+$ns_ at 0.000000000000 "$node_(22) setdest 1500.103576725374 1467.310301751772 13.735569446431"
+$ns_ at 0.000000000000 "$node_(23) setdest 121.941723895027 1687.595011206713 19.359107910266"
+$ns_ at 0.000000000000 "$node_(24) setdest 977.043550354943 278.090924029464 1.740311226595"
+$ns_ at 0.000000000000 "$node_(25) setdest 848.949127531268 1000.541208145051 19.495965334254"
+$ns_ at 0.000000000000 "$node_(26) setdest 1481.956507639426 515.896057059207 13.217990459744"
+$ns_ at 0.000000000000 "$node_(27) setdest 1999.999000000000 1608.440409191986 29.088844920411"
+$ns_ at 0.000000000000 "$node_(28) setdest 1036.576500932106 1341.459563275545 18.845788816320"
+$ns_ at 0.000000000000 "$node_(29) setdest 1669.140213517516 524.205099769024 10.687067475857"
+$ns_ at 0.000000000000 "$node_(30) setdest 1550.404910227590 397.232159185986 1.461006152115"
+$ns_ at 0.000000000000 "$node_(31) setdest 1348.328003576417 466.416679924648 24.251148659504"
+$ns_ at 0.000000000000 "$node_(32) setdest 798.131713296586 994.787209443760 14.237972201139"
+$ns_ at 0.000000000000 "$node_(33) setdest 0.001000000000 1248.122585554127 28.179773960721"
+$ns_ at 0.000000000000 "$node_(34) setdest 1451.669163130045 165.403379936387 0.586447580960"
+$ns_ at 0.000000000000 "$node_(35) setdest 861.676597159054 911.071103012892 23.627869864437"
+$ns_ at 0.000000000000 "$node_(36) setdest 1069.698437667510 46.110435949342 2.064293968412"
+$ns_ at 0.000000000000 "$node_(37) setdest 212.829862106016 1933.310554676527 8.177378171706"
+$ns_ at 0.000000000000 "$node_(38) setdest 744.447332524218 1147.815412997704 0.697320895557"
+$ns_ at 0.000000000000 "$node_(39) setdest 970.829768413409 554.594899922992 13.067773665109"
+$ns_ at 0.000000000000 "$node_(40) setdest 1299.043658321265 0.001000000000 29.116388524797"
+$ns_ at 0.000000000000 "$node_(41) setdest 238.244564763478 564.587231664142 16.248909278962"
+$ns_ at 0.000000000000 "$node_(42) setdest 1228.489139989771 907.213234929104 10.176401882909"
+$ns_ at 0.000000000000 "$node_(43) setdest 1999.999000000000 1525.822467792616 16.083286881568"
+$ns_ at 0.000000000000 "$node_(44) setdest 1568.297340439741 987.868395922197 23.509330265617"
+$ns_ at 0.000000000000 "$node_(45) setdest 1529.491138698417 802.455109587935 3.228829844325"
+$ns_ at 0.000000000000 "$node_(46) setdest 1626.798029729086 244.827293124461 29.755745346836"
+$ns_ at 0.000000000000 "$node_(47) setdest 578.153220553489 1569.466186180805 7.371231800195"
+$ns_ at 0.000000000000 "$node_(48) setdest 137.345285582532 1048.150335781011 2.401768514947"
+$ns_ at 0.000000000000 "$node_(49) setdest 100.709247846306 1273.539438782066 14.320593319227"
+$ns_ at 0.000000000000 "$node_(50) setdest 1027.149756266338 958.067191333834 8.039183233459"
+$ns_ at 0.000000000000 "$node_(51) setdest 1734.098621866316 1999.999000000000 28.478860368603"
+$ns_ at 0.000000000000 "$node_(52) setdest 1399.535429153118 627.704048454535 6.569949782372"
+$ns_ at 0.000000000000 "$node_(53) setdest 1895.669285744862 1965.612926847713 1.110213096712"
+$ns_ at 0.000000000000 "$node_(54) setdest 1954.510609395350 424.517176879071 7.322509710906"
+$ns_ at 0.000000000000 "$node_(55) setdest 133.760746099392 647.651889417114 6.172198902570"
+$ns_ at 0.000000000000 "$node_(56) setdest 1572.469179021210 587.850804847312 22.380044329838"
+$ns_ at 0.000000000000 "$node_(57) setdest 1999.999000000000 1366.153900377311 4.233396232013"
+$ns_ at 0.000000000000 "$node_(58) setdest 1999.999000000000 675.766392761636 24.272600492240"
+$ns_ at 0.000000000000 "$node_(59) setdest 1596.884359924538 584.037722930261 11.642975197324"
+$ns_ at 0.000000000000 "$node_(60) setdest 1145.094246791499 743.211012654662 1.363341599334"
+$ns_ at 0.000000000000 "$node_(61) setdest 1021.712418938108 220.224237596859 7.625074147601"
+$ns_ at 0.000000000000 "$node_(62) setdest 767.125726350896 1217.070613816406 0.658989586208"
+$ns_ at 0.000000000000 "$node_(63) setdest 780.486590370854 1805.733374878037 4.328985160141"
+$ns_ at 0.000000000000 "$node_(64) setdest 365.106966844008 918.409215985440 7.078718089627"
+$ns_ at 0.000000000000 "$node_(65) setdest 1630.834586760274 264.647554890388 20.933487908244"
+$ns_ at 0.000000000000 "$node_(66) setdest 1103.513149019569 1633.673028519341 7.310088317134"
+$ns_ at 0.000000000000 "$node_(67) setdest 765.917374551608 688.410204936447 3.981348645655"
+$ns_ at 0.000000000000 "$node_(68) setdest 1304.551415844212 0.001000000000 20.910148624582"
+$ns_ at 0.000000000000 "$node_(69) setdest 181.662415754671 1442.667982760295 9.144429675354"
+$ns_ at 0.000000000000 "$node_(70) setdest 1166.529888725298 1613.579290984232 2.277221424514"
+$ns_ at 0.000000000000 "$node_(71) setdest 1806.607158035934 1027.368244908808 13.991043317320"
+$ns_ at 0.000000000000 "$node_(72) setdest 1981.926332047050 874.098129983550 6.686462553185"
+$ns_ at 0.000000000000 "$node_(73) setdest 1227.597306099873 72.584520590870 0.193724194622"
+$ns_ at 0.000000000000 "$node_(74) setdest 520.732904304470 0.001000000000 13.518463667476"
+$ns_ at 0.000000000000 "$node_(75) setdest 621.911670329351 1916.239902862590 5.892846875463"
+$ns_ at 0.000000000000 "$node_(76) setdest 1201.700625719956 818.710301067768 8.097668046681"
+$ns_ at 0.000000000000 "$node_(77) setdest 1033.500140281489 1462.683994619559 26.210131893511"
+$ns_ at 0.000000000000 "$node_(78) setdest 1039.202916912157 1999.999000000000 26.345287651456"
+$ns_ at 0.000000000000 "$node_(79) setdest 943.451765211827 1999.999000000000 13.581011259016"
+$ns_ at 0.000000000000 "$node_(80) setdest 1131.639945243981 1558.939400178360 17.438999104994"
+$ns_ at 0.000000000000 "$node_(81) setdest 1570.058859839778 1863.528592302416 18.866358383898"
+$ns_ at 0.000000000000 "$node_(82) setdest 527.808149865995 611.979318118018 14.995182716891"
+$ns_ at 0.000000000000 "$node_(83) setdest 645.674441119235 138.041613581122 1.131492485759"
+$ns_ at 0.000000000000 "$node_(84) setdest 936.246568125529 540.403221132102 5.447854667357"
+$ns_ at 0.000000000000 "$node_(85) setdest 1999.999000000000 253.363092827606 12.541024387404"
+$ns_ at 0.000000000000 "$node_(86) setdest 504.317921895224 549.328591125843 5.026813971092"
+$ns_ at 0.000000000000 "$node_(87) setdest 1777.878198600564 1813.716600277909 10.820785150674"
+$ns_ at 0.000000000000 "$node_(88) setdest 1025.389222629799 1545.091173194785 12.754071970148"
+$ns_ at 0.000000000000 "$node_(89) setdest 0.001000000000 1323.613725993215 18.830931641486"
+$ns_ at 0.000000000000 "$node_(90) setdest 490.248554909405 1031.033138030920 8.831749133687"
+$ns_ at 0.000000000000 "$node_(91) setdest 686.883973116669 885.279787542272 21.900385617939"
+$ns_ at 0.000000000000 "$node_(92) setdest 794.020108305745 251.150990557455 29.334649371919"
+$ns_ at 0.000000000000 "$node_(93) setdest 1049.145546618674 1594.344669724630 0.720161372162"
+$ns_ at 0.000000000000 "$node_(94) setdest 1029.629809372053 248.906070237786 18.339539564336"
+$ns_ at 0.000000000000 "$node_(95) setdest 991.823335238053 1586.853370894176 26.207532539608"
+$ns_ at 0.000000000000 "$node_(96) setdest 1489.677758574705 0.001000000000 25.608718172976"
+$ns_ at 0.000000000000 "$node_(97) setdest 695.412010143812 648.100312876096 28.982759851821"
+$ns_ at 0.000000000000 "$node_(98) setdest 1999.999000000000 607.886932012419 17.068273199319"
+$ns_ at 0.000000000000 "$node_(99) setdest 1933.366049607777 0.001000000000 15.687883507418"
+$ns_ at 0.089672417417 "$node_(2) setdest 1027.597213927510 848.260130087729 23.063771357038"
+$ns_ at 0.120001798545 "$node_(39) setdest 647.982368673640 1082.143779165235 22.755774846383"
+$ns_ at 0.715936301572 "$node_(69) setdest 0.001000000000 1175.980214482706 21.039164750210"
+$ns_ at 0.910759097484 "$node_(74) setdest 424.288508988277 306.766082232897 13.518463667476"
+$ns_ at 1.747751213400 "$node_(0) setdest 307.466819566137 1237.600085227474 5.532843212087"
+$ns_ at 1.954421029302 "$node_(28) setdest 1292.395348757983 1274.206121995596 10.159196881115"
+$ns_ at 2.341785748525 "$node_(56) setdest 1631.449957290516 691.803114340743 7.472457711876"
+$ns_ at 2.386379930238 "$node_(6) setdest 1278.918461872971 1711.358041178659 23.658743738652"
+$ns_ at 3.488998512315 "$node_(84) setdest 1082.114912384527 0.001000000000 14.147355417974"
+$ns_ at 4.572712515506 "$node_(17) setdest 182.952497905468 1556.548900954074 3.894715976647"
+$ns_ at 4.605254169777 "$node_(89) setdest 451.618606643763 1698.677594134345 18.830931641486"
+$ns_ at 4.765036075481 "$node_(2) setdest 801.046981776833 729.689392805385 8.128093978021"
+$ns_ at 5.408092124758 "$node_(97) setdest 959.562266958462 387.533546164227 11.781929871275"
+$ns_ at 6.014720911781 "$node_(35) setdest 1006.168752880233 322.070528682411 22.386282770824"
+$ns_ at 6.192830580050 "$node_(22) setdest 1355.234227412612 1245.033143859085 6.123995639118"
+$ns_ at 7.114881446213 "$node_(78) setdest 1059.721841991520 1518.288397693722 26.345287651456"
+$ns_ at 7.942781065145 "$node_(26) setdest 1590.436539053423 421.973616417011 5.548611667435"
+$ns_ at 7.977425124065 "$node_(42) setdest 926.666827863057 846.326213857381 29.050774036794"
+$ns_ at 8.020117789093 "$node_(46) setdest 1771.356177758057 113.113012854179 11.761764520979"
+$ns_ at 8.226728303029 "$node_(87) setdest 1671.699155052710 1999.999000000000 15.585726170716"
+$ns_ at 9.030443224128 "$node_(41) setdest 16.735458470902 574.077309426605 29.070302613906"
+$ns_ at 9.338637837117 "$node_(98) setdest 1982.304785863437 624.966112618350 17.068273199319"
+$ns_ at 9.396626641197 "$node_(62) setdest 765.941190981216 1216.399109971832 0.223338967281"
+$ns_ at 9.437360990964 "$node_(86) setdest 497.025121120772 596.282606292904 27.579641442026"
+$ns_ at 9.615192190862 "$node_(33) setdest 62.277294535497 1297.475118320391 28.179773960721"
+$ns_ at 10.779460151474 "$node_(98) setdest 1929.142466010582 659.774729006872 24.320316990634"
+$ns_ at 11.160261980209 "$node_(86) setdest 725.500975155573 858.539203428454 21.579084372676"
+$ns_ at 11.991565190550 "$node_(37) setdest 359.601845104906 1716.532592570946 7.967496545550"
+$ns_ at 12.089317227117 "$node_(63) setdest 533.196494664592 991.117984921774 26.490110216424"
+$ns_ at 12.374660848977 "$node_(43) setdest 1886.458782470160 1496.163738838859 16.083286881568"
+$ns_ at 12.420033109846 "$node_(92) setdest 1029.657162466402 0.001000000000 27.286252772526"
+$ns_ at 12.434971407533 "$node_(33) setdest 338.798007198923 1072.464943628101 26.901764214901"
+$ns_ at 12.441744357828 "$node_(71) setdest 1999.999000000000 1368.652135112304 21.394355049808"
+$ns_ at 12.571793683407 "$node_(29) setdest 1691.514521840050 503.904807834039 0.770721668696"
+$ns_ at 12.812689324543 "$node_(88) setdest 1078.508722415429 1478.693015512564 4.500585237513"
+$ns_ at 13.392265425936 "$node_(98) setdest 1901.392529877827 899.193131632005 12.318780222406"
+$ns_ at 13.745053432867 "$node_(51) setdest 1468.515714848251 1290.582243529252 28.478860368603"
+$ns_ at 14.482316846419 "$node_(25) setdest 1000.685075885714 1091.549817522412 4.503098425452"
+$ns_ at 15.092569665695 "$node_(31) setdest 1413.602660153017 770.698046656180 14.755319484082"
+$ns_ at 15.288094659378 "$node_(58) setdest 1991.686631204052 660.779229269794 24.272600492240"
+$ns_ at 15.443102221626 "$node_(13) setdest 292.247017548482 139.905329676352 28.353422393622"
+$ns_ at 15.493332135369 "$node_(62) setdest 751.776681310101 1236.801521769116 1.582044368332"
+$ns_ at 15.701196162925 "$node_(54) setdest 1965.621870745897 390.377523819101 27.572486537717"
+$ns_ at 15.994157672013 "$node_(58) setdest 1959.582681116490 854.333304162613 12.711326289582"
+$ns_ at 16.053109904781 "$node_(69) setdest 316.637935960606 711.141836697377 21.039164750210"
+$ns_ at 16.301833542275 "$node_(91) setdest 395.353795464403 19.125996547700 23.552286653259"
+$ns_ at 16.360800044847 "$node_(20) setdest 0.001000000000 367.801955381130 10.050758984364"
+$ns_ at 16.657206073761 "$node_(41) setdest 0.001000000000 547.684418530663 21.076766764134"
+$ns_ at 16.665694077861 "$node_(95) setdest 1271.512982916292 1598.119851589284 20.790032627263"
+$ns_ at 17.003302609118 "$node_(54) setdest 1811.233484879123 0.001000000000 25.579344799127"
+$ns_ at 17.022007897074 "$node_(15) setdest 1450.911292708089 1033.362284551631 11.675786911674"
+$ns_ at 17.757254264198 "$node_(66) setdest 1420.016779002613 1468.500902410647 12.060317797909"
+$ns_ at 18.139930107070 "$node_(41) setdest 347.260626038628 0.001000000000 21.076766764134"
+$ns_ at 18.336402632416 "$node_(56) setdest 1517.782480972860 744.838364807935 22.305192719110"
+$ns_ at 18.462401892231 "$node_(75) setdest 995.562599806308 1799.417306843281 13.152725580922"
+$ns_ at 18.576195401359 "$node_(42) setdest 825.789992975341 661.067886253614 13.998276997549"
+$ns_ at 19.179303217369 "$node_(68) setdest 1454.750831105310 111.078425445582 20.910148624582"
+$ns_ at 19.625040525979 "$node_(40) setdest 1138.318215215817 827.303865365758 29.116388524797"
+$ns_ at 19.671054634937 "$node_(43) setdest 1907.845779246645 1652.088628063759 3.833797296229"
+$ns_ at 20.189682315515 "$node_(79) setdest 951.523917725316 1911.127799232105 13.581011259016"
+$ns_ at 20.449223750332 "$node_(3) setdest 1761.330411434955 459.231471634052 12.621991588357"
+$ns_ at 20.843394179121 "$node_(6) setdest 1203.000085188834 1952.623257203172 6.637880776955"
+$ns_ at 21.069123441670 "$node_(94) setdest 1499.792177804870 1173.863960982353 24.427053388980"
+$ns_ at 21.569623223843 "$node_(11) setdest 977.913458270936 1481.340309399278 28.213049543563"
+$ns_ at 21.984066135631 "$node_(87) setdest 1529.619097501775 1750.731223715010 15.585726170716"
+$ns_ at 22.920304266886 "$node_(93) setdest 923.027862878867 1652.652335472408 3.171671606978"
+$ns_ at 22.970994454980 "$node_(21) setdest 231.528914162367 740.005993076137 17.274274618978"
+$ns_ at 23.864610246923 "$node_(8) setdest 385.255562450302 1691.601209515557 13.285940243760"
+$ns_ at 23.959819074368 "$node_(56) setdest 1517.682190224822 747.905133249570 5.852937141987"
+$ns_ at 24.211151744922 "$node_(67) setdest 494.277600631635 1137.696659639035 10.850778324353"
+$ns_ at 24.310913203077 "$node_(1) setdest 1803.027539339017 1253.387903489649 6.491429231016"
+$ns_ at 24.314548224936 "$node_(36) setdest 1100.596676899220 66.334817984057 8.714377497196"
+$ns_ at 24.428432468166 "$node_(10) setdest 1262.165412330528 1315.630162782247 26.693514768811"
+$ns_ at 24.484070028043 "$node_(56) setdest 1613.402180679927 1280.834127761908 11.211339160772"
+$ns_ at 24.647308663397 "$node_(46) setdest 1999.999000000000 210.254129815975 19.582462006883"
+$ns_ at 24.698118759272 "$node_(74) setdest 695.769817746559 350.884608433943 28.035097659965"
+$ns_ at 25.041229716594 "$node_(92) setdest 1417.919034077263 413.823714497201 27.286252772526"
+$ns_ at 25.159549467409 "$node_(16) setdest 978.848297962539 258.234479727760 0.545561718980"
+$ns_ at 25.217333167027 "$node_(30) setdest 1492.153448023377 376.519943569949 9.508770219251"
+$ns_ at 25.273066001203 "$node_(15) setdest 540.472275659330 972.226108457894 25.560267727199"
+$ns_ at 25.415968998584 "$node_(78) setdest 1041.582165483410 1554.551898735240 13.098224392912"
+$ns_ at 25.664480134265 "$node_(12) setdest 1410.681953947417 1503.393570707276 10.058864899407"
+$ns_ at 25.686944263417 "$node_(33) setdest 0.001000000000 1033.647265132184 19.442724882271"
+$ns_ at 26.537565292571 "$node_(73) setdest 1176.287442788407 156.672445431936 8.561129513006"
+$ns_ at 26.544745348623 "$node_(27) setdest 1988.974283973822 1617.146479681790 29.088844920411"
+$ns_ at 26.616991252452 "$node_(13) setdest 313.102089289913 144.627574641372 19.238452244111"
+$ns_ at 26.760403892830 "$node_(79) setdest 954.754555099423 1976.699869854270 2.019961970761"
+$ns_ at 27.027671935020 "$node_(27) setdest 1999.999000000000 1623.356584870369 6.082847451509"
+$ns_ at 27.278713148174 "$node_(86) setdest 791.069107688246 882.693881571773 4.443353099720"
+$ns_ at 27.299774030319 "$node_(39) setdest 866.643132655473 1904.500231237324 17.603320253830"
+$ns_ at 27.374156179964 "$node_(34) setdest 951.903356916282 6.972246592430 20.105054209859"
+$ns_ at 27.539054734827 "$node_(48) setdest 871.593892679482 945.340760734618 26.313256725357"
+$ns_ at 27.728464326163 "$node_(13) setdest 139.523559042614 0.001000000000 19.961835745582"
+$ns_ at 27.991070889318 "$node_(28) setdest 1368.672872068466 1254.357766636430 1.633185935881"
+$ns_ at 28.113253170124 "$node_(68) setdest 1721.368259944911 92.488949630269 23.910079533793"
+$ns_ at 28.142291505333 "$node_(81) setdest 1570.051502447669 1854.717581644775 0.491506867314"
+$ns_ at 28.511607821695 "$node_(78) setdest 716.190294297347 1406.315362506572 28.451094224689"
+$ns_ at 28.552220051790 "$node_(36) setdest 972.126676482763 107.179569469589 2.720279270975"
+$ns_ at 29.107857084213 "$node_(27) setdest 1795.344319837967 1738.636387826152 6.082847451509"
+$ns_ at 29.178112920313 "$node_(76) setdest 1290.856684696105 777.355540291251 7.770428320807"
+$ns_ at 29.331328615549 "$node_(32) setdest 743.264855388216 1019.435585685423 2.769264719661"
+$ns_ at 30.129668827501 "$node_(95) setdest 1298.014566935174 1461.400521354625 12.081092191260"
+$ns_ at 30.488120683950 "$node_(47) setdest 558.487764715276 1684.763331930346 19.317167423259"
+$ns_ at 30.776915698526 "$node_(71) setdest 1755.220440921338 1800.619575064060 21.394355049808"
+$ns_ at 30.877775036440 "$node_(23) setdest 111.531999793472 1999.999000000000 25.466874578307"
+$ns_ at 31.192832057205 "$node_(62) setdest 848.658654798260 1999.999000000000 29.898098714887"
+$ns_ at 31.429091481430 "$node_(58) setdest 1867.385559241356 1146.490059236904 12.806232735214"
+$ns_ at 31.706174126878 "$node_(88) setdest 1486.985010202629 958.743471767512 14.579473511747"
+$ns_ at 31.719138812331 "$node_(30) setdest 1430.317205492311 369.909479376838 11.222307663388"
+$ns_ at 31.885487389877 "$node_(65) setdest 1999.999000000000 236.134618693632 24.250379801496"
+$ns_ at 32.957613598193 "$node_(98) setdest 1584.888497314799 0.001000000000 28.212946683641"
+$ns_ at 33.097002696484 "$node_(57) setdest 1994.631225498013 1363.772682878038 4.233396232013"
+$ns_ at 33.105636075769 "$node_(35) setdest 959.320189209519 395.663208403499 4.193638462442"
+$ns_ at 33.120487085248 "$node_(38) setdest 1380.140852848002 1748.763203787280 22.140400213949"
+$ns_ at 33.414868345152 "$node_(54) setdest 1776.722487521333 87.263284053477 25.579344799127"
+$ns_ at 33.470284952631 "$node_(3) setdest 1792.458308200822 436.469810772322 3.334737803301"
+$ns_ at 33.645379114818 "$node_(42) setdest 793.570893986268 702.382296605477 13.146450357352"
+$ns_ at 33.803280247362 "$node_(26) setdest 1585.652189306431 0.001000000000 27.688036758709"
+$ns_ at 34.484125338763 "$node_(57) setdest 1963.363102753168 1364.973274102653 25.277012122055"
+$ns_ at 34.508778588193 "$node_(74) setdest 707.227280116466 0.001000000000 16.905042564026"
+$ns_ at 34.931869283771 "$node_(19) setdest 1518.903764087206 544.471862433758 14.693746526273"
+$ns_ at 35.194091350401 "$node_(8) setdest 302.388684517922 1999.999000000000 27.548899219570"
+$ns_ at 35.243330258526 "$node_(52) setdest 1229.523786478814 173.177313092028 24.535126281788"
+$ns_ at 35.522991806034 "$node_(44) setdest 1567.965165103528 986.878622030125 3.698469052687"
+$ns_ at 35.722055021521 "$node_(57) setdest 1999.999000000000 1398.386705724435 27.240085780692"
+$ns_ at 35.780191925226 "$node_(89) setdest 659.974312095407 1999.999000000000 14.327690360464"
+$ns_ at 35.805278123238 "$node_(44) setdest 1856.781816257742 740.903897392740 28.647465075087"
+$ns_ at 35.907535316347 "$node_(0) setdest 47.498493646815 1287.481285589792 12.465207446857"
+$ns_ at 36.088567381724 "$node_(4) setdest 1667.337767765755 1657.166747132412 4.646260856706"
+$ns_ at 36.183539769650 "$node_(31) setdest 828.086998512390 701.617348574961 19.248430885871"
+$ns_ at 36.224195748623 "$node_(2) setdest 668.108957233774 438.038671156341 7.482340813910"
+$ns_ at 36.542953775451 "$node_(47) setdest 534.312621033337 1861.835136508457 21.159342396427"
+$ns_ at 36.691564406516 "$node_(64) setdest 0.001000000000 912.764865876905 25.486375690716"
+$ns_ at 36.776289338923 "$node_(20) setdest 180.529546713107 345.770629411363 10.050758984364"
+$ns_ at 36.900353749617 "$node_(97) setdest 1109.692081628755 0.001000000000 26.714840593602"
+$ns_ at 37.083405318148 "$node_(54) setdest 1763.308670056922 0.001000000000 7.787054538217"
+$ns_ at 37.260653000808 "$node_(30) setdest 1430.230454156851 369.370967288386 0.185741772952"
+$ns_ at 37.333297736298 "$node_(46) setdest 1554.603095173070 399.484892718799 19.582462006883"
+$ns_ at 37.542340749828 "$node_(57) setdest 1340.365878655384 1999.999000000000 27.240085780692"
+$ns_ at 37.630658565725 "$node_(42) setdest 691.179776935338 615.669626836949 3.173402078829"
+$ns_ at 37.700355417760 "$node_(5) setdest 422.929150504762 1691.065738484006 20.749353812261"
+$ns_ at 38.043786438057 "$node_(73) setdest 1126.658679460138 0.001000000000 19.974986434779"
+$ns_ at 38.767473043116 "$node_(70) setdest 1161.914821423184 1628.287828418506 0.919858105860"
+$ns_ at 39.046781990070 "$node_(13) setdest 93.965122914707 37.960536549880 19.961835745582"
+$ns_ at 39.140252924852 "$node_(59) setdest 1220.779738249849 293.741032092729 24.872461535061"
+$ns_ at 39.291162618826 "$node_(68) setdest 1665.708505692812 177.243384348744 2.992820135622"
+$ns_ at 39.470435369292 "$node_(60) setdest 966.880428382793 626.713442112680 5.800679649759"
+$ns_ at 39.477929163260 "$node_(77) setdest 1438.927336373620 1802.871413485907 12.590897856822"
+$ns_ at 39.544718193385 "$node_(7) setdest 1504.536518275352 607.827660201823 11.340512195628"
+$ns_ at 40.059893478415 "$node_(82) setdest 460.613064890775 0.001000000000 21.495706103304"
+$ns_ at 40.197283278983 "$node_(30) setdest 1728.652252121964 645.757407213069 11.455423589869"
+$ns_ at 40.343733963450 "$node_(51) setdest 1723.661454269810 1610.022440126759 28.510061514228"
+$ns_ at 40.393003395672 "$node_(87) setdest 1322.003703067040 1967.112015915141 10.005829831991"
+$ns_ at 40.604667530112 "$node_(96) setdest 1501.572826723093 56.970598260063 25.608718172976"
+$ns_ at 40.921019779650 "$node_(50) setdest 1044.295002587023 1002.667402747783 1.320385127873"
+$ns_ at 41.035342489548 "$node_(61) setdest 787.272784632598 0.001000000000 22.888311762500"
+$ns_ at 41.079373791079 "$node_(78) setdest 475.441903723385 1362.185610124633 13.057728722495"
+$ns_ at 41.235102241189 "$node_(12) setdest 1585.727308872110 1390.625641750250 4.182178445024"
+$ns_ at 41.448165260605 "$node_(9) setdest 1698.567700767727 1297.284539129889 1.920249397728"
+$ns_ at 41.657117538590 "$node_(95) setdest 1908.933704446966 451.841368698265 27.102762127309"
+$ns_ at 41.736920367801 "$node_(99) setdest 1938.258582539227 31.415648883303 15.687883507418"
+$ns_ at 41.826104087329 "$node_(76) setdest 1180.194414463558 780.310548077223 2.664659168740"
+$ns_ at 42.012829513871 "$node_(90) setdest 680.569446331227 1534.832363040661 17.251069850892"
+$ns_ at 42.017453833136 "$node_(13) setdest 258.851167157909 159.240626413703 11.492276219739"
+$ns_ at 42.785895377368 "$node_(69) setdest 171.554292847270 822.162927523128 9.589541884373"
+$ns_ at 42.877259868205 "$node_(96) setdest 1504.950938914190 12.743484235811 5.008943488095"
+$ns_ at 43.004631385268 "$node_(86) setdest 1038.420931618670 1087.731112661050 12.006667177494"
+$ns_ at 43.054196505194 "$node_(84) setdest 1087.420217154316 19.655699557611 14.147355417974"
+$ns_ at 43.151655475592 "$node_(23) setdest 105.317072285858 1813.484148645827 25.466874578307"
+$ns_ at 43.226333782687 "$node_(33) setdest 107.962657614557 1021.277554579495 19.442724882271"
+$ns_ at 43.479599725806 "$node_(85) setdest 1983.503521437183 243.929666619488 12.541024387404"
+$ns_ at 43.578268279619 "$node_(55) setdest 0.001000000000 745.994111955674 20.354335796110"
+$ns_ at 43.686548242687 "$node_(49) setdest 466.286864874376 53.284016437325 26.073023976347"
+$ns_ at 43.763538491355 "$node_(99) setdest 1922.457652897717 0.001000000000 19.871416076840"
+$ns_ at 44.226702111407 "$node_(63) setdest 54.456548655208 230.891641796420 28.726647503427"
+$ns_ at 44.493202580814 "$node_(84) setdest 1135.504367878608 88.675789380837 2.944436312006"
+$ns_ at 44.539506146447 "$node_(11) setdest 889.153781701175 1475.981708533370 23.831274989587"
+$ns_ at 44.848978724221 "$node_(37) setdest 265.162960528482 1473.622096970321 11.945801764071"
+$ns_ at 44.905327395450 "$node_(45) setdest 846.871694898872 902.883807557664 22.875474332963"
+$ns_ at 44.989079651371 "$node_(47) setdest 638.547114989735 1919.781632355716 6.007134628168"
+$ns_ at 44.990348601663 "$node_(83) setdest 1290.150002590623 373.640224038452 14.713392170633"
+$ns_ at 44.994817040812 "$node_(85) setdest 1721.154786738042 144.229120540322 28.790137975256"
+$ns_ at 45.034056687695 "$node_(3) setdest 1792.707046679718 436.544167392410 0.248148255153"
+$ns_ at 45.429955185522 "$node_(80) setdest 1133.761438574808 1554.784571890663 2.259846409784"
+$ns_ at 45.533145964016 "$node_(99) setdest 1657.141725952924 527.489374242410 19.871416076840"
+$ns_ at 45.682822047955 "$node_(18) setdest 1967.249945922900 888.977744033978 16.121798136409"
+$ns_ at 45.837319847495 "$node_(92) setdest 1750.489260476457 127.113671445979 25.572101060615"
+$ns_ at 46.068823798954 "$node_(81) setdest 1803.038270563164 1394.352559349747 14.168611267844"
+$ns_ at 46.080264305164 "$node_(3) setdest 1758.021243928225 371.303398167437 4.359503138748"
+$ns_ at 46.271277237956 "$node_(73) setdest 979.269858392766 465.288024872956 19.974986434779"
+$ns_ at 46.785734009488 "$node_(8) setdest 95.140967883524 1228.704853439420 27.548899219570"
+$ns_ at 47.153862461967 "$node_(65) setdest 1316.060619625201 183.309669422382 24.250379801496"
+$ns_ at 47.359321192834 "$node_(66) setdest 1191.027595237785 1561.204318171969 16.213431434881"
+$ns_ at 47.494307273119 "$node_(80) setdest 1294.814788005576 1454.427967770930 11.999136596284"
+$ns_ at 48.159793318576 "$node_(14) setdest 114.293228550500 866.338259538857 6.102749204920"
+$ns_ at 48.227152271550 "$node_(75) setdest 1200.751410705109 1999.999000000000 15.158983014264"
+$ns_ at 48.270791369862 "$node_(11) setdest 941.296726620730 1999.999000000000 13.577931035328"
+$ns_ at 48.421099101975 "$node_(54) setdest 1743.150300947965 131.139308382961 7.787054538217"
+$ns_ at 48.435488200255 "$node_(18) setdest 1999.999000000000 914.381995167256 24.315514369663"
+$ns_ at 48.569936814282 "$node_(40) setdest 959.404599137259 1395.361306037007 27.751703236534"
+$ns_ at 48.815466879533 "$node_(33) setdest 0.001000000000 1079.230798642474 21.200573690607"
+$ns_ at 48.908191549203 "$node_(41) setdest 495.269683600732 233.434720884378 21.076766764134"
+$ns_ at 48.919195702008 "$node_(53) setdest 1672.347668717083 1300.494696319265 22.520300629534"
+$ns_ at 48.960228843340 "$node_(72) setdest 1756.880396308532 886.377825065794 20.609660343394"
+$ns_ at 49.017978200438 "$node_(24) setdest 1202.187933135099 121.317254378754 29.025743508588"
+$ns_ at 49.044510307804 "$node_(26) setdest 1578.490322592570 631.667118802989 27.688036758709"
+$ns_ at 49.047848788783 "$node_(44) setdest 1712.451667581166 920.585475210483 27.808352035776"
+$ns_ at 49.517350734167 "$node_(22) setdest 1757.139843222783 1553.581494694910 11.391484951647"
+$ns_ at 50.140049055039 "$node_(18) setdest 1685.319076782148 1158.486993656884 24.315514369663"
+$ns_ at 50.479542019198 "$node_(23) setdest 249.933320466794 1754.064802207829 5.752145440830"
+$ns_ at 51.018811169288 "$node_(64) setdest 39.071550606031 912.160855297565 25.486375690716"
+$ns_ at 51.051571613767 "$node_(32) setdest 1848.002677592448 1321.521918922476 29.751478385357"
+$ns_ at 51.732607975541 "$node_(96) setdest 1493.958387481763 0.001000000000 7.040051196815"
+$ns_ at 51.734794254583 "$node_(55) setdest 11.694320485901 754.591221018551 20.354335796110"
+$ns_ at 51.770271102852 "$node_(29) setdest 1958.068403222317 1036.947900405042 12.037823829182"
+$ns_ at 52.058417441397 "$node_(17) setdest 330.090944464167 1339.615301039849 14.153692625719"
+$ns_ at 52.447840406793 "$node_(55) setdest 0.001000000000 761.214800076499 27.167622956488"
+$ns_ at 52.457118171605 "$node_(97) setdest 1222.149152759603 290.288277082294 26.714840593602"
+$ns_ at 52.551991863453 "$node_(64) setdest 0.001000000000 989.942603666531 27.228732143595"
+$ns_ at 52.942508498045 "$node_(55) setdest 234.113088932892 893.825544076718 27.167622956488"
+$ns_ at 53.451027743235 "$node_(34) setdest 0.001000000000 129.609763191172 23.018908323911"
+$ns_ at 53.774384454674 "$node_(25) setdest 669.680794033019 713.202208229759 19.171519771683"
+$ns_ at 53.908372715953 "$node_(35) setdest 807.884086728866 230.503576432155 7.576470829881"
+$ns_ at 53.983979531501 "$node_(71) setdest 1999.999000000000 1811.287685855678 15.191552393823"
+$ns_ at 54.123039152948 "$node_(96) setdest 1488.545782277756 6.275251879620 7.040051196815"
+$ns_ at 54.193555260101 "$node_(21) setdest 529.341386843357 1158.639330155329 22.985863662502"
+$ns_ at 54.266337607109 "$node_(10) setdest 1241.464901285142 1227.121473644811 20.523749468009"
+$ns_ at 54.595161637556 "$node_(33) setdest 142.407704967347 1155.673961071880 21.200573690607"
+$ns_ at 54.683558828423 "$node_(51) setdest 1881.674225881475 1999.999000000000 29.738151410766"
+$ns_ at 54.743109829043 "$node_(85) setdest 1747.756489102541 43.614573048583 19.695553662005"
+$ns_ at 54.871231922252 "$node_(20) setdest 187.582161981920 340.410785023515 20.545026398365"
+$ns_ at 55.022396542498 "$node_(52) setdest 1212.044383628385 169.230857562101 14.308368620782"
+$ns_ at 55.088468196082 "$node_(61) setdest 358.426055136172 402.842505372146 22.888311762500"
+$ns_ at 55.104837240120 "$node_(91) setdest 431.878284565679 715.804781172600 19.245061584312"
+$ns_ at 55.275991596130 "$node_(74) setdest 716.965003284558 298.217771990002 16.905042564026"
+$ns_ at 55.300059821006 "$node_(96) setdest 1999.999000000000 849.948011032250 29.037821370059"
+$ns_ at 55.302391154242 "$node_(20) setdest 245.223396958208 313.226802826433 6.852833929507"
+$ns_ at 55.351744987572 "$node_(58) setdest 1843.017447096689 1175.665031084226 3.747015345526"
+$ns_ at 55.526116396874 "$node_(70) setdest 1161.832872888505 1662.862240515459 2.702902062981"
+$ns_ at 55.715398769546 "$node_(48) setdest 939.822688712211 1139.762064080690 28.522302277987"
+$ns_ at 55.748730515013 "$node_(64) setdest 231.875185239653 1451.558302698576 27.228732143595"
+$ns_ at 56.192188151098 "$node_(7) setdest 1920.855487972481 219.585970431059 13.063970055237"
+$ns_ at 56.274766847443 "$node_(52) setdest 1348.851869684976 144.693088600682 8.248950418697"
+$ns_ at 56.924304698527 "$node_(62) setdest 923.372633498861 1411.432127548081 29.898098714887"
+$ns_ at 57.143485942234 "$node_(0) setdest 36.557199681737 1999.999000000000 24.669547435768"
+$ns_ at 57.252568425966 "$node_(16) setdest 976.983606096280 144.393892799724 13.175176117421"
+$ns_ at 57.335665380040 "$node_(44) setdest 1815.587150325163 806.045485979541 3.243203103950"
+$ns_ at 58.241989324633 "$node_(59) setdest 1456.636876549055 0.001000000000 27.687219648878"
+$ns_ at 58.469935856686 "$node_(24) setdest 1542.701893403011 857.474872237643 25.576190144139"
+$ns_ at 58.695215988924 "$node_(10) setdest 1169.881374988649 806.370440415137 14.255843578204"
+$ns_ at 58.947101143312 "$node_(6) setdest 1225.271744724823 1999.999000000000 7.860663266373"
+$ns_ at 59.261811176568 "$node_(79) setdest 995.540765229282 1982.647154219238 9.485488617052"
+$ns_ at 59.823791381457 "$node_(78) setdest 472.068459380667 997.165716645579 15.888843016740"
+$ns_ at 59.828179424185 "$node_(13) setdest 470.385649200762 0.001000000000 27.880598201752"
+$ns_ at 59.895911697814 "$node_(72) setdest 1999.999000000000 753.586057679627 22.479314086927"
+$ns_ at 60.027134489837 "$node_(85) setdest 1765.963144850529 77.766884981816 19.115321876923"
+$ns_ at 60.062732269640 "$node_(1) setdest 1388.734269627584 881.321699838287 26.138084266882"
+$ns_ at 60.722989846878 "$node_(43) setdest 1999.773329030116 1920.602830692874 12.922185874291"
+$ns_ at 60.972588860458 "$node_(15) setdest 686.551531014310 1007.407846609858 5.628965075589"
+$ns_ at 61.349024226378 "$node_(89) setdest 797.833284426242 1800.629084672375 14.327690360464"
+$ns_ at 61.682923885384 "$node_(5) setdest 0.001000000000 1689.563984301581 29.945621675137"
+$ns_ at 61.836660655601 "$node_(69) setdest 139.188668175407 623.937648859433 9.536064573776"
+$ns_ at 62.022245235272 "$node_(41) setdest 716.882070876804 239.374243891335 20.231247380347"
+$ns_ at 62.045587089384 "$node_(46) setdest 1686.892233708003 449.293132289153 6.665837064344"
+$ns_ at 62.051805157688 "$node_(85) setdest 1761.820489058677 75.727781181656 0.644630072905"
+$ns_ at 62.218861610240 "$node_(33) setdest 0.001000000000 1237.370376074972 8.521070218438"
+$ns_ at 62.596221899381 "$node_(66) setdest 1125.314334740880 988.943993977426 12.778428425700"
+$ns_ at 62.846263407600 "$node_(55) setdest 0.001000000000 1346.890026594805 15.909165276264"
+$ns_ at 62.939417807295 "$node_(48) setdest 877.949447448792 1445.698276452997 15.945840698731"
+$ns_ at 63.008233907570 "$node_(92) setdest 1783.516412856603 67.967368027739 14.959999818012"
+$ns_ at 63.029025637491 "$node_(3) setdest 1893.151335473498 574.601518770235 16.706061002245"
+$ns_ at 63.308947932037 "$node_(80) setdest 1389.375157405811 1412.311341322991 4.925484012052"
+$ns_ at 63.546340543005 "$node_(94) setdest 1350.988274472455 1727.946814264933 16.895958438972"
+$ns_ at 63.607136535643 "$node_(79) setdest 938.085682339693 1915.233406066722 7.713267694618"
+$ns_ at 64.110154359063 "$node_(97) setdest 1196.330947194795 365.887154094282 1.679570298404"
+$ns_ at 64.602156662047 "$node_(20) setdest 751.778458884470 387.523112178701 16.558490597960"
+$ns_ at 64.841914576242 "$node_(47) setdest 593.170592866557 1999.999000000000 23.432800555963"
+$ns_ at 65.459456508066 "$node_(54) setdest 1477.621512148804 645.479714076900 15.559131397770"
+$ns_ at 65.496604288031 "$node_(58) setdest 1968.877929201321 1258.913280373711 4.270910892536"
+$ns_ at 65.606802370991 "$node_(6) setdest 1337.703547090467 1760.836752460636 7.860663266373"
+$ns_ at 65.894263730582 "$node_(16) setdest 1044.332131187404 0.001000000000 19.849501507170"
+$ns_ at 66.518875681320 "$node_(18) setdest 1363.040080309280 1054.067170517625 19.048055637110"
+$ns_ at 66.666077617141 "$node_(37) setdest 0.001000000000 1281.930562846063 25.536256787666"
+$ns_ at 66.728139766103 "$node_(93) setdest 364.503905488483 1407.510312000338 24.867300350242"
+$ns_ at 66.745957350640 "$node_(98) setdest 1511.169281761073 209.438263845268 28.212946683641"
+$ns_ at 66.813399623725 "$node_(31) setdest 1471.696700711070 353.518433460053 23.742993446557"
+$ns_ at 67.155966180450 "$node_(75) setdest 1303.194085732221 1899.856477030870 15.158983014264"
+$ns_ at 67.536491579321 "$node_(92) setdest 1999.999000000000 294.283434267520 8.058857027043"
+$ns_ at 67.722876770443 "$node_(27) setdest 1794.191526873512 1743.623536399715 11.759401508806"
+$ns_ at 68.158158315547 "$node_(27) setdest 1698.643905465206 1962.387004496420 7.706823645548"
+$ns_ at 68.317741253680 "$node_(70) setdest 1176.595260730149 1575.956811326113 10.038987830701"
+$ns_ at 68.700788819277 "$node_(82) setdest 456.124304142209 40.882327173776 21.495706103304"
+$ns_ at 68.774953287224 "$node_(47) setdest 156.309212119002 1227.708212841681 23.432800555963"
+$ns_ at 68.832817770871 "$node_(51) setdest 1893.236969386243 1971.462072961165 29.738151410766"
+$ns_ at 69.214531621602 "$node_(85) setdest 1725.529412488435 0.001000000000 24.911768721458"
+$ns_ at 69.324811401618 "$node_(13) setdest 972.160875449066 377.729012945165 27.880598201752"
+$ns_ at 69.763402692906 "$node_(86) setdest 893.597841223651 697.905089480570 23.074957649437"
+$ns_ at 69.868204026459 "$node_(51) setdest 1909.719832282040 1999.999000000000 20.110919460576"
+$ns_ at 70.030471897727 "$node_(40) setdest 939.926274258150 855.199680103166 25.013563708485"
+$ns_ at 70.112082504882 "$node_(71) setdest 1627.040018272889 1827.542245702625 15.191552393823"
+$ns_ at 70.316773667696 "$node_(57) setdest 1227.493065504611 1897.054393545806 27.240085780692"
+$ns_ at 70.362995314592 "$node_(87) setdest 1360.224453628643 1999.999000000000 18.163061051678"
+$ns_ at 70.578372461059 "$node_(17) setdest 313.098844750699 1394.626743966799 3.554454628914"
+$ns_ at 70.614055643142 "$node_(82) setdest 270.371863575192 69.023114997125 9.553864383358"
+$ns_ at 70.705498202094 "$node_(73) setdest 1194.180815356548 324.683480651800 8.279800711824"
+$ns_ at 71.506872802460 "$node_(51) setdest 1999.999000000000 1843.697874486725 20.110919460576"
+$ns_ at 71.847971646303 "$node_(59) setdest 1483.710207512828 33.718534111972 27.687219648878"
+$ns_ at 71.859660541506 "$node_(26) setdest 1578.242365798222 633.476733241746 0.116582396488"
+$ns_ at 72.219259796308 "$node_(72) setdest 1591.035789450185 530.209702681513 22.479314086927"
+$ns_ at 72.585377453756 "$node_(85) setdest 1544.758064264631 377.207564935086 24.911768721458"
+$ns_ at 72.596663452856 "$node_(67) setdest 459.435529002390 1232.771892738305 11.047509931864"
+$ns_ at 72.631179548054 "$node_(38) setdest 1603.871669651700 1970.159075372703 25.309541366268"
+$ns_ at 72.779545101584 "$node_(56) setdest 1828.894944317591 1337.597385048744 28.615140866196"
+$ns_ at 72.926092876429 "$node_(74) setdest 344.834351303689 41.797255429858 12.032042355588"
+$ns_ at 72.980144300828 "$node_(41) setdest 562.378670091365 370.174950514088 10.333893834223"
+$ns_ at 73.061700079022 "$node_(84) setdest 1226.857522851622 97.166189001642 26.872853480199"
+$ns_ at 73.124257435480 "$node_(52) setdest 1383.845776561793 0.001000000000 29.778097256274"
+$ns_ at 73.139070000202 "$node_(87) setdest 1702.161248147877 1705.780028521218 18.163061051678"
+$ns_ at 73.171199376172 "$node_(68) setdest 1443.900163837872 272.309472453269 11.799385450064"
+$ns_ at 73.231161578992 "$node_(90) setdest 667.921878129178 1433.998604632768 14.354985874485"
+$ns_ at 73.409761402332 "$node_(59) setdest 936.842596536953 51.226251465326 26.789567104426"
+$ns_ at 73.921020494752 "$node_(16) setdest 1124.822148470788 172.568794488782 19.849501507170"
+$ns_ at 74.615841901935 "$node_(98) setdest 1524.937623859083 209.166828962586 8.171655329524"
+$ns_ at 74.720594457467 "$node_(64) setdest 243.210250738755 1009.094018182263 22.834035237434"
+$ns_ at 75.067218074835 "$node_(45) setdest 640.765667612603 714.312997900777 18.251870249483"
+$ns_ at 75.090720349261 "$node_(79) setdest 1068.260844714880 1999.999000000000 28.401182324245"
+$ns_ at 75.246906963511 "$node_(99) setdest 1686.069001748410 465.489565400449 29.400332968714"
+$ns_ at 75.441062807520 "$node_(65) setdest 1340.531583490891 0.001000000000 7.251790043167"
+$ns_ at 75.501061425052 "$node_(63) setdest 0.001000000000 208.078338029759 20.942202405337"
+$ns_ at 75.638976933931 "$node_(39) setdest 840.581353147491 1503.728093812946 16.427956705245"
+$ns_ at 75.704425092378 "$node_(30) setdest 1638.366097662557 741.119179483447 15.327847950901"
+$ns_ at 75.776104264514 "$node_(8) setdest 98.462189711693 1272.024160381593 2.064177348199"
+$ns_ at 75.806217812489 "$node_(5) setdest 378.787979401137 1688.218968771438 29.945621675137"
+$ns_ at 75.924955432917 "$node_(57) setdest 1266.118099886023 1785.260860795281 2.898463989873"
+$ns_ at 76.175233101258 "$node_(60) setdest 1342.419048920415 506.543759764146 17.627382700159"
+$ns_ at 76.251113888625 "$node_(28) setdest 1648.081868209286 1555.118404517371 8.219787332829"
+$ns_ at 76.301059507603 "$node_(98) setdest 1366.610402953940 240.354073669108 7.683263023762"
+$ns_ at 76.475809313267 "$node_(84) setdest 1121.649448311429 0.001000000000 3.664489920833"
+$ns_ at 76.544548695846 "$node_(21) setdest 1176.908340654840 1428.940977916132 21.895592845703"
+$ns_ at 76.606375895405 "$node_(75) setdest 1178.630361788120 1999.999000000000 5.998834811765"
+$ns_ at 76.768044763275 "$node_(62) setdest 844.097593338201 1299.385319207496 4.832929137296"
+$ns_ at 77.058382247725 "$node_(88) setdest 1333.848172047530 562.993560585868 19.387346500154"
+$ns_ at 77.098540411498 "$node_(70) setdest 490.822660688940 1211.041540338094 17.192664358413"
+$ns_ at 77.109095346354 "$node_(50) setdest 1040.889358035600 1058.352575788613 4.245129122289"
+$ns_ at 77.573959049201 "$node_(99) setdest 1769.351816333010 841.269681086676 10.425545978008"
+$ns_ at 77.641158233788 "$node_(3) setdest 1791.941549682159 0.001000000000 26.266745474790"
+$ns_ at 77.660257238363 "$node_(23) setdest 0.001000000000 1713.490000309452 29.962047844457"
+$ns_ at 78.108402862798 "$node_(36) setdest 1018.739810067786 0.001000000000 17.860776877886"
+$ns_ at 78.123354842858 "$node_(52) setdest 1587.793886723347 843.281463919472 29.778097256274"
+$ns_ at 78.266693637425 "$node_(89) setdest 793.827395220772 1803.077451615646 0.555427596202"
+$ns_ at 78.320302534528 "$node_(63) setdest 447.619276528778 20.555634354209 20.942202405337"
+$ns_ at 79.060972444759 "$node_(2) setdest 845.950744984888 696.635515859189 8.542395666043"
+$ns_ at 79.479032678933 "$node_(37) setdest 6.212206289804 1277.440342378233 25.536256787666"
+$ns_ at 79.779165876441 "$node_(37) setdest 149.819554418065 1029.261381441939 12.840090357412"
+$ns_ at 79.911894710201 "$node_(42) setdest 602.828087707222 668.131925176019 5.141428645960"
+$ns_ at 79.995750599042 "$node_(25) setdest 1390.467939688285 947.481428309739 18.684734793644"
+$ns_ at 80.073696617501 "$node_(53) setdest 1658.739648997067 1390.285036451007 2.423542771558"
+$ns_ at 80.310503589551 "$node_(90) setdest 153.742920429423 726.071673790544 28.376777533051"
+$ns_ at 80.482112977543 "$node_(51) setdest 1700.668342554996 1325.464046662287 20.110919460576"
+$ns_ at 80.560240788378 "$node_(79) setdest 1282.050705476237 1860.786386827924 28.401182324245"
+$ns_ at 80.567150992078 "$node_(56) setdest 1808.174926603760 1202.129780069659 7.888405046889"
+$ns_ at 80.795030212792 "$node_(61) setdest 552.434980232336 0.001000000000 24.227047698331"
+$ns_ at 80.834214120019 "$node_(9) setdest 1707.001287090650 1353.898474522376 5.565905293885"
+$ns_ at 81.261669458845 "$node_(19) setdest 1217.650251631377 1491.195560296532 24.758974002652"
+$ns_ at 81.366560059666 "$node_(1) setdest 1499.940812298091 932.524003511922 5.975027901725"
+$ns_ at 81.486001790190 "$node_(33) setdest 148.648323752971 1322.646932773662 8.521070218438"
+$ns_ at 81.511747125663 "$node_(77) setdest 1441.936563940918 1999.999000000000 27.586318633733"
+$ns_ at 81.762387846827 "$node_(67) setdest 598.722780646001 1203.102613828192 18.353344181680"
+$ns_ at 82.484809157036 "$node_(81) setdest 1839.543582078355 1355.143448088490 19.288490892901"
+$ns_ at 82.513814011198 "$node_(48) setdest 817.088081709428 669.868052025951 25.208456158801"
+$ns_ at 82.686324312032 "$node_(43) setdest 1999.999000000000 1913.760793810659 13.345335415487"
+$ns_ at 82.798118783819 "$node_(78) setdest 395.430154708480 948.249844821417 2.359321802897"
+$ns_ at 82.898827164202 "$node_(69) setdest 362.572137627623 255.003521662657 17.586405335736"
+$ns_ at 83.199294373208 "$node_(43) setdest 1989.188041979986 1585.987250128772 13.345335415487"
+$ns_ at 83.251497649501 "$node_(46) setdest 1796.625035299452 610.272338288386 9.634207956745"
+$ns_ at 83.370523049459 "$node_(76) setdest 1158.775800851435 402.342885519698 24.904451753051"
+$ns_ at 83.483780256482 "$node_(35) setdest 766.403393427365 236.409493784679 5.837109943468"
+$ns_ at 83.514011429645 "$node_(16) setdest 1071.129678110943 0.001000000000 11.323554515857"
+$ns_ at 84.271965746172 "$node_(30) setdest 1889.426543612106 541.571073767989 17.775380805023"
+$ns_ at 84.304058703011 "$node_(18) setdest 1343.886310208742 1101.209736843166 1.696792608828"
+$ns_ at 84.325272811002 "$node_(80) setdest 1387.752359706937 1413.107034836093 2.138424889136"
+$ns_ at 84.652134510512 "$node_(36) setdest 1044.274125682605 58.712594984051 17.860776877886"
+$ns_ at 85.067455086589 "$node_(38) setdest 1587.550010048207 1999.999000000000 17.739448466212"
+$ns_ at 85.170462157352 "$node_(80) setdest 1434.644294908827 1448.060330187203 12.644896479888"
+$ns_ at 85.195613757492 "$node_(95) setdest 1999.999000000000 469.284051382842 6.701552032466"
+$ns_ at 85.262232658266 "$node_(81) setdest 819.244533542115 582.688838854481 27.077905425806"
+$ns_ at 85.598938691381 "$node_(4) setdest 1485.751766239164 1762.696896758196 8.709732148667"
+$ns_ at 86.029371165132 "$node_(0) setdest 34.188430231333 1845.740262399712 24.669547435768"
+$ns_ at 86.111095558850 "$node_(23) setdest 841.289570695328 1576.912557937942 29.962047844457"
+$ns_ at 86.719376746048 "$node_(89) setdest 764.724549314061 1933.660356598067 9.571511069539"
+$ns_ at 86.776624655789 "$node_(17) setdest 387.854704893579 1324.860844126930 13.387551778867"
+$ns_ at 86.984765117759 "$node_(38) setdest 1505.827197293411 1850.590016344201 17.739448466212"
+$ns_ at 87.054695327596 "$node_(11) setdest 943.574625951726 1977.106955074191 13.577931035328"
+$ns_ at 87.526890345665 "$node_(26) setdest 920.107706032034 1231.376554721554 24.182308661491"
+$ns_ at 87.665972894863 "$node_(15) setdest 685.291674948271 1001.916044172101 1.301398091556"
+$ns_ at 87.785460300667 "$node_(86) setdest 1150.162943511959 585.814836421931 6.307885500413"
+$ns_ at 88.236740314511 "$node_(36) setdest 884.871643516552 18.476921882888 26.267850014051"
+$ns_ at 88.455458208187 "$node_(5) setdest 232.821899735475 1999.999000000000 29.756372369073"
+$ns_ at 88.633601869730 "$node_(10) setdest 1017.350682025985 816.900048129958 4.071073580351"
+$ns_ at 88.658425749052 "$node_(77) setdest 1455.248790686193 1127.945600668499 27.586318633733"
+$ns_ at 88.748996042967 "$node_(11) setdest 928.284987900410 1999.999000000000 26.827078817313"
+$ns_ at 89.276238300017 "$node_(96) setdest 1792.311657107448 1192.540740039958 29.037821370059"
+$ns_ at 89.376071015953 "$node_(85) setdest 1660.436874311183 461.089312670871 6.565898585050"
+$ns_ at 89.521850798919 "$node_(67) setdest 552.150632690149 1668.407879670793 17.768536366408"
+$ns_ at 89.542968305476 "$node_(79) setdest 1339.616342004748 1853.009522917348 24.154307307404"
+$ns_ at 89.546986752840 "$node_(32) setdest 1999.999000000000 1109.093461902072 16.405267326415"
+$ns_ at 89.775142355281 "$node_(11) setdest 627.849720059213 1550.179480032635 26.827078817313"
+$ns_ at 89.795709973954 "$node_(80) setdest 1418.766469232547 1317.075103485602 17.250228433541"
+$ns_ at 90.182894575391 "$node_(24) setdest 1759.449869676073 849.223784596041 6.639471732027"
+$ns_ at 90.251032137322 "$node_(50) setdest 582.066203317936 968.934223246927 10.540049397082"
+$ns_ at 90.278554931304 "$node_(82) setdest 410.560127256479 91.038147177812 19.906246041716"
+$ns_ at 90.372716835760 "$node_(45) setdest 759.018603419794 257.961811837354 14.273803551987"
+$ns_ at 90.661821994178 "$node_(35) setdest 768.571715421724 232.279788951587 16.377114944402"
+$ns_ at 90.946630495897 "$node_(35) setdest 763.760284566568 179.505784225600 1.466750619607"
+$ns_ at 91.023650965982 "$node_(12) setdest 1999.999000000000 1172.176540219089 29.476186621997"
+$ns_ at 91.118012895244 "$node_(9) setdest 1823.454464664916 963.348091530000 11.910545020625"
+$ns_ at 91.256487383932 "$node_(93) setdest 367.997460759400 1406.584451746750 0.762351667823"
+$ns_ at 91.354944920633 "$node_(91) setdest 979.027222683057 1175.416961950912 26.322144839605"
+$ns_ at 91.627390068602 "$node_(83) setdest 1249.605901172248 352.943604527894 1.015463602217"
+$ns_ at 91.639256398776 "$node_(40) setdest 68.593669847163 398.590665672326 19.706071986571"
+$ns_ at 91.851515384130 "$node_(13) setdest 493.111116475372 1330.459822632590 29.744244132364"
+$ns_ at 91.947863242368 "$node_(79) setdest 1180.334929031189 1999.999000000000 27.691858515401"
+$ns_ at 91.995516108148 "$node_(15) setdest 523.836771285104 1284.333916759737 28.376086067948"
+$ns_ at 92.283110684633 "$node_(0) setdest 129.981385993482 1680.130212526707 29.639666381422"
+$ns_ at 92.543204236800 "$node_(49) setdest 439.703306876493 0.001000000000 10.783705636655"
+$ns_ at 92.569612563623 "$node_(41) setdest 604.886494915961 249.402810571342 15.361754076379"
+$ns_ at 92.949043229415 "$node_(72) setdest 1317.474822229639 565.408475541931 6.066952890427"
+$ns_ at 93.623315535025 "$node_(68) setdest 1457.166612073213 186.189552990794 2.912355066548"
+$ns_ at 93.833674482627 "$node_(59) setdest 923.543158758235 97.940461267715 19.929283171739"
+$ns_ at 93.996671463056 "$node_(22) setdest 1675.259930307082 1999.999000000000 29.344256527730"
+$ns_ at 94.104354145675 "$node_(64) setdest 0.001000000000 641.456778241154 26.862905125049"
+$ns_ at 94.414556810498 "$node_(17) setdest 20.711419702024 1543.502816549773 22.416340666765"
+$ns_ at 94.495422734778 "$node_(36) setdest 890.052185276925 0.001000000000 15.102159815556"
+$ns_ at 94.685806955189 "$node_(71) setdest 661.749864574173 1752.970099474379 22.120917485847"
+$ns_ at 94.901770955468 "$node_(55) setdest 74.342951745781 1490.759990980717 15.909165276264"
+$ns_ at 95.145871849200 "$node_(34) setdest 143.653063022992 148.117052447705 23.018908323911"
+$ns_ at 95.521314341898 "$node_(20) setdest 837.714267113162 534.224083725954 8.968368804991"
+$ns_ at 95.766001155978 "$node_(36) setdest 1034.373227651104 514.708617137391 15.102159815556"
+$ns_ at 95.997290352879 "$node_(93) setdest 0.001000000000 1223.399805798269 29.510348535220"
+$ns_ at 96.270816300697 "$node_(59) setdest 1149.097469979659 1315.667117202751 25.166271562834"
+$ns_ at 96.336280827139 "$node_(14) setdest 201.473400598652 891.376814014004 3.387045153884"
+$ns_ at 96.584767352620 "$node_(38) setdest 1498.642423180852 1854.007083928591 0.197782795958"
+$ns_ at 96.823925960738 "$node_(8) setdest 301.543643805112 1290.944694623325 14.917486972747"
+$ns_ at 97.303804818668 "$node_(98) setdest 1430.801296359000 165.491223716558 7.043993569094"
+$ns_ at 97.407289564780 "$node_(82) setdest 400.008186413257 678.211810990956 24.451383986361"
+$ns_ at 97.444539697095 "$node_(80) setdest 1569.767706138471 1397.175949218375 18.430152002881"
+$ns_ at 97.502171870531 "$node_(94) setdest 1527.480732594706 1620.770547115557 5.850608425768"
+$ns_ at 97.631528524945 "$node_(31) setdest 1553.038410836461 639.180190140691 21.327325277454"
+$ns_ at 97.939867752994 "$node_(56) setdest 1521.241602854468 716.866279360814 25.863216418275"
+$ns_ at 97.974848089213 "$node_(87) setdest 1206.743853145182 1872.995794022577 22.964458936062"
+$ns_ at 98.065084362108 "$node_(49) setdest 372.083409573801 135.535607510275 10.783705636655"
+$ns_ at 98.543661780364 "$node_(60) setdest 1527.016036072440 410.456729353954 6.721519416179"
+$ns_ at 98.571582412067 "$node_(76) setdest 981.942175850177 0.001000000000 17.245875473735"
+$ns_ at 98.737942118917 "$node_(0) setdest 59.766604485734 1196.827433684669 10.049334130674"
+$ns_ at 98.946124379397 "$node_(88) setdest 1273.768642525902 650.637084372050 5.410946786775"
+$ns_ at 99.031324863350 "$node_(95) setdest 1948.620793807128 479.125053293422 6.701552032466"
+$ns_ at 99.133187573355 "$node_(27) setdest 1761.452195774613 1940.368095943945 1.706039580290"
+$ns_ at 99.226309306910 "$node_(6) setdest 1265.521711082927 1782.778531500020 3.681340871036"
+$ns_ at 99.250641418631 "$node_(61) setdest 778.750566908893 469.924286162092 24.227047698331"
+$ns_ at 99.474350104159 "$node_(16) setdest 984.758431894170 277.598498624743 11.323554515857"
+$ns_ at 99.766738078770 "$node_(7) setdest 1999.999000000000 327.393226103304 24.919074597812"
+$ns_ at 99.774733019245 "$node_(79) setdest 421.598103792261 1299.814797065193 27.691858515401"
+$ns_ at 99.853500864928 "$node_(3) setdest 1777.787552156009 80.357798086360 26.266745474790"
+$ns_ at 99.897323403775 "$node_(42) setdest 1298.129047981509 176.204953249208 28.132216662608"
+$ns_ at 100.024644094791 "$node_(5) setdest 55.999120601102 1622.309801751258 29.756372369073"
+$ns_ at 100.943020592648 "$node_(65) setdest 1349.382175186667 66.299581300596 7.251790043167"
+$ns_ at 103.249370889241 "$node_(75) setdest 1128.519906570279 1959.712893790634 5.998834811765"
+$ns_ at 105.133667888712 "$node_(7) setdest 1713.262114097126 717.978834162317 24.919074597812"
+$ns_ at 105.469086357784 "$node_(32) setdest 1780.837656983051 802.795880498897 16.405267326415"
+$ns_ at 106.398470155645 "$node_(92) setdest 1982.425089651049 312.655619814206 8.058857027043"
+$ns_ at 106.912361597749 "$node_(12) setdest 1707.310347245934 1017.839242759985 29.476186621997"
+$ns_ at 109.463562462692 "$node_(22) setdest 1590.210583743340 1536.301424259989 29.344256527730"
+$ns_ at 109.926958057589 "$node_(93) setdest 531.449218951354 958.850647831760 29.510348535220"
+$ns_ at 110.513736261394 "$node_(64) setdest 123.532811936653 454.725006125718 26.862905125049"
+$ns_ at 115.556957786233 "$node_(84) setdest 1096.373809406003 23.344381599905 3.664489920833"
+$ns_ at 124.055202693637 "$node_(76) setdest 910.944330375816 161.539321774423 17.245875473735"
+$ns_ at 0.000000000 "$node_(99) setdest 1832.607423706101 646.965854200275 0.000000000000"
diff -u -r --new-file ./hls/utils/sc-x2000-y2000-n40-s25-t40 ../../ns-2.33-hls_working/ns-2.33/hls/utils/sc-x2000-y2000-n40-s25-t40
--- ./hls/utils/sc-x2000-y2000-n40-s25-t40	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/sc-x2000-y2000-n40-s25-t40	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,173 @@
+#
+# nodes: 40, pause: 0.00, max speed: 25.00  max x = 2000.00, max y: 2000.00
+# model (rwp): 0 
+#
+$node_(0) set X_ 556.734144874268
+$node_(0) set Y_ 1023.323395671633
+$node_(0) set Z_ 0.000000000000
+$node_(1) set X_ 1675.254407052934
+$node_(1) set Y_ 12.170824855525
+$node_(1) set Z_ 0.000000000000
+$node_(2) set X_ 1797.656017653140
+$node_(2) set Y_ 1218.096291050936
+$node_(2) set Z_ 0.000000000000
+$node_(3) set X_ 1580.042912516289
+$node_(3) set Y_ 1790.980062898955
+$node_(3) set Z_ 0.000000000000
+$node_(4) set X_ 1721.454093332358
+$node_(4) set Y_ 491.074164093664
+$node_(4) set Z_ 0.000000000000
+$node_(5) set X_ 293.461426879161
+$node_(5) set Y_ 194.327818388988
+$node_(5) set Z_ 0.000000000000
+$node_(6) set X_ 762.813370689406
+$node_(6) set Y_ 600.335853549355
+$node_(6) set Z_ 0.000000000000
+$node_(7) set X_ 7.606244254036
+$node_(7) set Y_ 1821.467184240878
+$node_(7) set Z_ 0.000000000000
+$node_(8) set X_ 567.570541584563
+$node_(8) set Y_ 1150.824915210722
+$node_(8) set Z_ 0.000000000000
+$node_(9) set X_ 319.212252397577
+$node_(9) set Y_ 988.884329212613
+$node_(9) set Z_ 0.000000000000
+$node_(10) set X_ 1656.638325819455
+$node_(10) set Y_ 1131.379517199232
+$node_(10) set Z_ 0.000000000000
+$node_(11) set X_ 1716.857002154931
+$node_(11) set Y_ 1227.684740973066
+$node_(11) set Z_ 0.000000000000
+$node_(12) set X_ 1195.784893173241
+$node_(12) set Y_ 1559.990623412305
+$node_(12) set Z_ 0.000000000000
+$node_(13) set X_ 1929.226004616775
+$node_(13) set Y_ 517.079305613319
+$node_(13) set Z_ 0.000000000000
+$node_(14) set X_ 1123.614274680777
+$node_(14) set Y_ 587.193556603327
+$node_(14) set Z_ 0.000000000000
+$node_(15) set X_ 1033.943428668990
+$node_(15) set Y_ 1487.776556902521
+$node_(15) set Z_ 0.000000000000
+$node_(16) set X_ 752.469858263916
+$node_(16) set Y_ 756.748509150971
+$node_(16) set Z_ 0.000000000000
+$node_(17) set X_ 734.094655923001
+$node_(17) set Y_ 1924.412749029243
+$node_(17) set Z_ 0.000000000000
+$node_(18) set X_ 1126.132816136838
+$node_(18) set Y_ 916.361810837086
+$node_(18) set Z_ 0.000000000000
+$node_(19) set X_ 14.919635587985
+$node_(19) set Y_ 737.759340467035
+$node_(19) set Z_ 0.000000000000
+$node_(20) set X_ 1269.091872151132
+$node_(20) set Y_ 1631.618369862061
+$node_(20) set Z_ 0.000000000000
+$node_(21) set X_ 1865.891363548573
+$node_(21) set Y_ 50.702816176774
+$node_(21) set Z_ 0.000000000000
+$node_(22) set X_ 233.514575391824
+$node_(22) set Y_ 666.586817517457
+$node_(22) set Z_ 0.000000000000
+$node_(23) set X_ 61.351618631027
+$node_(23) set Y_ 1120.878386036123
+$node_(23) set Z_ 0.000000000000
+$node_(24) set X_ 832.348224133163
+$node_(24) set Y_ 1273.785744411126
+$node_(24) set Z_ 0.000000000000
+$node_(25) set X_ 1006.789476756175
+$node_(25) set Y_ 1110.850734140051
+$node_(25) set Z_ 0.000000000000
+$node_(26) set X_ 815.477022427839
+$node_(26) set Y_ 1719.214668041585
+$node_(26) set Z_ 0.000000000000
+$node_(27) set X_ 504.151024518364
+$node_(27) set Y_ 1257.935527340725
+$node_(27) set Z_ 0.000000000000
+$node_(28) set X_ 1944.746921255118
+$node_(28) set Y_ 1377.385259974640
+$node_(28) set Z_ 0.000000000000
+$node_(29) set X_ 90.729549865155
+$node_(29) set Y_ 876.262664096945
+$node_(29) set Z_ 0.000000000000
+$node_(30) set X_ 1915.599887008177
+$node_(30) set Y_ 1502.690645778242
+$node_(30) set Z_ 0.000000000000
+$node_(31) set X_ 695.786972488310
+$node_(31) set Y_ 86.535228290291
+$node_(31) set Z_ 0.000000000000
+$node_(32) set X_ 590.370344089957
+$node_(32) set Y_ 347.489643639336
+$node_(32) set Z_ 0.000000000000
+$node_(33) set X_ 54.730974137938
+$node_(33) set Y_ 1847.594384775153
+$node_(33) set Z_ 0.000000000000
+$node_(34) set X_ 770.303791366672
+$node_(34) set Y_ 491.962183006197
+$node_(34) set Z_ 0.000000000000
+$node_(35) set X_ 1766.753092862251
+$node_(35) set Y_ 1832.119303131504
+$node_(35) set Z_ 0.000000000000
+$node_(36) set X_ 5.456153197969
+$node_(36) set Y_ 1684.850803011328
+$node_(36) set Z_ 0.000000000000
+$node_(37) set X_ 1729.938544333535
+$node_(37) set Y_ 1089.384148369874
+$node_(37) set Z_ 0.000000000000
+$node_(38) set X_ 157.713789929406
+$node_(38) set Y_ 681.511483413086
+$node_(38) set Z_ 0.000000000000
+$node_(39) set X_ 1204.510062879659
+$node_(39) set Y_ 204.065886995818
+$node_(39) set Z_ 0.000000000000
+$ns_ at 0.000000000000 "$node_(0) setdest 996.703960915059 1603.415983540197 7.782230063761"
+$ns_ at 0.000000000000 "$node_(1) setdest 538.451357580055 1744.209325577850 11.733055911215"
+$ns_ at 0.000000000000 "$node_(2) setdest 548.030773682242 745.617763578584 19.918471501516"
+$ns_ at 0.000000000000 "$node_(3) setdest 1015.212731543467 680.635951661151 18.038407697339"
+$ns_ at 0.000000000000 "$node_(4) setdest 1474.922357787712 1028.050646499336 5.596100925450"
+$ns_ at 0.000000000000 "$node_(5) setdest 54.103836112910 1307.275597606371 17.326681451110"
+$ns_ at 0.000000000000 "$node_(6) setdest 1837.973136498698 828.590764120950 1.526155474760"
+$ns_ at 0.000000000000 "$node_(7) setdest 1412.773152267630 485.309415366974 7.333676124226"
+$ns_ at 0.000000000000 "$node_(8) setdest 1916.884967452919 1101.059681713590 18.897125610036"
+$ns_ at 0.000000000000 "$node_(9) setdest 178.735953667829 1.371453768496 12.915494018910"
+$ns_ at 0.000000000000 "$node_(10) setdest 1097.754571142964 1962.720173556517 18.176739495767"
+$ns_ at 0.000000000000 "$node_(11) setdest 1701.268623370685 1233.540500313419 1.488937263526"
+$ns_ at 0.000000000000 "$node_(12) setdest 771.821074511545 1992.964000157532 22.033014728006"
+$ns_ at 0.000000000000 "$node_(13) setdest 543.773901751824 1200.299225246767 17.905577745231"
+$ns_ at 0.000000000000 "$node_(14) setdest 955.168352984927 1513.755464954117 21.209194042629"
+$ns_ at 0.000000000000 "$node_(15) setdest 1068.791180485653 1174.527370485636 3.555625981257"
+$ns_ at 0.000000000000 "$node_(16) setdest 668.105971687513 851.488744691378 12.110459402081"
+$ns_ at 0.000000000000 "$node_(17) setdest 1620.610641634265 1613.485384722912 23.239666605650"
+$ns_ at 0.000000000000 "$node_(18) setdest 1291.549551788078 1078.218047965249 20.150596505434"
+$ns_ at 0.000000000000 "$node_(19) setdest 1516.827883880749 1334.931729325318 2.540064476082"
+$ns_ at 0.000000000000 "$node_(20) setdest 620.559719108432 1740.821605846108 0.014775013557"
+$ns_ at 0.000000000000 "$node_(21) setdest 146.277528017097 472.065513092264 24.952574457100"
+$ns_ at 0.000000000000 "$node_(22) setdest 1319.038607198113 1087.234348817480 14.364596112974"
+$ns_ at 0.000000000000 "$node_(23) setdest 605.067103472196 1356.170593915113 14.564491243993"
+$ns_ at 0.000000000000 "$node_(24) setdest 521.609447803068 681.949688872869 19.038450178635"
+$ns_ at 0.000000000000 "$node_(25) setdest 70.153677321025 1057.226796654823 10.146676590199"
+$ns_ at 0.000000000000 "$node_(26) setdest 853.015300074535 625.679109433457 22.281269819828"
+$ns_ at 0.000000000000 "$node_(27) setdest 126.745131525585 190.749662938868 23.949801233241"
+$ns_ at 0.000000000000 "$node_(28) setdest 1720.407615630083 902.905421010119 14.122248097566"
+$ns_ at 0.000000000000 "$node_(29) setdest 1344.516254658041 1290.483230415541 14.456711191599"
+$ns_ at 0.000000000000 "$node_(30) setdest 1730.132927924360 356.393159577875 23.612702880491"
+$ns_ at 0.000000000000 "$node_(31) setdest 382.229951671933 128.416089260917 3.432044958716"
+$ns_ at 0.000000000000 "$node_(32) setdest 247.474954582876 1298.913893866509 10.635490219309"
+$ns_ at 0.000000000000 "$node_(33) setdest 533.072555061757 1342.585395785574 10.481324970859"
+$ns_ at 0.000000000000 "$node_(34) setdest 399.872221574385 642.342355397642 23.024457248586"
+$ns_ at 0.000000000000 "$node_(35) setdest 443.115356515510 1430.437349206861 17.097046955097"
+$ns_ at 0.000000000000 "$node_(36) setdest 1298.957706030593 1587.190408457171 23.988315833858"
+$ns_ at 0.000000000000 "$node_(37) setdest 1280.884618842957 1832.510029813892 12.625808972490"
+$ns_ at 0.000000000000 "$node_(38) setdest 158.150328323447 18.420272481094 19.662777237796"
+$ns_ at 0.000000000000 "$node_(39) setdest 1721.984919660926 1412.680268766141 11.552679124401"
+$ns_ at 10.475085708703 "$node_(16) setdest 1239.294282727755 823.032904772117 8.888211826738"
+$ns_ at 11.183782797222 "$node_(11) setdest 1965.486186731057 1942.568132453922 9.480570435247"
+$ns_ at 11.485051225359 "$node_(18) setdest 1686.038090958197 1253.726230113831 17.262687704203"
+$ns_ at 17.363802405992 "$node_(34) setdest 1764.239029200653 1578.209340434041 12.176300613580"
+$ns_ at 27.503253563449 "$node_(12) setdest 710.284540797399 1747.407811927457 8.695728882547"
+$ns_ at 33.723178908438 "$node_(38) setdest 1783.763462892112 1725.694410089237 21.976858235190"
+$ns_ at 35.110647844566 "$node_(24) setdest 338.574197470541 405.421187732843 23.798868617090"
+$ns_ at 36.496732226558 "$node_(18) setdest 719.381068489983 632.902749300605 14.879228087697"
+$ns_ at 37.164204135204 "$node_(28) setdest 209.903855298812 1840.816193256211 7.648666276029"
diff -u -r --new-file ./hls/utils/test_parameter.txt ../../ns-2.33-hls_working/ns-2.33/hls/utils/test_parameter.txt
--- ./hls/utils/test_parameter.txt	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/hls/utils/test_parameter.txt	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1 @@
+-out hls_trace.txt -sc sc-x2000-y2000-n100-s30-t100-MRD -cp cp-n100-c400-15-98.tcl -nn 100 -locs 3 -use_peri 1 -x 2000 -y 2000 -mac_emu 0 -stop 100 -zip 0
\ Kein Zeilenumbruch am Dateiende.
diff -u -r --new-file ./locservices/chc_caches.cc ../../ns-2.33-hls_working/ns-2.33/locservices/chc_caches.cc
--- ./locservices/chc_caches.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/chc_caches.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _CHC_Caches_cc
+#define _CHC_Caches_cc
+
+#include "chc.h"
+
+/******************/
+/* Location Cache */
+/******************/
+
+bool LSLocationCache::add(nodelocation* info) {
+    return (ChainedHashCache::add(info->id, (void*)(info)));
+}
+
+bool LSLocationCache::update(nodelocation* info) {
+    return (ChainedHashCache::update(info->id, (void*)(info)));
+}
+
+bool LSLocationCache::iupdate (void* ventry, void* vdata) {
+    if (((nodelocation*)ventry)->ts < ((nodelocation*)vdata)->ts) {
+	memcpy(ventry,vdata,sizeof(nodelocation));
+	return true;
+    }
+    return false;
+}
+
+bool LSLocationCache::itimeout (void* ventry) {
+    if (lifetime == 0) {
+	if (((((nodelocation*)ventry)->timeout) > 0.0) && 
+	    (Scheduler::instance().clock() > ((nodelocation*)ventry)->timeout))
+	{ return true; }
+    }else {
+	if ((Scheduler::instance().clock() - ((nodelocation*)ventry)->ts) > lifetime) 
+	{ return true; }
+	
+    }
+    return false;
+}
+
+void LSLocationCache::iprint (void* ventry) {
+    nodelocation* entry = (nodelocation*)ventry;
+    printf("(%d,%.2f/%.2f,%d:%d %.4f,%.4f)",entry->id,entry->loc.x,entry->loc.y,entry->sqr.grid,entry->sqr.order,entry->ts,entry->timeout);
+}
+
+/*****************/
+/* Request Cache */
+/*****************/
+
+bool LSRequestCache::add(locrequest* info) {
+    return (ChainedHashCache::add(info->dst, (void*)(info)));
+}
+
+bool LSRequestCache::update(locrequest* info) {
+    return (ChainedHashCache::update(info->dst, (void*)(info)));
+}
+
+bool LSRequestCache::iupdate (void* ventry, void* vdata) {
+    memcpy(ventry,vdata,sizeof(locrequest));
+    return true;
+}
+
+bool LSRequestCache::itimeout (void* ventry) {
+    if (lifetime == 0) { return false; }
+    if ((Scheduler::instance().clock() - ((locrequest*)ventry)->ts) > lifetime) 
+    { return true; }
+    return false;
+}
+
+void LSRequestCache::iprint (void* ventry) {
+    locrequest* entry = (locrequest*)ventry;
+    printf("(%d,%d,%d %.4f)",entry->dst,entry->seqno,entry->maxhop, entry->ts);
+}
+
+/***************/
+/* SeqNo Cache */
+/***************/
+
+bool LSSeqNoCache::add(seqnoentry* info) {
+    return (ChainedHashCache::add(info->key, (void*)(info)));
+}
+
+bool LSSeqNoCache::update(seqnoentry* info) {
+    return (ChainedHashCache::update(info->key, (void*)(info)));
+}
+
+const int LSSeqNoCache::find(const unsigned int key) {
+    void *tmp = ChainedHashCache::search(key);
+    if (tmp != NULL) {
+	return (((seqnoentry*)tmp)->seqno);
+    }else{ return (-1); }
+}
+
+bool LSSeqNoCache::iupdate (void* ventry, void* vdata) {
+    memcpy(ventry,vdata,sizeof(seqnoentry));
+    return true;
+}
+
+bool LSSeqNoCache::itimeout (void* ventry) {
+    if (lifetime == 0) { return false; }
+    if ((Scheduler::instance().clock() - ((seqnoentry*)ventry)->ts) > lifetime) 
+    { return true; }
+    return false;
+}
+
+void LSSeqNoCache::iprint (void* ventry) {
+    seqnoentry* entry = (seqnoentry*)ventry;
+    printf("(%d,%d, %.4f)",entry->key, entry->seqno, entry->ts);
+}
+
+/*********************/
+/* Suppression Cache */
+/*********************/
+
+bool LSSupCache::add(supinfo* info) {
+    return (ChainedHashCache::add(info->key, (void*)(info)));
+}
+
+bool LSSupCache::update(supinfo* info) {
+    return (ChainedHashCache::update(info->key, (void*)(info)));
+}
+
+bool LSSupCache::iupdate (void* ventry, void* vdata) {
+    memcpy(ventry,vdata,sizeof(supinfo));
+    return true;
+}
+
+bool LSSupCache::itimeout (void* ventry) {
+    if (lifetime == 0) { return false; }
+    if ((Scheduler::instance().clock() - ((supinfo*)ventry)->ts) > lifetime) 
+    { return true; }
+    return false;
+}
+
+void LSSupCache::iprint (void* ventry) {
+    supinfo* entry = (supinfo*)ventry;
+    printf("(%d,%d,%.2f,%d %.4f)",entry->key, entry->cnt, entry->dmin, (int)entry->blocked, entry->ts);
+}
+
+#endif
diff -u -r --new-file ./locservices/chc.cc ../../ns-2.33-hls_working/ns-2.33/locservices/chc.cc
--- ./locservices/chc.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/chc.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,250 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _CHC_cc
+#define _CHC_cc
+
+#include "chc.h"
+
+/*****************************/
+/* Base : Chained Hash Cache */
+/*****************************/
+
+//! updates an entry if necessary
+bool ChainedHashCache::update(unsigned int ikey, void* entry) {
+    
+    const unsigned int key = (ikey % size); 
+
+    cleanUp(key);
+
+    CHCEntry* last = table[key];
+    CHCEntry* tmp = table[key];
+
+    // Walk the Hash Chain and try to find an existing entry
+    while (tmp != NULL) {
+	if (tmp->key == ikey) {
+	    // Found entry
+	    iupdate(tmp->info,entry);
+	    return true;
+	}else{
+	    last = tmp;
+	    tmp = tmp->next;
+	}
+    }
+    return false;
+}
+
+//! adds a new entry or updates an old one   
+bool ChainedHashCache::add(unsigned int ikey, void* entry) {
+
+    const unsigned int key = (ikey % size); 
+
+    cleanUp(key);
+
+    CHCEntry* last = table[key];
+    CHCEntry* tmp = table[key];
+
+    // Walk the Hash Chain and try to find an existing entry
+    while (tmp != NULL) {
+	if (tmp->key == ikey) {
+	    // Found entry
+	    iupdate(tmp->info,entry);
+	    return false;
+	}else{
+	    last = tmp;
+	    tmp = tmp->next;
+	}
+    }
+
+    tmp = new CHCEntry;
+    tmp->key = ikey;
+
+    void* tinfo = inew();
+    if (tinfo == NULL) { 
+	printf("Warning: Could not generate CacheEntry !\n"); 
+	abort(); 
+    }
+    icopy(tinfo,entry);
+    tmp->info = tinfo;
+
+    // Correct list linkage
+    tmp->next = NULL;
+    tmp->prev = last;
+    if (last != NULL) { last->next = tmp; }
+
+    if (table[key] == NULL) { table[key] = tmp; }
+
+    return true;
+}
+
+//! removes an entry and returns the next element or NULL
+CHCEntry* ChainedHashCache::removeCHC(CHCEntry* victim) {
+
+    assert(victim != NULL);
+    CHCEntry* tmp = victim->next;
+
+    unsigned int key = (victim->key % size); 
+
+    // Correct successor
+    if (victim->next != NULL) { victim->next->prev = victim->prev; }
+    // Correct predecessor
+    if (victim->prev != NULL) { victim->prev->next = victim->next; }
+    // Correct Chain Head
+    if (table[key] == victim) { table[key] = victim->next; }
+
+    idelete (victim->info);
+    delete victim;
+    return tmp;
+}
+
+//! removes timed out entries from the selected hash chain
+void ChainedHashCache::cleanUp(const unsigned int ikey) {
+
+    CHCEntry* tmp = table[ikey];
+
+    while (tmp != NULL) {
+	if (itimeout(tmp->info)) {
+	    tmp = removeCHC(tmp);
+	}else{
+	    tmp = tmp->next;
+	}
+    }
+    return;
+}
+
+//! searches the cache for an entry that fits the key
+void* ChainedHashCache::search(unsigned int ikey) {
+
+    unsigned int key = (ikey % size); 
+
+    cleanUp(key);
+
+    CHCEntry* last = table[key];
+    CHCEntry* tmp = table[key];
+    while (tmp != NULL) {
+	if (tmp->key == ikey) {
+	    return tmp->info;
+	    break;
+	} else {
+	    last = tmp;
+	    tmp = tmp->next;
+	}
+    }
+    return NULL;
+}
+
+CHCEntry* ChainedHashCache::searchCHC(unsigned int ikey) {
+
+    unsigned int key = (ikey % size); 
+
+    cleanUp(key);
+
+    CHCEntry* last = table[key];
+    CHCEntry* tmp = table[key];
+    while (tmp != NULL) {
+	if (tmp->key == ikey) {
+	    return tmp;
+	    break;
+	} else {
+	    last = tmp;
+	    tmp = tmp->next;
+	}
+    }
+    return NULL;
+}
+
+//! searches the cache for an entry that fits the key
+void ChainedHashCache::remove(const unsigned int ikey) {
+
+    // Delete Entry
+    CHCEntry* tmp = searchCHC(ikey);
+    if (tmp != NULL) { removeCHC(tmp); }
+}
+
+//! print the table for debugging
+void ChainedHashCache::printTable() {
+
+    for (unsigned int i=0; i<size; i++) {
+	if (table[i] != NULL) {
+	    CHCEntry* tmp = table[i];
+	    printf("Row %d: ",i);
+	    while (tmp != NULL) {
+		iprint(tmp->info);
+		printf(" ");
+		tmp = tmp->next;
+	    }
+	    printf("\n");
+	}else{
+	    continue;
+	}
+    }   
+}
+
+//! print the table statistics for debugging
+void ChainedHashCache::printTableStats(const int id) {
+
+    double avg;
+    int max;
+
+    tableStats(&avg,&max);
+#ifndef PRINT_ONE_LINE
+    if (id != -1) {
+	printf("LocationCache Statistics for %d:\n",id);
+	printf("-------------------------------\n");
+    }else{
+	printf("LocationCache Statistics:\n");
+	printf("------------------------\n");
+    }
+    printf("Max. Line Usage       : %d\n",max);
+    printf("Average Line Usage    : %.4f\n",avg);
+#else
+    if (id != -1) {
+	printf("LocationCache Statistics for %d: %d\t%.4f\t\t\n",id,max,avg);
+    }else{
+	printf("LocationCache Statistics: %d\t%.4f\t\t\n",max,avg);
+    }
+#endif
+}
+
+//! evaluates some satistics for this CHC
+void ChainedHashCache::tableStats(double *avg_, int* max_) {
+
+    int avg = 0;
+    int max = 0;
+    int line = 0;
+    
+    for (unsigned int i=0; i<size; i++) {
+	if (table[i] != NULL) {
+	    cleanUp(i);
+	    line = 0;
+	    CHCEntry* tmp = table[i];
+	    while (tmp != NULL) {
+		avg++;
+		line++;
+		tmp = tmp->next;
+	    }
+	    if (line > max) { max = line; }
+	}else{
+	    continue;
+	}
+    }
+
+    if (max_ != NULL) { *max_ = max; }
+    if (avg_ != NULL) { *avg_ = avg/size; }
+}
+
+#endif //_CHC_cc
diff -u -r --new-file ./locservices/chc.h ../../ns-2.33-hls_working/ns-2.33/locservices/chc.h
--- ./locservices/chc.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/chc.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,180 @@
+#/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _CHC_h
+#define _CHC_h
+
+#include "hdr_locs.h"
+
+#define CHC_BASE_SIZE  97 /* Good prime for simple hash              */
+#define PRINT_ONE_LINE    /* Print output of TableStats as One-Liner */
+
+/**************/
+/* Base Class */
+/**************/
+
+class ChainedHashCache {
+
+ public:
+  ChainedHashCache(
+		   class LocationService* parent, 
+		   const unsigned int hash_size = CHC_BASE_SIZE, 
+		   const double lifetime = 0.0 )
+    {
+      this->parent = parent;
+      this->size = hash_size;
+      if (lifetime < 0.0) { this->lifetime = 0.0;      }
+      else                { this->lifetime = lifetime; }
+	    
+      table = new CHCEntry*[hash_size];
+	    
+      for (unsigned int i=0; i<hash_size; i++) {
+	table[i] = NULL;
+      }
+    }
+
+  virtual ~ChainedHashCache() {
+    for (unsigned int i=0; i < size; i++) {
+      while (table[i] != NULL) {
+	CHCEntry* tmp = table[i]->next;
+	table[i]->next->prev = NULL;
+	delete table[i];
+	table[i] = tmp;
+      }
+    }
+    delete[] table;
+  }
+
+  bool add(unsigned int ikey, void* entry);
+  bool update(unsigned int ikey, void* entry);
+  void* search(unsigned int ikey);
+  void remove(unsigned int ikey);
+    
+  // Unfortunately GLS needs access to all entries for its closest
+  // next hop scheme :( Maybe I'll find another way later - mk
+  CHCEntry** getTable(unsigned int *size) {
+    for (unsigned int i=0; i < this->size; i++) { cleanUp(i); }
+    (*size) = this->size;
+    return table;
+  }
+
+  void printTable();
+  void printTableStats(const int id = -1);
+  void tableStats(double *avg_, int* max_);
+
+ protected:
+  CHCEntry** table;
+  unsigned int size;
+  double lifetime;
+  class LocationService* parent;
+
+  CHCEntry* searchCHC(unsigned int ikey);
+  CHCEntry* removeCHC(CHCEntry* victim);
+  void cleanUp(const unsigned int ikey);
+
+  // Information handlers; Need to be overwritten
+  virtual bool iupdate(void*, void*) { return false; }
+  virtual bool itimeout(void*) { return false; }
+  virtual void* inew () = 0; 
+  virtual void idelete(void*) = 0;
+  virtual void icopy(void*, void*) = 0;
+  virtual void iprint(void*) = 0;
+};
+
+/*****************/
+/* Child Classes */
+/*****************/
+
+class LSLocationCache : public ChainedHashCache {
+ public:
+  LSLocationCache(class LocationService* parent, const unsigned int hash_size = CHC_BASE_SIZE, const double lifetime = 0.0 ) 
+    : ChainedHashCache(parent,hash_size,lifetime) {}
+  ~LSLocationCache() {}
+
+  bool add(nodelocation*);
+  bool update(nodelocation*);
+
+ private:
+  bool iupdate (void*, void*);
+  bool itimeout (void*);
+  void iprint (void*);
+  inline void* inew() { return ((void*)(new nodelocation)); }
+  inline void idelete (void* ventry) { delete (nodelocation*)ventry; }
+  inline void icopy (void* ventry, void* vdata) { memcpy(ventry,vdata,sizeof(nodelocation)); }
+};
+
+class LSRequestCache : public ChainedHashCache {
+ public:
+  LSRequestCache(class LocationService* parent, const unsigned int hash_size = CHC_BASE_SIZE, const double lifetime = 0.0 ) 
+    : ChainedHashCache(parent,hash_size,lifetime) {}
+  ~LSRequestCache() {}
+
+  bool add(locrequest*);
+  bool update(locrequest*);
+
+ private:
+  bool iupdate (void*, void*);
+  bool itimeout (void*);
+  void iprint (void*);
+
+  inline void* inew() { return ((void*)(new locrequest)); }
+  inline void idelete (void* ventry) { delete (locrequest*)ventry; }
+  inline void icopy (void* ventry, void* vdata) { memcpy(ventry,vdata,sizeof(locrequest)); }
+};
+
+class LSSeqNoCache : public ChainedHashCache {
+ public:
+  LSSeqNoCache(class LocationService* parent, const unsigned int hash_size = CHC_BASE_SIZE, const double lifetime = 0.0 ) 
+    : ChainedHashCache(parent,hash_size,lifetime) {}
+  ~LSSeqNoCache() {}
+
+  bool add(seqnoentry*);
+  bool update(seqnoentry*);
+  const int find(const unsigned int);
+
+ private:
+  bool iupdate (void*, void*);
+  bool itimeout (void*);
+  void iprint (void*);
+
+  inline void* inew() { return ((void*)(new seqnoentry)); }
+  inline void idelete (void* ventry) { delete (seqnoentry*)ventry; }
+  inline void icopy (void* ventry, void* vdata) { memcpy(ventry,vdata,sizeof(seqnoentry)); }
+};
+
+class LSSupCache : public ChainedHashCache {
+ public:
+  LSSupCache(class LocationService* parent, 
+	     const unsigned int hash_size = CHC_BASE_SIZE, 
+	     const double lifetime = 0.0 ) 
+    : ChainedHashCache(parent,hash_size,lifetime) {}
+  ~LSSupCache() {}
+
+  bool add(supinfo*);
+  bool update(supinfo*);
+
+ private:
+  bool iupdate (void*, void*);
+  bool itimeout (void*);
+  void iprint (void*);
+
+  inline void* inew() { return ((void*)(new supinfo)); }
+  inline void idelete (void* ventry) { delete (supinfo*)ventry; }
+  inline void icopy (void* ventry, void* vdata) { memcpy(ventry,vdata,sizeof(supinfo)); }
+};
+
+#endif //_CHC_h
diff -u -r --new-file ./locservices/gridlocservice.cc ../../ns-2.33-hls_working/ns-2.33/locservices/gridlocservice.cc
--- ./locservices/gridlocservice.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/gridlocservice.cc	2006-04-05 15:15:58.000000000 +0200
@@ -0,0 +1,1508 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _GridLocService_cc
+#define _GridLocService_cc
+
+#include "gridlocservice.h"
+#include "../gpsr/gpsr.h"
+#include <math.h>
+#include <random.h>
+#include <cmu-trace.h>
+
+#include "chc.h"
+
+/*
+  Notes/ToDo:
+  - callback() can handle Pkt's that the node wanted to send, but couldn't.
+    maybe we'll use it to clean caches or forward pkts
+  - loccache has a static timeout for every entry.
+  - loctable saves updates for a fixed time, that is specified in the update packet
+  - no next locserver and missing targets, should send feedback packets to the sender.
+    otherwise we use the same dead route every time :(
+  - order handling is a bit hacked (too many patches :( ) should be cleaned
+  - loccache is used for updates and everything else, which might destroy the GLS properties.
+    i probably need to test a seperate loccache/poscache approach.
+  - query forwarding should check tables first, because GLS is based on the hierachy distributed in the tables not the caches.
+
+  - location notifications need some knowledge about data traffic to know what a live connection
+    is. Unfortunately this can not be done with GPSR atm. So the mechanism is implemented, but
+    can not be used. :(
+*/
+
+/********************/
+/* Expire Functions */
+/********************/
+
+void GLSRequestScheduler::handle() {
+    ls_->unansweredRequest(local_key);
+}
+
+void GLSUpdateScheduler::handle() {
+    ls_->nackedUpdate((updcacheentry*)local_info);
+}
+
+void GLSUpdateScheduler::deleteInfo(void* info) {
+    delete (updcacheentry*)info;
+}
+
+/*******/
+/* GLS */
+/*******/
+
+GridLocService::GridLocService(Agent* p)
+    : LocationService(p)
+{
+    parent = p;
+    loccache  = new LSLocationCache(this,GLS_LOCCACHE_SIZE,GLS_LOCCACHE_TIMEOUT);
+    loctable  = new LSLocationCache(this,GLS_LOCTABLE_SIZE);
+    reqtable  = new LSRequestCache(this,GLS_REQTABLE_SIZE);
+
+    liveconns = new ConnectionCache(this,GLS_LIVECONN_TIMEOUT);
+
+    updtimer = new UpdateTimer(this);
+    reqtimer = new GLSRequestScheduler(this,GLS_HEAP_SIZE);   
+#ifdef ALLOW_ACKED_UPDATES
+    updcache = new GLSUpdateScheduler(this,GLS_HEAP_SIZE);
+#endif
+}
+
+GridLocService::~GridLocService() {
+    delete loccache;
+    delete loctable;
+    delete reqtable;
+    delete liveconns;
+    delete reqtimer;
+#ifdef ALLOW_ACKED_UPDATES
+    delete updcache;
+#endif
+}
+
+void GridLocService::init() {
+
+    // Initialize Topology Info
+    {
+	// Get the max x, y coordinates of the entire terrain
+	double maxx = mn_->T_->upperX();
+	double maxy = mn_->T_->upperY();
+	
+	double len;
+	if (maxx>maxy) len = maxx;
+	else           len = maxy;
+
+	if (len > (sizeof(int)*8*GLS_SMALLEST_GRID)) {
+	    printf("Scenario is too big for this Grid Size on a %d-bit Machine\n",sizeof(int)*8); 
+	    exit(1);
+	}
+
+	double smallest_grids = len / GLS_SMALLEST_GRID;
+	max_order = (int)smallest_grids; // primitive ceiling
+	while (smallest_grids <= (1 << max_order)) { max_order--; }
+	max_order++; // correct offset
+	if (max_order < 0) { max_order=0; }// primitive floor
+
+	max_len = ((1 << max_order) * GLS_SMALLEST_GRID);
+    }
+
+    // Initialize Fields for LocUpdate 
+    prevloc = getNodeInfo();
+    predto = 0;
+    prevlevel = max_order;
+
+    // Schedule first UpdTimer Event
+    updtimer->sched(0.0);
+}
+
+void GridLocService::recv(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    if ((iph->saddr() == parent->addr()) && (cmnh->num_forwards() == 0)) {
+	// New Paket by me
+	piggybackLocation(p);
+    }else{
+	// Other packets
+	updateLocation(p);
+    }
+
+    if (locsh->valid_) {
+      
+	// Location Service Packet that needs to be processed
+	switch (locsh->type_) {
+	    case LOCS_UPDATE:     { recvUpdate(p); break; }
+	    case LOCS_REQUEST:    { recvRequest(p); break; }
+	    case LOCS_REPLY:      { recvReply(p); break; }
+	    case LOCS_NOTIFY:     { recvNotify(p); break; }
+	    case LOCS_UPDATE_ACK: { recvUpdAck(p); break; }
+	    case LOCS_DATA:       { break; }
+	}	
+    }
+}
+
+void GridLocService::callback(Packet* &p) {
+
+    // Do we need to evaluate callbacks for 
+    // Cache consistency or forwarding ?
+
+    // For Tracing we mark the pkt as callback
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    if (locsh->valid_) { locsh->callback_ = 1; }
+    
+}
+
+void GridLocService::updatePosition(struct nodelocation &entry, struct hdr_ip* iph /* = NULL */) {
+  struct nodelocation* tmp = NULL;
+
+  tmp = (nodelocation*)loccache->search(entry.id);
+
+  if ((tmp!=NULL) && (tmp->ts > entry.ts)) {
+    if (GLS_DEBUG>=2) {
+      trace("LSUPOS: %.12f _%d_ [%d %.4f %.2f %.2f] to [%d %.4f %.2f %.2f]",
+		    Scheduler::instance().clock(),
+		    parent->addr(),
+		    entry.id, entry.ts, entry.loc.x, entry.loc.y,
+		    tmp->id, tmp->ts, tmp->loc.x, tmp->loc.y);
+    }
+    // Update
+    entry.ts = tmp->ts;
+    entry.loc = tmp->loc;
+    entry.sqr = tmp->sqr;
+    if (iph != NULL) {
+      // Update GPSR Routing Info
+      iph->dx() = tmp->loc.x;
+      iph->dy() = tmp->loc.y;
+      iph->dz() = tmp->loc.z;
+    }
+  }
+}
+
+void GridLocService::updateLocation(Packet *p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    // Try to update Location Info of Packets
+    if (locsh->valid_) {
+      
+	switch (locsh->type_) {
+
+	    case LOCS_UPDATE:
+		if (locsh->in_correct_grid)
+		    updatePosition(locsh->next,iph);
+		break;
+	    case LOCS_REQUEST:
+		updatePosition(locsh->next,iph);
+		break;
+	    case LOCS_UPDATE_ACK:
+	    case LOCS_REPLY:
+	    case LOCS_DATA:
+		updatePosition(locsh->dst,iph);
+		break;
+	    default:
+		break;
+	}
+	updatePosition(locsh->src);
+    }
+}
+
+
+void GridLocService::piggybackLocation(Packet *p) {
+    
+    // Don't piggyback LS Packets
+    if (HDR_CMN(p)->ptype()== PT_LOCS) { return; }
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Piggyback Info of this Node
+    if (locsh->valid_ == 0)
+	locsh->init();
+    locsh->type_ = LOCS_DATA;
+    locsh->src.id = parent->addr();
+    locsh->src.ts = Scheduler::instance().clock();
+    mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+    locsh->src.sqr = getGrid(); 
+}
+
+void GridLocService::evaluatePacket(const Packet *p) {
+    evaluateLocation((Packet*)p);
+}
+
+void GridLocService::evaluateLocation(Packet *p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    if ((cmnh->ptype()==PT_GPSR)&&(gpsrh->mode_ == GPSRH_BEACON)) {
+	// Direct Neighbor Information from GPSR Beacons
+	struct nodelocation neighb;
+
+	neighb.id = iph->saddr();
+	neighb.ts = Scheduler::instance().clock(); // Off by a few because Beacons don't have a TS
+	neighb.loc.x = gpsrh->hops_[0].x;
+	neighb.loc.y = gpsrh->hops_[0].y;
+	neighb.loc.z = gpsrh->hops_[0].z;
+	// Reverse lookup of Grid Info
+	neighb.sqr = getGrid(neighb.loc.x,neighb.loc.y);
+
+	loccache->add(&neighb);
+	loctable->update(&neighb);
+
+	return;
+    }
+
+    if (locsh->valid_) {
+      
+	bool new_entry;
+	struct nodelocation* eval = NULL;
+
+	switch (locsh->type_) {
+
+	    case LOCS_UPDATE:
+		if (locsh->in_correct_grid){ eval = &(locsh->next); } 
+		break;
+	    case LOCS_REQUEST: 
+		eval = &(locsh->next); 
+		break;
+	    case LOCS_UPDATE_ACK:
+	    case LOCS_REPLY:
+	    case LOCS_NOTIFY:
+	    case LOCS_DATA:
+		eval = &(locsh->dst); 
+		break; 
+	    default:
+		break;
+	}
+
+	// Evaluate extra Info:
+	//  - update Location Table Entries
+	//  - add/update Location Cache Entries
+	if (eval != NULL) {
+	    loctable->update(eval);
+	    new_entry = loccache->add(eval);
+	    if ((GLS_IMMEDIATE_NOTIFICATION) && (new_entry))
+		parent->notifyPos(eval->id); 
+	}
+
+	// Every Packet has SRC Info
+	loctable->update(&(locsh->src));
+	new_entry = loccache->add(&(locsh->src));
+
+	if ((GLS_IMMEDIATE_NOTIFICATION) && (new_entry))
+	    parent->notifyPos(locsh->src.id); 
+      
+    }
+}
+
+void GridLocService::recvUpdate(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    // Don't process my own updates
+    if ((iph->saddr() == parent->addr()) && (cmnh->num_forwards() == 0)) { return; }
+
+    // Packet is in the right grid and is searching
+    //  for the right server. Let it be.
+    if ((locsh->in_correct_grid) && (iph->daddr() != parent->addr())) {
+      return;
+    }
+
+    // Check if we're in the to-be-updated grid
+    if (inSameGrid(getNodeInfo(),locsh->dst)) {
+
+	// Mark Pkt as been in the correct grid
+	locsh->in_correct_grid = true;
+
+	// If we can't forward this packet to a "better" node,
+	// we are the locserver for this node in this square
+	if (!forwardUpdate(p)) { 
+
+	    if (true) {
+		struct nodelocation me = getNodeInfo();
+		trace("LSCLS: %.12f _%d_ [%d] for %d [%d] in %d",
+			      Scheduler::instance().clock(),
+			      parent->addr(),
+			      me.sqr.grid,
+			      locsh->src.id,
+			      locsh->src.sqr.grid,
+			      locsh->dst.sqr.order);   
+	    }
+	    
+	    loctable->add(&(locsh->src));
+
+#ifdef ALLOW_ACKED_UPDATES
+	    // Send ACK to SRC
+	    struct nodelocation info;
+	    info.id = parent->addr();
+	    info.ts = Scheduler::instance().clock();
+	    mn_->getLoc(&info.loc.x, &info.loc.y, &info.loc.z);
+	    info.sqr = getGrid();
+
+	    Packet *pkt = newUpdAck(p,&info);
+	    Packet::free(p);
+	    p = pkt;
+	    return;
+#else
+	    Packet::free(p);
+	    p = NULL;
+	    return;
+#endif
+	}
+	return;
+    }
+
+    // Has Pkt been in the correct grid
+    if (locsh->in_correct_grid) {
+
+	// Outdated info made someone believe that
+	//  we're in the right grid. Send Updates
+	//  to clarify our position
+	sendUpdates((locsh->dst.sqr.order)+1);
+
+	// Reset Update and delay it till the sent 
+	//  updates have reached their target grids.
+
+	// Reset DST to Target Grid 
+	iph->daddr() = NO_NODE; 
+	iph->dx_ = locsh->dst.loc.x;
+	iph->dy_ = locsh->dst.loc.y;
+	iph->dz_ = locsh->dst.loc.z;
+
+	// Reset Update State
+	locsh->in_correct_grid = false;
+
+	// Reset next Target Info
+	locsh->next.id = NO_NODE;
+	locsh->next.ts = -1.0;
+	locsh->next.loc.x = -1.0;
+	locsh->next.loc.y = -1.0;
+	locsh->next.loc.z = -1.0;
+	locsh->next.sqr.grid = -1;
+	locsh->next.sqr.order = 0;
+
+	// Warn about this Event
+	if (GLS_DEBUG>=2)
+	  trace("LSResetUPD: %.12f _%d_ %d (%d->%d)",
+			Scheduler::instance().clock(),
+			parent->addr(),
+			locsh->src.id,
+			locsh->src.sqr.grid,
+			locsh->dst.sqr.grid);  
+
+	// Delay with some buffer time
+	double delay = 2 * (locsh->dst.sqr.order+1) * Random::uniform(GLS_UPD_JITTER); 
+	Scheduler::instance().schedule(parent,p,delay);
+	p = NULL;
+	return;
+    }
+}
+
+void GridLocService::recvReply(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Check if the reply is for me
+    if (locsh->dst.id == parent->addr()) {
+
+	// Packet has been evaluated, discard it
+
+	if (GLS_DEBUG>=1)
+	    trace("LSRR: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  locsh->src.id,
+			  locsh->dst.id);            
+	
+        // Cancel all pending Requests
+	reqtimer->remove(locsh->src.id);
+
+        // Delete Request Entry in ReqTable
+	reqtable->remove(locsh->src.id);
+
+	// Notify SendBuffer - done in evaluation
+
+	Packet::free(p);
+	p = NULL;
+    }   
+}
+
+
+void GridLocService::recvNotify(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Check if the notification is for me
+    if (locsh->dst.id == parent->addr()) {
+
+	// Packet has been evaluated, discard it
+
+	if (GLS_DEBUG>=1)
+	    trace("LSRN: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  locsh->src.id,
+			  locsh->dst.id);            
+	
+        // Cancel all pending Requests
+	reqtimer->remove(locsh->src.id);
+
+        // Delete Request Entry in ReqTable
+	reqtable->remove(locsh->src.id);
+
+	Packet::free(p);
+	p = NULL;
+    }   
+}
+
+
+void GridLocService::recvUpdAck(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Check if the ack is for me
+    if (locsh->dst.id == parent->addr()) {
+
+	if (GLS_DEBUG>=3)
+	    trace("LSRACK: %.12f _%d_ (%d->%d) [%d:%d]",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  locsh->src.id,
+			  locsh->dst.id,
+			  locsh->upddst_.grid,
+			  locsh->upddst_.order);            
+	
+	unsigned int key = key(locsh->upddst_.grid,locsh->upddst_.order);
+
+        // Cancel all pending Events
+	updcache->remove(key);
+
+	Packet::free(p);
+	p = NULL;
+    }   
+}
+
+void GridLocService::recvRequest(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    // Don't process my own requests
+    if ((iph->saddr() == parent->addr()) && (cmnh->num_forwards() == 0)) { return; }
+
+    // Request queries for me, answer it
+    if (locsh->dst.id == parent->addr()) {
+
+      struct nodelocation info;
+      info.id = parent->addr();
+      info.ts = Scheduler::instance().clock();
+      mn_->getLoc(&info.loc.x, &info.loc.y, &info.loc.z);
+      info.sqr = getGrid();
+
+      Packet *pkt = newReply(p,&info);
+      Packet::free(p);
+      p = pkt;
+
+      if (GLS_DEBUG>=1) {
+	struct hdr_locs *rep_locsh = HDR_LOCS(pkt);
+	trace("LSSOR: %.12f _%d_ (%d->%d)",
+		      Scheduler::instance().clock(),
+		      parent->addr(),
+		      rep_locsh->src.id,
+		      rep_locsh->dst.id);         
+      }
+
+      return;
+    }
+
+    if (iph->daddr() == parent->addr()) {
+
+	// I'm the Target LocServer and should forward the Request
+	//  to the next LocServer or the DST itself
+	sendRequest(p);
+
+    }
+    
+    // Request is on it's way, leave it alone
+}
+
+void GridLocService::sendRequest(Packet* &p, bool fresh /* = false */) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    // Define common fields
+    cmnh->direction() = hdr_cmn::DOWN;
+
+    // NOTE: I think we should query the table first and the cache later,
+    //       because the GLS routing hierarchy is based on the tables.
+    //       Caches should only have backup capacity - mk
+
+    // Check Location Cache for the Position of the Next LocServer
+    //struct nodelocation* nxtLocServer = findClosest(loccache,locsh->dst);
+    struct nodelocation* nxtLocServer = findClosest(loctable,locsh->dst);
+
+    // If LocCache did not produce results 
+    // Check Location Table for the Position of the Next LocServer
+    //if (!nxtLocServer) { nxtLocServer = findClosest(loctable,locsh->dst); }
+    if (!nxtLocServer) { nxtLocServer = findClosest(loccache,locsh->dst); }
+
+    if (!nxtLocServer) {
+	// No Next LocServer Drop
+	parent->drop(p,DROP_LOCS_NONXTLS);
+	Packet::free(p);
+	p = NULL;
+	return;
+    }
+
+    // Found Next Hop or DST
+    locsh->next.id = nxtLocServer->id;
+    locsh->next.ts = nxtLocServer->ts;
+    locsh->next.loc = nxtLocServer->loc;
+    locsh->next.sqr = nxtLocServer->sqr;
+
+    // Mark Next LocServer as DST 
+    iph->daddr() = nxtLocServer->id;
+    iph->dx() = nxtLocServer->loc.x;
+    iph->dy() = nxtLocServer->loc.y;
+    iph->dz() = nxtLocServer->loc.z;
+    
+    cmnh->next_hop_ = nxtLocServer->id;
+
+    if (fresh) {
+	// Send
+	parent->recv(p,(Handler *)0);
+	p = NULL;
+    }
+}
+
+bool GridLocService::forwardUpdate(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    // Define common fields
+    cmnh->direction() = hdr_cmn::DOWN;
+
+    struct nodelocation* dst = &(locsh->dst);
+
+    // Check Location Cache for the Position of the Next LocServer in this Grid
+    struct nodelocation* nxtLocServer = findClosest(loccache,locsh->src,dst);
+
+    // If LocCache did not produce results 
+    // Check Location Table for the Position of the Next LocServer in this Grid
+    if (!nxtLocServer) { nxtLocServer = findClosest(loctable,locsh->src,dst); }
+
+    if (!nxtLocServer) { return false; }
+
+    // Found Next Hop or DST
+    
+    // Mark Routing Info for Updating
+    locsh->next.id = nxtLocServer->id;
+    locsh->next.ts = nxtLocServer->ts;
+    locsh->next.loc = nxtLocServer->loc;
+    locsh->next.sqr = nxtLocServer->sqr;
+
+    // Mark Next LocServer as DST
+    iph->daddr() = nxtLocServer->id;
+    iph->dx() = nxtLocServer->loc.x;
+    iph->dy() = nxtLocServer->loc.y;
+    iph->dz() = nxtLocServer->loc.z;
+    
+    cmnh->next_hop_ = nxtLocServer->id;
+
+    return true;
+}
+
+bool GridLocService::poslookup(Packet *p) {
+    
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Prune Location Service Packets
+    if (HDR_CMN(p)->ptype()== PT_LOCS) { return true; }
+    
+    // Check Location Cache for the Position of the DST
+    struct nodelocation* qryTarget = (nodelocation*)loccache->search(iph->daddr());
+
+    // If LocCache did not produce results 
+    // Check Location Table for the Position of the DST
+    if (!qryTarget) { qryTarget = (nodelocation*)loctable->search(iph->daddr()); }
+
+    if (qryTarget) {
+	
+	// Found Location in Cache or Table
+	if (GLS_DEBUG>=3)
+	    trace("LSIIC: %.12f _%d_ [%d %.4f %.2f %.2f]",      
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  qryTarget->id,
+			  qryTarget->ts,
+			  qryTarget->loc.x,
+			  qryTarget->loc.y);
+
+	// Mark DST 
+	iph->dx() = qryTarget->loc.x;
+	iph->dy() = qryTarget->loc.y;
+	iph->dz() = qryTarget->loc.z;
+      
+	// Mark DST for LocService
+	locsh->dst.id = qryTarget->id;
+	locsh->dst.ts = qryTarget->ts;
+	locsh->dst.loc = qryTarget->loc;
+	locsh->dst.sqr = qryTarget->sqr;
+
+	// Update SRC Info
+	locsh->type_ = LOCS_DATA;
+	locsh->src.id = parent->addr();
+	locsh->src.ts = Scheduler::instance().clock();
+	locsh->src.sqr = getGrid();
+	mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+      
+	return true;
+    }
+
+    // No Location can be found in the LocCache or LocTable, so we'll
+    // check if the dst is already queried and if it is not, we'll
+    // send a Location Request Packet
+
+    // Check if DST has been Queried
+
+    locrequest* request = (locrequest*)reqtable->search(iph->daddr());
+
+    if (!request) {
+	
+	// DST has not been queried in a long time (if ever)
+
+	Packet *pkt = newRequest(iph->daddr());
+	
+	// Remember this request
+	struct hdr_locs *locshdr = HDR_LOCS(pkt);
+	// NOTE: I use maxhop_ & seqno_ to implement a cheap upper limit
+	//       for requests
+	unsigned int nownr = 0;
+	unsigned int maxnr = GLS_MAX_REQUESTS;
+	struct locrequest tmpreq = { iph->daddr(), Scheduler::instance().clock(), maxnr, nownr };
+	reqtable->add(&(tmpreq));
+
+	// Schedule next Request Cycle
+	double delay =  (0.5 * ((double) (0x1 << (2 * nownr) )));
+	reqtimer->add(iph->daddr(), delay);
+
+	if (GLS_DEBUG>=1)
+	    trace("LSSRC: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  locshdr->src.id,
+			  locshdr->dst.id);     
+	
+	sendRequest(pkt,true);  
+	
+    }else{
+
+	// Request has been sent and is handled by timer 
+	if (GLS_DEBUG>=3)
+	    trace("LSRCIP: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  iph->saddr(),
+			  iph->daddr()); 
+	
+    }
+    
+    return false;
+}
+
+Packet* GridLocService::newReply(Packet* req, struct nodelocation* infosrc) {
+
+    Packet *pkt = parent->allocpkt();
+	
+    struct hdr_ip *req_iph = HDR_IP(req);
+    struct hdr_locs *req_locsh = HDR_LOCS(req);
+
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+
+    locsh->init();
+    locsh->type_ = LOCS_REPLY;
+    locsh->seqno_ = 0;
+
+    locsh->src.id = infosrc->id;
+    locsh->src.ts = infosrc->ts;
+    locsh->src.loc = infosrc->loc;
+    locsh->src.sqr = infosrc->sqr; 
+
+    locsh->dst.id = req_locsh->src.id;
+    locsh->dst.ts = req_locsh->src.ts;
+    locsh->dst.loc = req_locsh->src.loc;
+    locsh->dst.sqr = req_locsh->src.sqr;
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    iph->daddr() = req_iph->saddr();
+    iph->ttl() = GLS_TTL;
+
+    iph->dx_ = req_locsh->src.loc.x;
+    iph->dy_ = req_locsh->src.loc.y;
+    iph->dz_ = req_locsh->src.loc.z;
+
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Requests need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    
+    return pkt;
+} 
+
+Packet* GridLocService::newRequest(nsaddr_t dst_) {
+
+    Packet *pkt = parent->allocpkt();
+	
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+	
+    locsh->init();
+    locsh->type_ = LOCS_REQUEST;
+    locsh->src.id = parent->addr();
+    locsh->src.ts = Scheduler::instance().clock();
+    mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+    locsh->src.sqr = getGrid();
+
+    locsh->dst.id = dst_;
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    iph->daddr() = dst_;
+    iph->ttl() = GLS_TTL;
+
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Requests need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    
+    return pkt;
+} 
+
+Packet* GridLocService::newUpdate(struct nodelocation* dst_) {
+
+    Packet *pkt = parent->allocpkt();
+	
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+
+    locsh->init();
+    locsh->type_ = LOCS_UPDATE;
+    locsh->seqno_ = 0;
+
+    locsh->dst.loc = dst_->loc;
+    locsh->dst.sqr = dst_->sqr; 
+
+    locsh->src.id = parent->addr();
+    locsh->src.ts = Scheduler::instance().clock();
+    mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+    locsh->src.sqr = getGrid();
+    // Predict the valid time for this Update
+    //  depending on the level it is sent to
+    int level = dst_->sqr.order + 1;
+    locsh->src.timeout = (predto * level) + Scheduler::instance().clock();
+
+    // For clarity the grid center is considered our next target
+    locsh->next.loc = dst_->loc;
+    locsh->next.sqr = dst_->sqr; 
+
+    // Traceing
+    locsh->updreason_ = upd_reason;
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    iph->daddr() = NO_NODE; // For now. Might cause problems
+    iph->ttl() = GLS_TTL;
+
+    // Let GPSR route this pkt to the center of the target square
+    iph->dx_ = dst_->loc.x;
+    iph->dy_ = dst_->loc.y;
+    iph->dz_ = dst_->loc.z;
+
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Updates need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    
+    return pkt;
+} 
+
+Packet* GridLocService::newUpdAck(Packet* upd, struct nodelocation* infosrc) {
+
+    Packet *pkt = parent->allocpkt();
+	
+    struct hdr_ip *upd_iph = HDR_IP(upd);
+    struct hdr_locs *upd_locsh = HDR_LOCS(upd);
+
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+
+    locsh->init();
+    locsh->type_ = LOCS_UPDATE_ACK;
+    locsh->seqno_ = 0;
+
+    locsh->src.id = infosrc->id;
+    locsh->src.ts = infosrc->ts;
+    locsh->src.loc = infosrc->loc;
+    locsh->src.sqr = infosrc->sqr; 
+
+    locsh->dst.id = upd_locsh->src.id;
+    locsh->dst.ts = upd_locsh->src.ts;
+    locsh->dst.loc = upd_locsh->src.loc;
+    locsh->dst.sqr = upd_locsh->src.sqr;
+
+    locsh->upddst_ = upd_locsh->dst.sqr;
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    iph->daddr() = upd_iph->saddr();
+    iph->ttl() = GLS_TTL;
+
+    iph->dx_ = upd_locsh->src.loc.x;
+    iph->dy_ = upd_locsh->src.loc.y;
+    iph->dz_ = upd_locsh->src.loc.z;
+
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Requests need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    
+    return pkt;
+} 
+
+Packet* GridLocService::newNotify(struct nodelocation* dst_) {
+
+    Packet *pkt = parent->allocpkt();
+	
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    struct hdr_gpsr *gpsrh = HDR_GPSR(pkt);
+
+    locsh->init();
+    locsh->type_ = LOCS_NOTIFY;
+    locsh->seqno_ = 0;
+
+    locsh->dst.id = dst_->id;
+    locsh->dst.ts = dst_->ts;
+    locsh->dst.loc = dst_->loc;
+    locsh->dst.sqr = dst_->sqr; 
+
+    locsh->src.id = parent->addr();
+    locsh->src.ts = Scheduler::instance().clock();
+    mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+    locsh->src.sqr = getGrid();
+
+    locsh->next.loc = dst_->loc;
+    locsh->next.sqr = dst_->sqr; 
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    iph->daddr() = dst_->id;
+    iph->ttl() = GLS_TTL;
+
+    iph->dx_ = dst_->loc.x;
+    iph->dy_ = dst_->loc.y;
+    iph->dz_ = dst_->loc.z;
+
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->xmit_failure_ = 0;
+
+    // All Location Updates need to be transported by GPSR as Data Pkts
+    gpsrh->mode_ = GPSRH_DATA_GREEDY;
+    gpsrh->port_ = hdr_gpsr::LOCS;
+    
+    return pkt;
+} 
+
+/************************/
+/* GLS Packet Functions */
+/************************/
+
+void GridLocService::unansweredRequest(nsaddr_t id) {
+
+    locrequest* request = (locrequest*)reqtable->search(id);
+
+    if (request == NULL) {
+	printf("Warning: Timer tried to access invalid Request ! Check Table/Timer Synchronisation.\n");
+	exit(1);
+    }
+
+    unsigned int nownr = request->seqno + 1;
+    if (nownr < request->maxhop) {
+	
+	// We may try again
+
+	Packet *pkt = newRequest(id);
+	  
+	// Remember this request
+	struct hdr_locs *locsh = HDR_LOCS(pkt);
+
+	struct locrequest tmpreq = { id, Scheduler::instance().clock(), request->maxhop, nownr };
+	reqtable->add(&tmpreq);
+
+	// Schedule next Request Cycle
+	double delay =  (0.5 * ((double) (0x1 << (2 * nownr) )));
+	// Limit request delay
+	if (delay >= GLS_REQUEST_MAX_PERIOD) { delay = GLS_REQUEST_MAX_PERIOD; }
+	reqtimer->add(locsh->dst.id, delay);
+
+	if (GLS_DEBUG>=2)
+	    trace("LSNRC: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  locsh->src.id,
+			  locsh->dst.id);
+	
+	sendRequest(pkt,true);
+    }else{
+
+      // We tried some, and now we wait for the SendBuffer to
+      //  initiate a new cycle (making sure the pkt still exists)
+      reqtable->remove(id);
+
+    }
+    
+}
+
+void GridLocService::sendUpdates(unsigned int order) {
+
+    if (order == 0) { 
+	printf("Warning: Tried to send Updates to my own grid !\n"); 
+	return; 
+    }
+
+    int grid = -1;
+    int mygrid = (getGrid()).grid;
+
+    // Get Base Value for all order-(n-1) squares of order-n
+    int base = mygrid & (0xffffffff << shiftVal(order));
+
+    if (GLS_DEBUG>=3)
+      trace("LSSUPD: %.12f _%d_ [%d]->(%d)",
+		    Scheduler::instance().clock(),
+		    parent->addr(),
+		    mygrid,
+		    order);
+
+    // Correct mygrid for hierarchy level 
+    mygrid = (mygrid & (0xffffffff << shiftVal(order-1)));
+    
+    // Send to all 3 order-(n-1) squares that make up the 
+    //  order-n square with my order-(n-1) square
+    for (int i=0;i<4;i++) {
+	grid = base + (i << shiftVal(order-1));
+
+	// Don't send to my own square
+	if (grid == mygrid) { continue; }
+
+	struct nodelocation dst;
+	dst.loc = getGridPos(grid,order-1);
+	dst.sqr.grid = grid;
+	dst.sqr.order = order-1;
+	
+	// Generate Update
+	Packet *p = newUpdate(&dst);
+
+#ifdef ALLOW_ACKED_UPDATES
+	// Keep Info about this Update
+	updcacheentry* target = new updcacheentry;
+	target->sqr = dst.sqr;
+	target->cnt = 0;
+	unsigned int key = key(target->sqr.grid,target->sqr.order);
+	double findelay = // Scales a little with order and number
+	    (double)((target->sqr.order) << (target->cnt)) + 
+	    Random::uniform(GLS_UPD_JITTER); 
+	updcache->add(key,findelay,(void*)target);
+#endif
+
+	// Send Updates jittered, to avoid collisions
+	//  and solve bootstrapping issue
+	double delay = order * Random::uniform(GLS_UPD_JITTER);
+	Scheduler::instance().schedule(parent,p,delay);
+
+	p = NULL;
+    }
+}
+
+void GridLocService::updateLocServers() {
+
+    // get up-to-date Info
+    struct nodelocation nowloc = getNodeInfo();
+
+    // Check for border crossing
+    for(int level = 1; level <= max_order; level++) {
+	if (!inSameGrid(nowloc,prevloc,level)) {
+	    // Send Updates to LocServers of all hierarchy 
+	    //  levels that have changed
+	    upd_reason = "XING";
+	    sendUpdates(level+1);
+	}
+    }
+
+    // Check for exceeded update distance or timeout
+    double dx = (nowloc.loc.x-prevloc.loc.x); dx *= dx;
+    double dy = (nowloc.loc.y-prevloc.loc.y); dy *= dy; 
+    double distance = sqrt(dx+dy);
+    double age = (nowloc.ts - prevloc.ts);
+
+    if ((distance >= GLS_UPDATE_DISTANCE) || (age > predto)) {
+
+	// Distance has higher priority in Trace
+	if (age > predto) { upd_reason = "PRED"; }
+	if (distance >= GLS_UPDATE_DISTANCE) { upd_reason = "DIST"; }
+
+	// Set Timeout for Updates
+	if (mn_->speed() != 0) {
+	    predto = (double)(2*GLS_UPDATE_DISTANCE)/mn_->speed();
+	}
+
+	// Higher Hierarchies get fewer Updates
+	for(unsigned int level = 1; level <= prevlevel; level++) {
+	    // Send Updates to all LocServers of this level
+	    sendUpdates(level);
+	}
+	// Reset Level Counter
+	prevlevel--;
+	if (prevlevel == 0) { prevlevel = max_order; }
+    }
+
+    // Inform active communication partners of position changes
+    if (!((prevloc.loc.x == nowloc.loc.x) && (prevloc.loc.y == nowloc.loc.y))) {
+	/*
+	  ! NOT SAFE ! Do not maniplulate members of tmp.
+	  Needs fixing...
+	*/
+	connectionentry* tmp = liveconns->getAll();
+
+	while (tmp != NULL) {
+
+	    struct nodelocation* qryTarget = (nodelocation*)loccache->search(tmp->dst);
+	    if (!qryTarget) { qryTarget = (nodelocation*)loctable->search(tmp->dst); }
+	    if (!qryTarget) { 
+		printf("Warning: Live Connection does not know partner info ! No notification will be sent !\n");
+	    } else {
+
+		// Generate Notification
+		Packet *p = newNotify(qryTarget);
+		
+		//parent->recv(p,(Handler *)0);
+		
+		// Send Updates jittered, to avoid collisions
+		//  and solve bootstrapping issue
+		double delay = Random::uniform(GLS_NOTIFY_JITTER);
+		Scheduler::instance().schedule(parent,p,delay);
+		
+		p = NULL;
+	    }
+	    tmp = tmp->next;
+	}
+    }
+
+    // Memorize nowloc as prevloc
+    prevloc = nowloc;
+}
+
+void GridLocService::nackedUpdate(updcacheentry* e) {
+
+    // Don't exceed maximum retry count
+    e->cnt++;
+    if (e->cnt >= GLS_MAX_UPDATE_RETRIES) { return; }
+
+    // An Update we sent did not reach a target, thus
+    //  we send it again, hoping that connectivity
+    //  has improved.    
+
+    upd_reason = "NACK";
+
+    struct nodelocation dst;
+    dst.loc = getGridPos(e->sqr.grid,e->sqr.order);
+    dst.sqr.grid = e->sqr.grid;
+    dst.sqr.order = e->sqr.order;
+
+    // Generate Update
+    Packet *p = newUpdate(&dst);
+
+    // Keep Info about this Update
+    unsigned int key = key(e->sqr.grid,e->sqr.order);
+    double findelay = // Scales a little with order and number
+	(double)((e->sqr.order) << (e->cnt)) + 
+	Random::uniform(GLS_UPD_JITTER); 
+    updcache->add(key,findelay,(void*)e);
+
+    // Send Updates jittered, to avoid collisions
+    //  and solve bootstrapping issue
+    double delay = (e->sqr.order+1) * Random::uniform(GLS_UPD_JITTER);
+    Scheduler::instance().schedule(parent,p,delay);
+}
+
+/*************************/
+/* GLS Support Functions */
+/*************************/
+
+//! Returns the closest known next hop or NULL (Wrapper Function)
+nodelocation* GridLocService::findClosest(void* cache, nodelocation loc_, nodelocation* dst_) {
+
+    unsigned int size;
+    CHCEntry** table = ((LSLocationCache*)cache)->getTable(&size);
+
+    nodelocation* closest = NULL;
+    nsaddr_t closestId = parent->addr();
+  
+    // Walk through Table
+    for (unsigned int i=0; i<size; i++) {
+        if (table[i] != NULL) {
+	    CHCEntry* tmp = table[i];
+	    while (tmp != NULL) {
+		nodelocation* tmpinfo = (nodelocation*)tmp->info;
+		if (closer(tmpinfo->id,closestId,loc_.id)) { 
+		    if (dst_ != NULL) {
+			// Closest must be in the same grid as the dst
+			if (inSameGrid(*dst_,*tmpinfo)) { closest = tmpinfo; closestId = tmpinfo->id; }
+		    }else{
+			closest = tmpinfo; closestId = tmpinfo->id; 
+		    }
+		}
+		tmp = tmp->next;
+	    } 
+	}
+    }
+
+    // Check if no closer target could be found
+    if (closest == NULL) { return NULL; }
+
+    return closest;
+}
+
+//! Return reference Position for a (grid,order)-pair
+struct position GridLocService::getGridPos(struct square sqr) {
+    return getGridPos(sqr.grid, sqr.order);
+}
+
+struct position GridLocService::getGridPos(int grid, int order) {
+
+  struct position gridpos;
+    gridpos.z = 0;
+
+    // Get upper left grid no.
+    grid = grid & (0xffffffff << shiftVal(order));
+
+    // Get row & column of grid
+    int tmp = grid;
+    unsigned int row = 0;
+    unsigned int col = 0;
+    for (int i=0; i<16; i++) {
+	row = row << 1; 
+	col = col << 1;
+	if (tmp & 0x40000000) { row++; }
+	if (tmp & 0x80000000) { col++; }
+	tmp = tmp << 2;
+    } 
+
+    // Calculate upper left corner
+    gridpos.x = (GLS_SMALLEST_GRID * (col));
+    gridpos.y = (GLS_SMALLEST_GRID * (row));
+    // Correct for center
+    if (order == 0) {
+	gridpos.x += GLS_SMALLEST_GRID * 0.5;
+	gridpos.y += GLS_SMALLEST_GRID * 0.5;
+    }else{
+	gridpos.x += GLS_SMALLEST_GRID * (1 << (order-1));
+	gridpos.y += GLS_SMALLEST_GRID * (1 << (order-1));
+    }
+
+    return gridpos;
+}
+
+//! Check if two nodes are in the same grid of a specified order
+bool GridLocService::inSameGrid(struct nodelocation src, struct nodelocation dst, int order /* = -1 */)
+{
+    if (order == -1) {
+	// Choose biggest order of SRC & DST
+	if (src.sqr.order > dst.sqr.order) { order = src.sqr.order; }
+	else { order = dst.sqr.order; }
+    }
+
+    unsigned int mask = 0xffffffff; // valid for 32-bit arch.
+    mask = mask << shiftVal(order);
+
+    return ( ((src.sqr.grid & mask) == (dst.sqr.grid & mask)) ? true:false);
+}
+
+//! Check if him is closer to dst than me
+bool GridLocService::closer(nsaddr_t me, nsaddr_t him, nsaddr_t dst) {
+  // adapted from HGPS code
+    int my_dist = me - dst;
+    int his_dist = him - dst;
+
+    if (me == him) return false;
+
+    if (my_dist == 0) return true;
+    if (his_dist == 0) return false;
+
+    if (((my_dist > 0) && (his_dist<0)) ||
+	((my_dist < 0) && (his_dist<0) && (my_dist < his_dist)) ||
+	((my_dist > 0) && (his_dist>0) && (my_dist < his_dist))) {
+	return true;
+    }else{
+	return false;
+    }
+}
+
+//! Return the grid the caller is in */
+struct square GridLocService::getGrid() {
+
+    // Check own position
+    double x,y,z;
+    mn_->getLoc(&x, &y, &z);
+
+    return getGrid(x,y);
+}
+
+//! Return the grid coresponding to x/y */
+struct square GridLocService::getGrid(double x, double y) {
+
+    // adapted from HGPS code
+    double len_x, len_y;
+    int grid_num = 0;
+    struct square loc;
+
+    // assume minx = miny = 0. otherwise, use x - minx in place of x similar for y
+    len_x = len_y = max_len;
+     
+    while ((len_x > GLS_SMALLEST_GRID)|| (len_y > GLS_SMALLEST_GRID)) {
+	if (x < len_x/2) {
+	    if (y < len_y/2) { grid_num = grid_num * 4 + 0; }
+	    else { y -= len_y/2; grid_num = grid_num * 4 + 1; }
+	}else{
+	    x -= len_x/2;
+	    if (y<len_y/2) { grid_num = grid_num * 4 + 2; }
+	    else{ y -= len_y/2; grid_num = grid_num * 4 + 3; }
+	}
+	len_x = len_x/2;
+	len_y = len_y/2;
+    }
+    
+    loc.grid = grid_num;
+    loc.order = 0; // smallest order
+    
+    return loc;
+}
+
+struct nodelocation GridLocService::getNodeInfo() {
+    struct nodelocation loc;
+    loc.id = parent->addr();
+    loc.ts = Scheduler::instance().clock();
+    mn_->getLoc(&loc.loc.x, &loc.loc.y, &loc.loc.z);
+    loc.sqr = getGrid();
+    return loc;
+}
+
+/********/
+/* Size */
+/********/
+
+int GridLocService::hdr_size(Packet* p) {
+
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Defining Base Field Types in Bytes
+    const unsigned int id         = 4;
+    const unsigned int locCoord   = 3;
+    const unsigned int timeStamp  = 2;
+    const unsigned int TTL        = 1;
+    const unsigned int grid       = 2;
+    const unsigned int order      = 1;
+    const unsigned int square     = grid + order;
+    const unsigned int position   = locCoord + locCoord;
+
+    // All LS based routing agents must be listed here - mk
+    if (cmnh->ptype() == PT_GPSR) { return 0; } // GPSR Packet
+
+    if (cmnh->ptype() == PT_LOCS) { // LOCS Packet
+	switch (locsh->type_) {
+	    case LOCS_UPDATE:
+		return (2*id + 2*position + 2*timeStamp + square + timeStamp + TTL);
+	    case LOCS_REQUEST: 
+		return (2*id + 2*position + 2*timeStamp + id + TTL);
+	    case LOCS_REPLY:
+		return (2*id + 2*position + 2*timeStamp + TTL);  
+	    case LOCS_UPDATE_ACK:
+		return (2*id + 2*position + 2*timeStamp + order + TTL);  
+	    default:
+		printf("Invalid LOCS Packet wants to know it's size !\n");
+		abort();
+	}	
+    }
+
+    // Data Packet
+    return (2*id + 2*position);
+}
+
+/********************/
+/* Connection Cache */
+/********************/
+
+ConnectionCache::ConnectionCache(LocationService* parent, const double expire) {
+    this->parent = parent;
+    if (expire < 0.0) { this->expire = 0.0; }
+    else { this->expire = expire; }
+
+    first = last = NULL;
+}
+
+ConnectionCache::~ConnectionCache() {
+
+    connectionentry* tmp;
+    while (last != NULL) {
+	tmp = last->prev;
+	delete last;
+	last = tmp;
+    }
+    first = last;
+}
+
+connectionentry* ConnectionCache::remove(connectionentry* victim) {
+
+    assert(victim != NULL);
+    connectionentry* tmp = victim->next;
+
+    // Correct successor
+    if (victim->next != NULL) { victim->next->prev = victim->prev; }
+    // Correct predecessor
+    if (victim->prev != NULL) { victim->prev->next = victim->next; }
+    // Correct first and last
+    if (first == victim) { first = victim->next; }
+    if (last == victim) { last = victim->prev; }
+    
+    delete victim;
+    return tmp;
+}
+
+void ConnectionCache::cleanUp() {
+
+    if (expire == 0.0) { return; }
+
+    connectionentry* tmp = first;
+    double now = Scheduler::instance().clock();
+
+    while (tmp != NULL) {
+	if ((now - tmp->ts) > expire) {
+	    tmp = remove(tmp);
+	}else{
+	    tmp = tmp->next;
+	}
+    }
+}
+
+void ConnectionCache::add(const unsigned int dst) {
+    
+    cleanUp();
+
+    connectionentry* tmp = first;
+
+    // Walk the list and try to find an existing entry
+    while (tmp != NULL) {
+	if (tmp->dst == (nsaddr_t)dst) {
+	    // Update
+	    tmp->ts = Scheduler::instance().clock();
+	    return;
+	}else{
+	    tmp = tmp->next;
+	}
+    }
+
+    // No entry could be found, so we append a new one to the end of the chain
+    tmp = new connectionentry();
+    tmp->dst = (nsaddr_t)dst;
+    tmp->ts = Scheduler::instance().clock();
+    tmp->next = NULL;
+    tmp->prev = last;
+    if (last != NULL) { last->next = tmp; }
+    last = tmp;
+
+    if (first == NULL) { first = tmp; }
+}
+
+void ConnectionCache::printTable() {
+    
+    connectionentry* tmp = first;
+    printf("%d has LiveConns:", parent->addr());
+    while (tmp != NULL) {
+	printf("(%d,%.4f) ",tmp->dst,tmp->ts);
+	tmp = tmp->next;
+    }
+    printf("\n");
+}
+
+
+#endif // _GridLocService_cc
+
+
+
+
diff -u -r --new-file ./locservices/gridlocservice.h ../../ns-2.33-hls_working/ns-2.33/locservices/gridlocservice.h
--- ./locservices/gridlocservice.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/gridlocservice.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,209 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _GridLocService_h
+#define _GridLocService_h
+
+#include "hdr_locs.h"
+#include "locservice.h"
+#include "ls_queued_timer.h"
+#include <timer-handler.h>
+
+#define GLS_SMALLEST_GRID      250
+#define GLS_TTL                64
+#define GLS_LOCCACHE_TIMEOUT   20    /* Compromise to accomodate for HGPS 30.0 + 10.2 sec timeouts */
+#define GLS_LOCCACHE_SIZE      97
+#define GLS_LOCTABLE_SIZE      97
+#define GLS_REQTABLE_SIZE      199
+#define GLS_LIVECONN_TIMEOUT   20    /* Connections are considered alive for 20 secs */
+#define GLS_UPDATE_DISTANCE    250 //100   /* Traveldistance before Update gets necessary */
+#define GLS_UPDATE_INTERVAL    2.0   /* Check every x secs if Updates are needed */
+#define GLS_UPD_JITTER         0.015 /* 0-15 ms Delay per order */
+#define GLS_MAX_UPDATE_RETRIES 4     /* Don't try more than 4 times to place an update in a square */
+#define GLS_NOTIFY_JITTER      0.015 /* 0-15 ms Delay for one LocNotification */
+#define GLS_HEAP_SIZE          32    /* Initial Heap Size for Timers */
+#define GLS_REQUEST_TIMEOUT    1.5   /* Send a new Request every 1.5 secs */
+#define GLS_REQUEST_MAX_PERIOD 10    /* Max interval between requests (adapted to HGPS) */
+#define GLS_MAX_REQUESTS       6     /* Send max. 3 Requests on our own (without renewal by SendBuffer) */
+
+#define GLS_IMMEDIATE_NOTIFICATION true
+
+// Mix x & y into one unique key 
+// (unique for a reasonable number of values, i.e 0.5*2^sizeof(int))
+#define key(x,y)  (((x)<<16)+(y))
+
+//#define ALLOW_ACKED_UPDATES
+
+// Debugging Level 
+//  0 - no debug
+//  1 - basic
+//  2 - extended
+//  3 - full
+#define GLS_DEBUG 2
+
+/*************************/
+/* GRID Location Service */
+/*************************/
+
+class GridLocService : public LocationService {
+
+ public:
+    GridLocService(class Agent *p);
+    ~GridLocService();
+    void recv(Packet* &p);
+    bool poslookup(Packet *p);
+    void evaluatePacket(const Packet *p);
+    void callback(Packet* &p);
+    int hdr_size(Packet* p);
+    void init();
+
+ protected:
+    void updateLocServers();
+    void unansweredRequest(nsaddr_t id);
+    void nackedUpdate(updcacheentry* sqr);
+
+ private:
+    int max_order;
+    double max_len;
+
+    // Update Cycle Support
+    struct nodelocation prevloc;
+    double predto;
+    unsigned int prevlevel;
+
+    // Update Trace Support
+    const char* upd_reason; 
+
+    class LSLocationCache *loccache;
+    class LSLocationCache *loctable;
+    class LSRequestCache *reqtable;
+    friend class LSLocationCache;
+
+    class UpdateTimer *updtimer;
+    class ConnectionCache *liveconns;
+    class GLSRequestScheduler *reqtimer;
+    class GLSUpdateScheduler *updcache;
+
+    friend class UpdateTimer;
+    friend class GLSRequestScheduler;
+    friend class GLSUpdateScheduler;
+
+    Packet* newRequest(nsaddr_t dst_);
+    Packet* newReply(Packet* req, struct nodelocation* infosrc);
+    Packet* newUpdate(struct nodelocation* dst_);
+    Packet* newUpdAck(Packet* upd, struct nodelocation* infosrc);
+    Packet* newNotify(struct nodelocation* dst_);
+   
+    void recvRequest(Packet* &p);
+    void recvReply(Packet* &p);
+    void recvNotify(Packet* &p);
+    void recvUpdate(Packet* &p);
+    void recvUpdAck(Packet* &p);
+    void sendRequest(Packet* &p, bool fresh = false);
+    void evaluateLocation(Packet *p);
+    void piggybackLocation(Packet *p);
+    void updateLocation(Packet *p);
+    bool forwardUpdate(Packet* &p);
+    void updatePosition(struct nodelocation &entry, struct hdr_ip* iph=NULL);
+
+    // GLS Functions
+    nodelocation* findClosest(void* cache, nodelocation loc_, nodelocation* dst_ = NULL);
+    bool closer(nsaddr_t me, nsaddr_t him, nsaddr_t dst);
+    bool inSameGrid(struct nodelocation src, struct nodelocation dst, int order = -1); 
+    struct nodelocation getNodeInfo();
+    void sendUpdates(unsigned int order);
+    struct square getGrid();
+    struct square getGrid(double x, double y);
+    struct position getGridPos(int grid, int order);
+    struct position getGridPos(struct square sqr);
+    unsigned int shiftVal(unsigned int order) {
+	if (order == 0) { return 0; }
+	else { return (unsigned int)(1<<order); }
+    }
+    
+};
+
+/******************/
+/* Helper Classes */
+/******************/
+
+class GLSUpdateScheduler : public QueuedTimer {
+    
+ public:
+    GLSUpdateScheduler(class GridLocService *ls, int size)
+	: QueuedTimer(size) 
+	{ ls_ = ls; }
+    void handle();
+    void deleteInfo(void* info);
+
+ private:
+    GridLocService* ls_; 
+    
+};
+
+class GLSRequestScheduler : public QueuedTimer {
+    
+ public:
+    GLSRequestScheduler(class GridLocService *ls, int size)
+	: QueuedTimer(size) 
+	{ ls_ = ls; }
+    void handle();
+    
+ private:
+    GridLocService* ls_; 
+    
+};
+
+class UpdateTimer : public TimerHandler {
+ public:
+    UpdateTimer(GridLocService *ls) : TimerHandler()
+	{ ls_ = ls; };
+    void expire(Event *e) {
+	// Call LS Routine
+	ls_->updateLocServers();
+	
+	// Reschedule
+	resched(GLS_UPDATE_INTERVAL);
+    };
+ protected:
+    GridLocService *ls_;
+};
+
+class ConnectionCache {
+    
+ public:
+    ConnectionCache(class LocationService* parent, const double expire = 0.0);
+    ~ConnectionCache();
+
+    void add(const unsigned int dst);
+    connectionentry* getAll() { return first; }
+    void printTable();
+
+ private:
+    connectionentry* first;
+    connectionentry* last;
+    double expire;
+    class LocationService* parent;
+    connectionentry* remove(connectionentry* victim);
+    void cleanUp();
+};
+
+#endif // _GridLocService_h
+
+
+
+
diff -u -r --new-file ./locservices/.#gridlocservice.h.1.4 ../../ns-2.33-hls_working/ns-2.33/locservices/.#gridlocservice.h.1.4
--- ./locservices/.#gridlocservice.h.1.4	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/.#gridlocservice.h.1.4	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,192 @@
+#ifndef _GridLocService_h
+#define _GridLocService_h
+
+#include "hdr_locs.h"
+#include "locservice.h"
+#include "ls_queued_timer.h"
+#include <timer-handler.h>
+
+#define GLS_SMALLEST_GRID      250
+#define GLS_TTL                64
+#define GLS_LOCCACHE_TIMEOUT   20    /* Compromise to accomodate for HGPS 30.0 + 10.2 sec timeouts */
+#define GLS_LOCCACHE_SIZE      97
+#define GLS_LOCTABLE_SIZE      97
+#define GLS_REQTABLE_SIZE      199
+#define GLS_LIVECONN_TIMEOUT   20    /* Connections are considered alive for 20 secs */
+#define GLS_UPDATE_DISTANCE    250 //100   /* Traveldistance before Update gets necessary */
+#define GLS_UPDATE_INTERVAL    2.0   /* Check every x secs if Updates are needed */
+#define GLS_UPD_JITTER         0.015 /* 0-15 ms Delay per order */
+#define GLS_MAX_UPDATE_RETRIES 4     /* Don't try more than 4 times to place an update in a square */
+#define GLS_NOTIFY_JITTER      0.015 /* 0-15 ms Delay for one LocNotification */
+#define GLS_HEAP_SIZE          32    /* Initial Heap Size for Timers */
+#define GLS_REQUEST_TIMEOUT    1.5   /* Send a new Request every 1.5 secs */
+#define GLS_REQUEST_MAX_PERIOD 10    /* Max interval between requests (adapted to HGPS) */
+#define GLS_MAX_REQUESTS       6     /* Send max. 3 Requests on our own (without renewal by SendBuffer) */
+
+#define GLS_IMMEDIATE_NOTIFICATION true
+
+// Mix x & y into one unique key 
+// (unique for a reasonable number of values, i.e 0.5*2^sizeof(int))
+#define key(x,y)  (((x)<<16)+(y))
+
+//#define ALLOW_ACKED_UPDATES
+
+// Debugging Level 
+//  0 - no debug
+//  1 - basic
+//  2 - extended
+//  3 - full
+#define GLS_DEBUG 3
+
+/*************************/
+/* GRID Location Service */
+/*************************/
+
+class GridLocService : public LocationService {
+
+ public:
+    GridLocService(class Agent *p);
+    ~GridLocService();
+    void recv(Packet* &p);
+    bool poslookup(Packet *p);
+    void evaluatePacket(const Packet *p);
+    void callback(Packet* &p);
+    int hdr_size(Packet* p);
+    void init();
+
+ protected:
+    void updateLocServers();
+    void unansweredRequest(nsaddr_t id);
+    void nackedUpdate(updcacheentry* sqr);
+
+ private:
+    int max_order;
+    double max_len;
+
+    // Update Cycle Support
+    struct nodelocation prevloc;
+    double predto;
+    unsigned int prevlevel;
+
+    // Update Trace Support
+    const char* upd_reason; 
+
+    class LSLocationCache *loccache;
+    class LSLocationCache *loctable;
+    class LSRequestCache *reqtable;
+    friend class LSLocationCache;
+
+    class UpdateTimer *updtimer;
+    class ConnectionCache *liveconns;
+    class GLSRequestScheduler *reqtimer;
+    class GLSUpdateScheduler *updcache;
+
+    friend class UpdateTimer;
+    friend class GLSRequestScheduler;
+    friend class GLSUpdateScheduler;
+
+    Packet* newRequest(nsaddr_t dst_);
+    Packet* newReply(Packet* req, struct nodelocation* infosrc);
+    Packet* newUpdate(struct nodelocation* dst_);
+    Packet* newUpdAck(Packet* upd, struct nodelocation* infosrc);
+    Packet* newNotify(struct nodelocation* dst_);
+   
+    void recvRequest(Packet* &p);
+    void recvReply(Packet* &p);
+    void recvNotify(Packet* &p);
+    void recvUpdate(Packet* &p);
+    void recvUpdAck(Packet* &p);
+    void sendRequest(Packet* &p, bool fresh = false);
+    void evaluateLocation(Packet *p);
+    void piggybackLocation(Packet *p);
+    void updateLocation(Packet *p);
+    bool forwardUpdate(Packet* &p);
+    void updatePosition(struct nodelocation &entry, struct hdr_ip* iph=NULL);
+
+    // GLS Functions
+    nodelocation* findClosest(void* cache, nodelocation loc_, nodelocation* dst_ = NULL);
+    bool closer(nsaddr_t me, nsaddr_t him, nsaddr_t dst);
+    bool inSameGrid(struct nodelocation src, struct nodelocation dst, int order = -1); 
+    struct nodelocation getNodeInfo();
+    void sendUpdates(unsigned int order);
+    struct square getGrid();
+    struct square getGrid(double x, double y);
+    struct position getGridPos(int grid, int order);
+    struct position getGridPos(struct square sqr);
+    unsigned int shiftVal(unsigned int order) {
+	if (order == 0) { return 0; }
+	else { return (unsigned int)(1<<order); }
+    }
+    
+};
+
+/******************/
+/* Helper Classes */
+/******************/
+
+class GLSUpdateScheduler : public QueuedTimer {
+    
+ public:
+    GLSUpdateScheduler(class GridLocService *ls, int size)
+	: QueuedTimer(size) 
+	{ ls_ = ls; }
+    void handle();
+    void deleteInfo(void* info);
+
+ private:
+    GridLocService* ls_; 
+    
+};
+
+class GLSRequestScheduler : public QueuedTimer {
+    
+ public:
+    GLSRequestScheduler(class GridLocService *ls, int size)
+	: QueuedTimer(size) 
+	{ ls_ = ls; }
+    void handle();
+    
+ private:
+    GridLocService* ls_; 
+    
+};
+
+class UpdateTimer : public TimerHandler {
+ public:
+    UpdateTimer(GridLocService *ls) : TimerHandler()
+	{ ls_ = ls; };
+    void expire(Event *e) {
+	// Call LS Routine
+	ls_->updateLocServers();
+	
+	// Reschedule
+	resched(GLS_UPDATE_INTERVAL);
+    };
+ protected:
+    GridLocService *ls_;
+};
+
+class ConnectionCache {
+    
+ public:
+    ConnectionCache(class LocationService* parent, const double expire = 0.0);
+    ~ConnectionCache();
+
+    void add(const unsigned int dst);
+    connectionentry* getAll() { return first; }
+    void printTable();
+
+ private:
+    connectionentry* first;
+    connectionentry* last;
+    double expire;
+    class LocationService* parent;
+    connectionentry* remove(connectionentry* victim);
+    void cleanUp();
+};
+
+#endif // _GridLocService_h
+
+
+
+
diff -u -r --new-file ./locservices/hdr_locs.cc ../../ns-2.33-hls_working/ns-2.33/locservices/hdr_locs.cc
--- ./locservices/hdr_locs.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/hdr_locs.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+//#include <stdio.h>
+#include "hdr_locs.h"
+
+int hdr_locs::offset_;
+
+class LOCSHeaderClass : public PacketHeaderClass {
+public:
+    LOCSHeaderClass() : PacketHeaderClass("PacketHeader/LOCS",sizeof(hdr_locs)) {
+	bind_offset(&hdr_locs::offset_);
+    }
+} class_locshdr;
diff -u -r --new-file ./locservices/hdr_locs.h ../../ns-2.33-hls_working/ns-2.33/locservices/hdr_locs.h
--- ./locservices/hdr_locs.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/hdr_locs.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,183 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _hdr_locs_h
+#define _hdr_locs_h
+
+#include <packet.h>
+
+#ifndef NO_NODE
+#define NO_NODE -2
+#endif
+
+// Simple Location Service
+#define LOCS_REQUEST    1
+#define LOCS_REPLY      2
+#define LOCS_DATA       3
+#define LOCS_UPDATE     4
+#define LOCS_UPDATE_ACK 5
+#define LOCS_NOTIFY     6
+
+// TimerHeap Element
+typedef struct TimerHeapEntry{
+    unsigned int key;
+    double ts;
+    void* info;
+};
+
+typedef struct position {
+    double x, y, z;
+};
+
+typedef struct square {
+    int grid;
+    unsigned int order;
+};
+
+typedef struct CHCEntry {
+    unsigned int key;
+    CHCEntry* next;
+    CHCEntry* prev;
+
+    // Payload
+    void* info;
+};
+
+typedef struct nodelocation {
+    nsaddr_t id;
+    double ts;
+    double timeout;
+    position loc;
+    square sqr;
+};
+
+typedef struct locrequest {
+    nsaddr_t dst;
+    double ts;
+    unsigned int maxhop;
+    unsigned int seqno;
+};
+
+typedef struct seqnoentry {
+    unsigned int key;
+    double ts;
+    unsigned int seqno;
+};
+
+typedef struct supinfo {
+    unsigned int key;
+    double ts;
+    unsigned int cnt;
+    double dmin;
+    bool blocked;
+};
+
+typedef struct updcacheentry {
+    unsigned int cnt;
+    square sqr;
+};
+
+typedef struct connectionentry {
+    nsaddr_t dst;
+    double ts;
+    connectionentry* next;
+    connectionentry* prev;
+};
+
+struct hdr_locs {
+
+    nodelocation src;
+    nodelocation dst;
+    nodelocation lasthop;
+    nodelocation next;
+
+    unsigned int valid_;
+    int type_;
+    unsigned int seqno_;
+    unsigned int maxhop_;
+    square upddst_;
+    bool in_correct_grid;
+    const char* updreason_;
+    int callback_;
+
+    inline void init() {	
+	src.id = NO_NODE;
+	src.ts = -1.0;
+	src.timeout = -1.0;
+	src.loc.x = -1.0;
+	src.loc.y = -1.0;
+	src.loc.z = -1.0;
+	src.sqr.grid = -1;
+	src.sqr.order = 0;
+
+	dst.id = NO_NODE;
+	dst.ts = -1.0;
+	dst.timeout = -1.0;
+	dst.loc.x = -1.0;
+	dst.loc.y = -1.0;
+	dst.loc.z = -1.0;
+	dst.sqr.grid = -1;
+	dst.sqr.order = 0;
+
+	next.id = NO_NODE;
+	next.ts = -1.0;
+	next.timeout = -1.0;
+	next.loc.x = -1.0;
+	next.loc.y = -1.0;
+	next.loc.z = -1.0;
+	next.sqr.grid = -1;
+	next.sqr.order = 0;
+
+	lasthop.id = NO_NODE;
+	lasthop.ts = -1.0;
+	lasthop.timeout = -1.0;
+	lasthop.loc.x = -1.0;
+	lasthop.loc.y = -1.0;
+	lasthop.loc.z = -1.0;
+	lasthop.sqr.grid = -1;
+	lasthop.sqr.order = 0;
+
+	upddst_.grid = -1;
+	upddst_.order = 0;
+
+	valid_ = 1;
+	type_ = 0;
+	maxhop_ = 0;
+	seqno_ = 0;
+	in_correct_grid = false;
+	updreason_ = "NRSN";
+	callback_ = 0;
+    } 
+
+    // NS Rudimentary
+    static int offset_;
+    inline static int& offset() { return offset_; } 
+    inline static hdr_locs* access(const Packet* p) {
+	return (hdr_locs*) p->access(offset_);
+    }
+    
+    int size(bool implicit_beacon = false) {
+	
+	return 0;
+    }
+};  
+
+#endif // _hdr_locs_h
+
+
+
+
diff -u -r --new-file ./locservices/locservice.h ../../ns-2.33-hls_working/ns-2.33/locservices/locservice.h
--- ./locservices/locservice.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/locservice.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,81 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _LocationService_h
+#define _LocationService_h
+
+#include <ip.h>
+#include <god.h>
+#include <trace.h>
+#include <mobilenode.h>
+#include <agent.h>
+
+class LocationService {
+
+ public:
+    LocationService(class Agent *p) {
+      parent = p;
+      active_ = true;
+      tracetarget_ = NULL;
+      mn_ = NULL;
+    }
+    virtual ~LocationService() {}
+    virtual void recv(Packet* &p) = 0;
+    virtual bool poslookup(Packet *p) = 0;
+    virtual void evaluatePacket(const Packet *p) { return; }
+    virtual void setTarget(NsObject *t) {
+      target_ = t;
+    }
+    virtual void init() { return; }
+    virtual void wake() { active_ = true; }
+    virtual void sleep() { active_ = false; }
+    virtual void callback(Packet* &p) { return; }
+    virtual void dropPacketCallback(Packet* &p) { return; }
+    virtual int hdr_size(Packet* p) { return(0); }
+    inline bool active() { return active_; }
+
+    inline void setTraceTarget(Trace* target) { tracetarget_ = target; }
+    inline void setMobileNode(MobileNode* mn) { mn_ = mn; }
+    inline nsaddr_t addr() { 
+	//if (parent == NULL) {abort();}
+	return parent->addr(); 
+    }
+
+    virtual void trace(char *fmt,...) {
+	va_list ap;
+	if (!tracetarget_)
+	    return;
+	va_start(ap, fmt);
+	vsprintf(tracetarget_->pt_->buffer(), fmt, ap);
+	tracetarget_->pt_->dump();
+	va_end(ap);
+    }
+    
+ protected:
+    class Agent *parent;
+    NsObject *target_;
+    Trace *tracetarget_;
+    MobileNode *mn_;
+    bool active_;
+
+    // All LS based routing agents must be listed here - mk
+    //friend class GPSR_Agent;
+    friend class PBRAgent;
+    friend class CBF_Agent;
+};
+#endif // _LocationService_h
+
diff -u -r --new-file ./locservices/.#locservice.h.1.4 ../../ns-2.33-hls_working/ns-2.33/locservices/.#locservice.h.1.4
--- ./locservices/.#locservice.h.1.4	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/.#locservice.h.1.4	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,64 @@
+#ifndef _LocationService_h
+#define _LocationService_h
+
+#include <ip.h>
+#include <god.h>
+#include <trace.h>
+#include <mobilenode.h>
+#include <agent.h>
+
+class LocationService {
+
+ public:
+    LocationService(class Agent *p) {
+      parent = p;
+      active_ = true;
+      tracetarget_ = NULL;
+      mn_ = NULL;
+    }
+    virtual ~LocationService() {}
+    virtual void recv(Packet* &p) = 0;
+    virtual bool poslookup(Packet *p) = 0;
+    bool gsr_routing;
+    virtual void evaluatePacket(const Packet *p) { return; }
+    virtual void setTarget(NsObject *t) {
+      target_ = t;
+    }
+    virtual void init() { return; }
+    virtual void wake() { active_ = true; }
+    virtual void sleep() { active_ = false; }
+    virtual void callback(Packet* &p) { return; }
+    virtual void dropPacketCallback(Packet* &p) { return; } // modif wk
+    virtual int hdr_size(Packet* p) { return(0); }
+    inline bool active() { return active_; }
+
+    inline void setTraceTarget(Trace* target) { tracetarget_ = target; }
+    inline void setMobileNode(MobileNode* mn) { mn_ = mn; }
+    inline nsaddr_t addr() { 
+	//if (parent == NULL) {abort();}
+	return parent->addr(); 
+    }
+
+    virtual void trace(char *fmt,...) {
+	va_list ap;
+	if (!tracetarget_)
+	    return;
+	va_start(ap, fmt);
+	vsprintf(tracetarget_->pt_->buffer(), fmt, ap);
+	tracetarget_->pt_->dump();
+	va_end(ap);
+    }
+    
+ protected:
+    class Agent *parent;
+    NsObject *target_;
+    Trace *tracetarget_;
+    MobileNode *mn_;
+    bool active_;
+
+    // All LS based routing agents must be listed here - mk
+    friend class GPSR_Agent;
+    friend class CBF_Agent;
+};
+#endif // _LocationService_h
+
diff -u -r --new-file ./locservices/ls_queued_timer.cc ../../ns-2.33-hls_working/ns-2.33/locservices/ls_queued_timer.cc
--- ./locservices/ls_queued_timer.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/ls_queued_timer.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,479 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _LS_Queued_Timer_cc
+#define _LS_Queued_Timer_cc
+
+#include "ls_queued_timer.h"
+#include "ls_timer_heap.h"
+#include "locservice.h"
+
+/*****************/
+/* Queued Timer */
+/*****************/
+
+QueuedTimer::QueuedTimer(int size)
+    : TimerHandler()
+{ 
+    in_progress = NULL; 
+    heap_ = new TimerHeap(size,this); 
+    parent = -2;
+    warn_multiple = true;
+}
+
+QueuedTimer::QueuedTimer(int size, bool mwarn)
+    : TimerHandler()
+{ 
+    in_progress = NULL; 
+    heap_ = new TimerHeap(size,this); 
+    parent = -2;
+    warn_multiple = mwarn;
+}
+
+QueuedTimer::~QueuedTimer() {
+    delete heap_;
+}
+
+void QueuedTimer::shutdown() {
+	
+    // Get rid of pending event
+    if (in_progress != NULL) {
+      if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+      delete in_progress;
+      in_progress = NULL;
+      cancel();
+    }
+    // Clean Heap
+    heap_->clean();
+    return; 
+}
+
+void QueuedTimer::add(int32_t key_, double delay_, void* info_ /* = NULL */) {
+
+    // Prune invalid KEYs
+    if (key_ < 0) { return; }
+    add((unsigned int)key_,delay_,info_);
+
+}
+
+void QueuedTimer::add(unsigned int key_, double delay_, void* info_ /* = NULL */) {
+
+    // Add new event to the Heap
+    struct TimerHeapEntry* reqevent = new TimerHeapEntry;
+    reqevent->key = key_;
+    // Heap is absolute time addressed
+    reqevent->ts = (Scheduler::instance().clock() + delay_);
+    reqevent->info = info_;
+    heap_->insert(reqevent);
+    notify();
+
+#ifndef NDEBUG
+
+    /* 
+       In Debugging Mode print a Warning if a key
+       is used multiple times - mk
+    */
+    unsigned int usage_;
+    if (warn_multiple && ((usage_ = countEntries(key_)) > 1)) {
+      printf("QueuedTimer Warning: Key %d used %d times !\n", key_, usage_);
+    }
+
+#endif
+}
+
+void QueuedTimer::expire(Event *e) {
+
+    // Keep Info about Event
+    local_key = in_progress->key;
+    local_info = in_progress->info;
+
+    // Kill timed out Event
+    delete in_progress;
+    in_progress = NULL;
+  
+    handle();
+
+    if (heap_->empty()) { return; }
+
+    // In case handle did not call add and thus no
+    //  in_progress event is scheduled, we should 
+    //  schedule the next event ourselves
+    if (in_progress == NULL) {
+	in_progress = heap_->extract_min();
+	double now = Scheduler::instance().clock();
+	// Make sure all expired timers are removed
+	while (in_progress->ts < now) { 
+	    printf("QueuedTimer Warning: Skipped Queued Timer !\n");
+	    if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+	    delete in_progress;
+	    in_progress = heap_->extract_min();
+	    if (in_progress == NULL) { return; }
+	}
+	resched(in_progress->ts - now);
+    }
+}
+
+bool QueuedTimer::remove(int32_t key_) {
+
+    // Prune invalid KEYs
+    if (key_ < 0) { return false; }
+    return remove((unsigned int)key_);
+
+}
+
+bool QueuedTimer::remove(unsigned int key_) {
+
+    // Remove element from queue
+    bool removed = heap_->remove(key_);
+
+    if (!in_progress) { return (removed); }
+
+    // Check if event to key_ is pending
+    if (in_progress->key == key_) {
+
+	removed = true;
+
+	// Event pending, kill it and schedule
+	//  next event if one exists
+	if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+	delete in_progress;
+	in_progress = NULL;
+	cancel();
+    
+	if (heap_->empty()) { return (removed); }
+
+	in_progress = heap_->extract_min();
+	double now = Scheduler::instance().clock();
+	// Make sure all expired timers are removed
+	while (in_progress->ts < now) { 
+	    printf("QueuedTimer Warning: Skipped Queued Timer !\n");
+	    if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+	    delete in_progress;
+	    in_progress = heap_->extract_min();
+	    if (in_progress == NULL) { return (removed); }
+	}
+	sched(in_progress->ts - now);
+    }
+
+    return (removed);
+}
+
+void* QueuedTimer::extract(unsigned int key_, double* ttime_ /*= NULL*/) {
+
+  // Init ttime_ to -1.0
+  if (ttime_ != NULL) { (*ttime_) = -1.0; }
+
+  // If no event is pending, no match can be found
+  if (!in_progress) { return NULL; }
+
+  void* tmp = NULL;
+  double tmptime = -1.0;
+
+  // Check if event to key_ is pending
+  if (in_progress->key == key_) {
+
+    // Event pending, kill it and schedule
+    //  next event if one exists
+    tmp = in_progress->info;
+    tmptime = in_progress->ts;
+    delete in_progress;
+    in_progress = NULL;
+    cancel();
+    
+    if (ttime_ != NULL) { (*ttime_) = tmptime; }
+
+    if (heap_->empty()) { return (tmp); }
+
+    in_progress = heap_->extract_min();
+    double now = Scheduler::instance().clock();
+    // Make sure all expired timers are removed
+    while (in_progress->ts < now) { 
+      printf("QueuedTimer Warning: Skipped Queued Timer !\n");
+      if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+      delete in_progress;
+      in_progress = heap_->extract_min();
+    }
+    sched(in_progress->ts - now);
+    return (tmp);
+  }
+
+  // Check queue for event to key_
+  tmp = heap_->extract(key_, &tmptime);
+  if (tmp == NULL) { return NULL; }
+  else { 
+    if (ttime_ != NULL) { (*ttime_) = tmptime; }
+    return (tmp); 
+  }
+}
+
+void* const QueuedTimer::peek(unsigned int key_) {
+
+  // If no event is pending, no match can be found
+  if (!in_progress) { return NULL; }
+
+  // Check if event to key_ is pending
+  if (in_progress->key == key_) { return in_progress->info; }
+
+  // Check queue for event to key_
+  return (heap_->peek(key_));
+}
+
+bool QueuedTimer::queued(unsigned int key_) {
+    
+    // Check if element is in queue
+    bool queued = heap_->find(key_);
+
+    if (!in_progress) { return (queued); }
+
+    // Check if event to key_ is pending
+    if (in_progress->key == key_) { queued = true; }
+    
+    return (queued);
+}
+
+void QueuedTimer::notify() {
+
+    // Check if we can schedule an event
+
+    if (!in_progress) { // No Timer pending
+
+	if (heap_->empty()) { return; }
+
+	in_progress = heap_->extract_min();
+	double now = Scheduler::instance().clock();
+	// Make sure all expired timers are removed
+	while (in_progress->ts < now) { 
+	    printf("QueuedTimer Warning: Skipped Queued Timer !\n");
+	    if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+	    delete in_progress;
+	    in_progress = heap_->extract_min();
+	    if (in_progress == NULL) { return; }
+	}
+	resched(in_progress->ts - now);
+	
+    }else{ // Timer pending
+
+	if (heap_->empty()) { return; }
+
+	if ((heap_->tell_min())->ts <= in_progress->ts) {
+
+	    // MinReq should be scheduled earlier, reorder
+	    heap_->insert(in_progress);
+	    in_progress = heap_->extract_min();
+	    double now = Scheduler::instance().clock();
+	    // Make sure all expired timers are removed
+	    while (in_progress->ts < now) { 
+		printf("QueuedTimer Warning: Skipped Queued Timer !\n");
+		if (in_progress->info != NULL) { deleteInfo(in_progress->info); }
+		delete in_progress;
+		in_progress = heap_->extract_min();
+		if (in_progress == NULL) { return; }
+	    }
+	    resched(in_progress->ts - now);
+	}
+    }
+}
+
+unsigned int QueuedTimer::countEntries(unsigned int key_) {
+    
+    // Count entries in queue
+    unsigned int counter = heap_->count(key_);
+
+    if (!in_progress) { return (counter); }
+
+    // Check if event to key_ is pending
+    if (in_progress->key == key_) { counter++; }
+    
+    return (counter);
+}
+
+void QueuedTimer::printQueue() {
+
+    if (in_progress != NULL) {
+	printf("InProgress (%d,%f,%d)\n",in_progress->key,in_progress->ts,(int)in_progress->info);
+    }else{
+	printf("InProgress (NT,NT,NT)\n");
+    }
+    heap_->printTable();
+}
+
+/******************/
+/* Heap Functions */
+/******************/
+
+void TimerHeap::insert(struct TimerHeapEntry* elem) {
+    unsigned int i, par;
+
+    if (heapsize == maxsize) { // Heap is full and needs to grow
+	maxsize *= 2;
+	struct TimerHeapEntry** tmp = new TimerHeapEntry*[maxsize];
+	bzero (tmp, maxsize*sizeof(TimerHeapEntry*));
+	bcopy (elems, tmp, heapsize*sizeof(TimerHeapEntry*));
+	delete [] elems;
+	elems = tmp;
+    }
+
+    i = heapsize++;
+    par = parent(i);
+    while ((i > 0) && (lessthan(elem,elems[par]))) { 
+	elems[i] = elems[par];
+	i = par;
+	par = parent(i);
+    }
+    elems[i] = elem;
+    return;
+};
+
+struct TimerHeapEntry* TimerHeap::extract_min() {
+    struct TimerHeapEntry* min;   
+
+    if (heapsize == 0)
+	return NULL;
+    min = elems[0];
+    elems[0] = elems[--heapsize];
+    elems[heapsize] = NULL;
+    heapify(0);
+
+    return min;
+}
+
+void TimerHeap::heapify(unsigned int i) {
+    unsigned int	l, r, x;
+
+    while (i < heapsize) {
+	l = left(i); r = right(i);
+	if (r < heapsize) {
+	    if (lessthan(elems[l],elems[r])) x = l;
+	    else                             x = r;
+	} else
+	    x = (l < heapsize ? l : i);
+	if ((x != i) && lessthan(elems[x], elems[i])) {
+	    swap(i, x); i = x;
+	} else {
+	    break;
+	}
+    }
+}
+
+void TimerHeap::removeElem(int elem) {
+  for (elem; elem; elem = parent(elem)) {
+    swap(elem, parent(elem));
+  }
+  struct TimerHeapEntry* tmpElem = extract_min();
+  delete tmpElem;
+}
+
+bool TimerHeap::remove(unsigned int key_) {
+
+    if (empty()) { return false; }
+
+    // Delete all events
+    // 07.03.02 [HMF] changed increment to decrement (didn't make sense to
+    // Martin and me)
+
+    bool found = false;
+
+    for (int i = maxsize-1; i >= 0; i--) {
+	if ((elems[i]!=NULL)&&(elems[i]->key == key_)) {
+	    if (elems[i]->info != NULL) { timer->deleteInfo(elems[i]->info); }
+	    removeElem(i);
+	    found = true;
+	}
+    }
+    return found;
+}
+
+unsigned int TimerHeap::count(unsigned int key_) {
+
+    if (empty()) { return 0; }
+
+    unsigned int counter = 0;
+
+    for (int i = maxsize-1; i>=0; i--) {
+      if ((elems[i]!=NULL)&&(elems[i]->key == key_)) {
+	counter++;
+      }
+    }
+    return counter;
+}
+
+void* TimerHeap::extract(unsigned int key_, double* ttime_) {
+
+    if (ttime_ != NULL) { (*ttime_) = -1.0; }
+
+    if (empty()) { return NULL; }
+
+    // Note: Should more than one entry fit the key
+    //       only the first found entry will be
+    //       returned; all others remain
+    void* tmp = NULL;
+    for (int i = maxsize-1; i>=0; i--) {
+	if ((elems[i]!=NULL)&&(elems[i]->key == key_)) {
+	  if (ttime_ != NULL) { (*ttime_) = elems[i]->ts; }
+	  if (elems[i]->info != NULL) { tmp = elems[i]->info; }
+	  else { tmp = NULL; }
+	  removeElem(i);
+	  return tmp;
+	}
+    }
+    
+    // No fitting entry
+    return NULL;
+}
+
+void* const TimerHeap::peek(unsigned int key_) {
+
+    if (empty()) { return NULL; }
+
+    // Note: Should more than one entry fit the key
+    //       only the first found entry will be
+    //       returned; all others remain
+    for (int i = maxsize-1; i>=0; i--) {
+	if ((elems[i]!=NULL)&&(elems[i]->key == key_)) {
+	  return elems[i]->info;
+	}
+    }
+    
+    // No fitting entry
+    return NULL;
+}
+
+bool TimerHeap::find(unsigned int key_) {
+
+    if (empty()) { return false; }
+
+    // Search all events
+    for (int i = maxsize-1; i>=0; i--) {
+	if ((elems[i]!=NULL)&&(elems[i]->key == key_)) {
+	    return true;
+	}
+    }
+    return false;
+}
+
+void TimerHeap::printTable() {
+    printf("HeapTable (%d/%d): ",heapsize,maxsize);
+    for (unsigned int i=0; i<maxsize; i++) {
+	if (elems[i] != NULL)
+	    printf(" (%d,%f,%d)",elems[i]->key,elems[i]->ts,(int)elems[i]->info);
+	else
+	    printf(" (NN,NT,NT)");
+    }
+    printf("\n");
+}
+
+#endif //_LS_Queued_Timer_cc
diff -u -r --new-file ./locservices/ls_queued_timer.h ../../ns-2.33-hls_working/ns-2.33/locservices/ls_queued_timer.h
--- ./locservices/ls_queued_timer.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/ls_queued_timer.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _LS_Queued_Timer_h
+#define _LS_Queued_Timer_h
+
+#include <timer-handler.h>
+#include <packet.h>
+
+/*****************/
+/* Queued Timer */
+/*****************/
+
+class QueuedTimer : public TimerHandler {
+
+ public:
+    QueuedTimer(int size);
+    QueuedTimer(int size, bool mwarn);
+    virtual ~QueuedTimer();
+    virtual void handle() = 0;
+    virtual void deleteInfo(void* info) {}
+    void notify();
+    bool remove(int32_t key_);
+    bool remove(unsigned int key_);
+    bool queued(unsigned int key_);
+    void* const peek(unsigned int key_);
+    void* extract(unsigned int key_, double* ttime_ = NULL);
+    void shutdown();
+    void add(int32_t key_, double delay_, void* info_ = NULL);
+    void add(unsigned int key_, double delay_, void* info_ = NULL);
+    void expire(Event *e);
+    unsigned int countEntries(unsigned int key_);
+    void printQueue();
+
+    void setParent(int id) { parent = id; }
+
+ protected:
+    class TimerHeap *heap_;
+    struct TimerHeapEntry *in_progress;
+    unsigned int local_key;
+    void* local_info;
+    int parent;
+    bool warn_multiple;
+};
+
+#endif //_LS_Queued_Timer_h
+
+
+
+
+
+
diff -u -r --new-file ./locservices/ls_timer_heap.h ../../ns-2.33-hls_working/ns-2.33/locservices/ls_timer_heap.h
--- ./locservices/ls_timer_heap.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/ls_timer_heap.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,137 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _LS_Request_Heap_h
+#define _LS_Timer_Heap_h
+
+#include "hdr_locs.h"
+
+/****************/
+/* Timer Heap */
+/****************/
+
+class TimerHeap {
+
+ public:
+    TimerHeap(int size, class QueuedTimer* timer_) {
+	elems = new TimerHeapEntry*[size];
+	bzero (elems, size*sizeof(TimerHeapEntry*));
+	maxsize = size;
+	heapsize = 0;
+	inverted = false;
+	timer = timer_;
+    }
+
+    ~TimerHeap() {
+	for (int i = maxsize-1; i>=0; i--) {
+	    if (elems[i]->info != NULL) { timer->deleteInfo(elems[i]->info); }
+	}
+   	delete [] elems;
+    }
+
+    void heapify(unsigned int i);
+    void insert(struct TimerHeapEntry* elem);
+    bool remove(unsigned int key_);
+    void* extract(unsigned int key_, double* ttime_ = NULL);
+    bool find(unsigned int key_);
+    void* const peek(unsigned int key_);
+    unsigned int count(unsigned int key_);
+    void printTable();
+    struct TimerHeapEntry* extract_min();
+    inline struct TimerHeapEntry* tell_min() {
+	return (heapsize > 0 ? elems[0] : NULL);
+    };
+
+    inline void invert() { if (heapsize==0) { inverted = !inverted; } }
+    inline unsigned int	parent(unsigned int i)	{ return ((i - 1) / 2); }
+    inline unsigned int	left(unsigned int i)	{ return ((i * 2) + 1); }
+    inline unsigned int	right(unsigned int i)	{ return ((i + 1) * 2); }
+
+    inline void clean() {
+	for (unsigned int i=0; i<maxsize; i++)
+	    elems[i] = NULL;
+	heapsize = 0;
+	inverted = false;
+    }
+    
+    inline struct TimerHeapEntry* get(int i) {
+	if (elems[i]==NULL)
+	    return NULL;
+	else
+	    return elems[i];
+    }
+
+    inline bool empty() {
+	if (heapsize==0) return true;
+	else return false;
+    }
+
+    inline void iter_init() {
+	heapiter = 0;
+    }
+
+    inline struct TimerHeapEntry* iter() {
+	if (heapiter >= heapsize) {
+	    heapiter = 0;
+	    return NULL;
+	} else {
+	    return elems[heapiter++];
+	}
+    }
+
+ private:
+    struct TimerHeapEntry** elems;
+    class QueuedTimer* timer;
+    bool inverted;
+    unsigned int maxsize;
+    unsigned int heapsize;
+    unsigned int heapiter;
+
+    void removeElem(int elem);
+  
+    inline void swap(unsigned int i, unsigned int j) {
+	TimerHeapEntry* helper = elems[i];
+	elems[i] = elems[j];
+	elems[j] = helper;
+	return;
+    };
+
+    inline bool equal(struct TimerHeapEntry* q1, struct TimerHeapEntry* q2) {
+	if ((q1->key == q2->key) &&
+	    (q1->ts == q2->ts))
+	    return true;
+	else
+	    return false;
+    }
+
+    inline bool lessthan(struct TimerHeapEntry* q1, struct TimerHeapEntry* q2) {
+	if (inverted) {
+	    if (q1->ts > q2->ts) { return true; }
+	    else { return false; }
+	}else{
+	    if (q1->ts < q2->ts) { return true; }
+	    else { return false; }
+	}
+    }
+};
+#endif //_LS_Timer_Heap_h
+
+
+
+
+
+
diff -u -r --new-file ./locservices/omnilocservice.cc ../../ns-2.33-hls_working/ns-2.33/locservices/omnilocservice.cc
--- ./locservices/omnilocservice.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/omnilocservice.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _OmniLocService_cc
+#define _OmniLocService_cc
+
+#include "omnilocservice.h"
+
+OmniLocService::OmniLocService(Agent* p)
+  : LocationService(p)
+{}
+
+void OmniLocService::recv(Packet* &p) {
+    return;
+}
+
+bool OmniLocService::poslookup(Packet *p) {
+    struct hdr_ip *iphdr = HDR_IP(p);
+    God::instance()->getPosition(iphdr->daddr(), &iphdr->dx_, &iphdr->dy_, &iphdr->dz_);
+    return true;
+}
+
+#endif // _OmniLocService_cc
+
+
diff -u -r --new-file ./locservices/omnilocservice.h ../../ns-2.33-hls_working/ns-2.33/locservices/omnilocservice.h
--- ./locservices/omnilocservice.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/omnilocservice.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _OmniLocService_h
+#define _OmniLocService_h
+
+#include "locservice.h"
+
+class OmniLocService : public LocationService {
+
+ public:
+    OmniLocService(Agent* p);
+
+    void recv(Packet* &p);
+    bool poslookup(Packet *p);
+    
+};
+
+#endif // _OmniLocService_h
+
+
diff -u -r --new-file ./locservices/realocservice.cc ../../ns-2.33-hls_working/ns-2.33/locservices/realocservice.cc
--- ./locservices/realocservice.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/realocservice.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,888 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _ReaLocService_cc
+#define _ReaLocService_cc
+
+
+#include "realocservice.h"
+#include "hdr_locs.h"
+
+#include "chc.h"
+
+/*
+  Notes:
+*/
+
+/**************************/
+/* Request Timer Children */
+/**************************/
+
+void RLSRequestScheduler::handle() {
+    ls_->nextRequestCycle(local_key);
+}
+
+void RLSRequestDelay::handle() {
+    ls_->forwardRequest((Packet*&)local_info);
+}
+
+void RLSRequestDelay::deleteInfo(void* info) {
+    Packet::free((Packet*)info);
+}
+
+/*******/
+/* RLS */
+/*******/
+
+ReaLocService::ReaLocService(Agent* p)
+  : LocationService(p)
+{
+    parent = p;
+
+    loccache = new LSLocationCache(this,RLS_LOCCACHE_SIZE,RLS_LOCCACHE_TIMEOUT);
+    forwcache = new LSSeqNoCache(this,RLS_FORWCACHE_SIZE,RLS_FORWCACHE_TIMEOUT);
+    seqnocache = new LSSeqNoCache(this,RLS_FORWCACHE_SIZE);
+    reqtable = new LSRequestCache(this,RLS_REQTABLE_SIZE,RLS_REQTABLE_TIMEOUT);
+
+#ifndef ALLOW_MAX_FLOOD
+    reqtimer = new RLSRequestScheduler(this,RLS_HEAP_SIZE);
+#endif
+
+#ifdef ALLOW_REQUEST_SUPPRESSION
+    reqdelay = new RLSRequestDelay(this,RLS_REQDELAY_SIZE);
+    supinfocache = new LSSupCache(this,RLS_SUPINFOCACHE_SIZE,RLS_SUPINFOCACHE_TIMEOUT);
+#endif
+}
+
+ReaLocService::~ReaLocService() {
+    delete loccache;
+    delete forwcache;
+    delete reqtable;
+    delete seqnocache;
+#ifndef ALLOW_MAX_FLOOD
+    delete reqtimer;
+#endif
+#ifdef ALLOW_REQUEST_SUPPRESSION
+    delete reqdelay;
+    delete supinfocache;
+#endif
+}
+
+void ReaLocService::recv(Packet* &p) {
+
+    if (!active()) { return; } 
+
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    if ((iph->saddr() == parent->addr()) && (cmnh->num_forwards() == 0)) {
+	// New Data Pakets need no evaluation , since they contain nothing
+        // They only need piggybacked src info
+        piggybackSourceLocation(p);
+    }else{
+	// We'll try to update info in traversing packets that have outdated info
+	updateLocation(p);
+	// Some of the traversing Packets have Location Information for us
+	evaluateLocation(p);
+    }
+
+    if (locsh->valid_) {
+      
+	// Location Service Packet that needs to be processed
+	switch (locsh->type_) {
+	    case LOCS_REQUEST: { 
+		if (--iph->ttl() == 0) {
+		    if (locs_verbose) {
+			trace("LSTTL: %.12f _%d_ %d (%d->%d) %d [%d]",
+				      Scheduler::instance().clock(),
+				      parent->addr(),
+				      cmnh->uid(),
+				      locsh->src.id,
+				      locsh->dst.id,
+				      locsh->seqno_,
+				      locsh->maxhop_);
+		    }
+		    Packet::free(p);
+		    p = NULL;
+		    return;
+		}
+		recvRequest(p); 
+		break; 
+	    }
+	    case LOCS_REPLY:  
+		recvReply(p);
+		break;
+	    case LOCS_DATA:
+		break;
+	}
+
+	// Propagate node location as lasthop information
+	//  if the packet has not been consumed
+	if (p != NULL) {
+	    piggybackLasthopLocation(p);
+	}
+    }
+}
+
+void ReaLocService::callback(Packet* &p) {
+
+    // Do we need to evaluate callbacks for 
+    // Cache consistency or forwarding ?
+
+    // For Tracing we mark the pkt as callback
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    if (locsh->valid_) { locsh->callback_ = 1; }
+    
+}
+
+void ReaLocService::sleep() { 
+    active_ = false;
+#ifndef ALLOW_MAX_FLOOD
+    reqtimer->shutdown(); 
+#endif
+}
+
+void ReaLocService::piggybackSourceLocation(Packet *p) {
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    
+    assert((HDR_IP(p)->saddr() == parent->addr()) && (HDR_CMN(p)->num_forwards() == 0));
+
+    if (locsh->valid_ == 0) {
+	locsh->init();
+	locsh->type_ = LOCS_DATA;
+    }
+
+    // Newly generated Data Pkts need piggybacked src info
+    locsh->src.id = parent->addr();
+    locsh->src.ts = Scheduler::instance().clock();
+    mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+    locsh->lasthop.id = parent->addr();
+}
+
+void ReaLocService::piggybackLasthopLocation(Packet *p) {
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    
+    locsh->lasthop.id = parent->addr();
+    locsh->lasthop.ts = Scheduler::instance().clock();
+    mn_->getLoc(&locsh->lasthop.loc.x, &locsh->lasthop.loc.y, &locsh->lasthop.loc.z);
+}
+
+void ReaLocService::updatePosition(struct nodelocation &entry, struct hdr_ip* iph /* = NULL */) {
+  struct nodelocation* tmp = NULL;
+
+  tmp = (nodelocation*)loccache->search(entry.id);
+  if ((tmp!=NULL) && (tmp->ts > entry.ts)) {
+    if (locs_verbose) {
+      trace("LSUPOS: %.12f _%d_ [%d %.4f %.2f %.2f] to [%d %.4f %.2f %.2f]",
+		    Scheduler::instance().clock(),
+		    parent->addr(),
+		    entry.id, entry.ts, entry.loc.x, entry.loc.y,
+		    tmp->id, tmp->ts, tmp->loc.x, tmp->loc.y);
+    }
+    // Update
+    entry.ts = tmp->ts;
+    entry.loc = tmp->loc;
+    entry.sqr = tmp->sqr;
+    if (iph != NULL) {
+      // Update Routing Info
+      iph->dx() = tmp->loc.x;
+      iph->dy() = tmp->loc.y;
+      iph->dz() = tmp->loc.z;
+    }
+  }
+}
+
+void ReaLocService::updateLocation(Packet *p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    // Check Location Info of LocService Packets
+    if (locsh->valid_) {
+      switch (locsh->type_) {
+	  case LOCS_DATA:
+	  case LOCS_REPLY:
+	    updatePosition(locsh->dst,iph);
+          case LOCS_REQUEST:
+	  default:
+	    updatePosition(locsh->src);
+      }
+    }
+}
+
+void ReaLocService::evaluatePacket(const Packet *p) {
+  evaluateLocation((Packet*)p);
+}
+
+void ReaLocService::evaluateLocation(Packet *p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_ip *iph = HDR_IP(p);
+
+    if (locsh->valid_) {
+
+        bool new_entry;
+	switch (locsh->type_) {
+	    case LOCS_REPLY:
+	        new_entry = loccache->add(&locsh->dst);
+		if ((RLS_IMMEDIATE_NOTIFICATION) && (new_entry))
+		  parent->notifyPos(locsh->dst.id); 
+	    case LOCS_REQUEST:
+	    default: 
+	        new_entry = loccache->add(&locsh->src);
+		if ((RLS_IMMEDIATE_NOTIFICATION) && (new_entry))
+		  parent->notifyPos(locsh->src.id); 
+	}
+    }
+
+}
+
+void ReaLocService::sendRequest(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+
+    // Define common fields
+    cmnh->direction() = hdr_cmn::DOWN;
+    cmnh->next_hop_ = MAC_BROADCAST;
+
+#ifdef ALLOW_DIRECTIONAL_FLOODING
+
+    double myx,myy,myz;
+    mn_->getLoc(&myx, &myy, &myz);
+    double dist = distance(locsh->lasthop.loc.x, locsh->lasthop.loc.y, myx, myy);
+    double maxdist = God::instance()->getRadioRange();
+    double delay = RLS_DF_MAX_DELAY * (1 - ((dist * dist) / (maxdist * maxdist)));
+
+    if ((delay == RLS_DF_MAX_DELAY)||(delay < 0)) {
+
+	// Originating Nodes need not wait the max.delay
+	//  since no one else is sending this pkt
+
+	// Nodes that receive the pkt even though they are 
+	//  beyond norm radio range may produce a negative
+	//  delay. This may not happen.
+	// NOTE: This might happen in a small percentage of
+	//       cases, where the phy has no "hardcoded" 
+	//       max.range
+
+	delay = 0;
+    }
+
+#else
+
+    double delay = bcastDelay();
+
+#endif
+    
+    // Requests need a manual update of the lasthop info
+    piggybackLasthopLocation(p);
+
+    // In an ideal case we could just hand the pkt over to the LL
+    //target_->recv(p,(Handler *)0);
+
+    Scheduler::instance().schedule(target_,p,delay);
+
+    p = NULL;
+}
+
+#ifdef ALLOW_REQUEST_SUPPRESSION
+bool ReaLocService::suppressedPkt(Packet* &p) {
+
+    /* 
+       Implements a combination of a distance-/counter-based 
+       suppression scheme for broadcasts.
+       Scheme can be replaced if needed.
+    */
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+    struct hdr_ip *iph = HDR_IP(p);
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+
+    // Check if an supinfocache entry exists
+    supinfo* pktinfo = (supinfo*)supinfocache->search(cmnh->uid());
+
+    if (pktinfo == NULL) {
+
+	// First time broadcast
+	double myx,myy,myz;
+	mn_->getLoc(&myx, &myy, &myz);
+	double dist = distance(locsh->lasthop.loc.x, locsh->lasthop.loc.y, myx, myy);
+	
+	bool tooClose = false;
+	if (dist < RLS_DIST_THRESHOLD) { tooClose = true; }
+	else                           { tooClose = false; }
+
+	struct supinfo tmpsi = { 
+	    cmnh->uid(), Scheduler::instance().clock(), 1, dist, tooClose
+	};
+	supinfocache->add(&tmpsi);
+	return tooClose;
+
+    }else{
+
+	// Possible rebroadcast (delayed, queued pkt exists)
+	if ((pktinfo->blocked) || (pktinfo->cnt >= RLS_CNT_THRESHOLD)) {
+
+	    // Node is not allowed to forward this pkt or
+	    // pkt has been received too often
+	    return true;
+
+	}else{
+
+	    // Lasthop distance evaluation shall decide whether to 
+	    // rebroadcast this pkt or not
+	    double myx,myy,myz;
+	    mn_->getLoc(&myx, &myy, &myz);
+	    double dist = distance(locsh->lasthop.loc.x, locsh->lasthop.loc.y, myx, myy);
+	    double dmin;
+	    if (dist < pktinfo->dmin) { dmin = dist; }
+	    else { dmin = pktinfo->dmin; }
+	    
+	    bool tooClose = false;
+	    if (dmin < RLS_DIST_THRESHOLD) { tooClose = true; }
+	    else                           { tooClose = false; }
+
+	    struct supinfo tmpsi = { 
+		cmnh->uid(), Scheduler::instance().clock(), 
+		pktinfo->cnt++, dmin, tooClose
+	    };
+	    supinfocache->add(&tmpsi);
+	    return tooClose;
+
+	}
+    }
+}
+#endif
+
+void ReaLocService::forwardRequest(Packet* &p) {
+
+    // Forward Packet
+    sendRequest(p); 
+}
+
+void ReaLocService::recvRequest(Packet* &p) {
+
+    struct hdr_locs *req_locsh = HDR_LOCS(p);
+    struct hdr_cmn *req_cmnh = HDR_CMN(p);
+
+    // Check if we had this Pkt before
+    unsigned int key_ = key(req_locsh->src.id,req_locsh->dst.id);
+
+    int seqno_;
+    seqno_ = forwcache->find(key_);
+
+#ifdef ALLOW_MULTIPLE_REPLIES
+    // If we're not the DST, check if we had this Pkt
+    if (!(req_locsh->dst.id == parent->addr()))
+#endif
+	// Prune Requests that have already been processed
+	if ((seqno_>=0)&&((unsigned int)seqno_>=req_locsh->seqno_)) {
+	    if (locs_show_processing)
+		trace("LSDAP: %.12f _%d_ %d (%d->%d) %d [%d]",
+			      Scheduler::instance().clock(),
+			      parent->addr(),
+			      req_cmnh->uid(),
+			      req_locsh->src.id,
+			      req_locsh->dst.id,
+			      req_locsh->seqno_,
+			      req_locsh->maxhop_);
+	    Packet::free(p);
+	    p = NULL;
+	    return;
+	}
+    
+    
+    // We never had this request (or not for a long time) -> Remember it
+    struct seqnoentry tmpsqn = { 
+	key_, Scheduler::instance().clock(), req_locsh->seqno_ 
+    };
+    forwcache->add(&tmpsqn);           
+
+    if (req_locsh->dst.id == parent->addr()) {
+
+	// Packet is for me and needs a reply 
+	struct nodelocation info;
+	info.id = parent->addr();
+	info.ts = Scheduler::instance().clock();
+	mn_->getLoc(&info.loc.x, &info.loc.y, &info.loc.z);
+
+	Packet *pkt = genReply(p,&info);
+	Packet::free(p);
+	p = pkt;
+
+	if (locs_verbose) {
+	    struct hdr_locs *locsh = HDR_LOCS(pkt);
+	    trace("LSSOR: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  locsh->src.id,
+			  locsh->dst.id);         
+	}
+	return;
+
+    }else{
+	
+      // Packet is not for me process it
+     
+      if (locs_show_processing){
+	  trace("LSPR: %.12f _%d_ %d (%d->%d) %d",
+			Scheduler::instance().clock(),
+			parent->addr(),
+			req_cmnh->uid(),
+			req_locsh->src.id,
+			req_locsh->dst.id,
+			req_locsh->seqno_);      
+      }         
+
+#ifdef ALLOW_CACHED_REPLY	
+
+	// Check if we can answer the Request from our cache
+	struct nodelocation* qryTarget = (nodelocation*)loccache->search(req_locsh->dst.id);
+
+	if (qryTarget) {
+
+	    Packet *pkt = genReply(p, qryTarget);
+	    Packet::free(p);
+	    p = pkt;
+
+	    if (locs_verbose) {
+		struct hdr_locs *locsh = HDR_LOCS(pkt);
+		trace("LSSCR: %.12f _%d_ (%d->%d)",
+		      Scheduler::instance().clock(),
+		      parent->addr(),
+		      locsh->dst.id,
+		      locsh->src.id);            
+	    }
+	    return;
+	}
+	
+#endif
+
+	// Check if we were the last node that should
+	//  recv this request
+	if (--req_locsh->maxhop_ == 0) {
+	  Packet::free(p);
+	  p = NULL;
+	  return;
+	}
+
+#ifdef ALLOW_REQUEST_SUPPRESSION
+
+	struct hdr_cmn *cmnh = HDR_CMN(p);
+	
+	if (!suppressedPkt(p)) {
+	    
+	    if (!reqdelay->queued(cmnh->uid())) {
+		
+		// Schedule pkt for rebroadcast after a RAD
+		reqdelay->add(cmnh->uid(), RLS_SUPRAD_TIME, (void*)p);
+		p = NULL;
+		return;
+		
+	    }else{
+		
+		// Pkt is already scheduled for rebroadcast
+		// discard this copy
+		Packet::free(p);
+		p = NULL;
+		return;
+		
+	    }
+	    
+	}else{
+	    
+	    // Rebroadcast is suppressed and all scheduled copies
+	    // will be cancelled
+	    reqdelay->remove(cmnh->uid());
+	    Packet::free(p);
+	    p = NULL;
+	    return;
+	    
+	}
+	
+#else
+	
+	// Forward Packet
+	sendRequest(p);
+	
+#endif
+	
+    }
+}
+
+void ReaLocService::recvReply(Packet* &p) {
+
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    if (locsh->dst.id == parent->addr()) {
+	// The original Request was mine, get rid of the reply 
+	if (locs_verbose)
+	  trace("LSRR: %.12f _%d_ (%d->%d)",
+			Scheduler::instance().clock(),
+			parent->addr(),
+			locsh->src.id,
+			locsh->dst.id);            
+
+#ifndef ALLOW_MAX_FLOOD
+	// Cancel all pending Requests
+	reqtimer->remove(locsh->src.id);
+#endif
+
+        // Delete Request Entry in ReqTable
+	reqtable->remove(locsh->src.id);
+
+	// Already notified parent in evaluation
+
+	Packet::free(p);
+	p = NULL;
+    }   
+}
+
+bool ReaLocService::poslookup(Packet *p) {
+    
+    if (!active()) { return false; }
+
+    struct hdr_ip *iphdr = HDR_IP(p);
+    struct hdr_locs *locshdr = HDR_LOCS(p);
+    
+    // Prune Location Service Packets
+    if ((locshdr->type_ == LOCS_REPLY) || (locshdr->type_ == LOCS_REQUEST))
+	return true;
+
+    // Check Location Cache for the Position of the DST
+    struct nodelocation* qryTarget = (nodelocation*)loccache->search(iphdr->daddr());
+
+    if (qryTarget) {
+      // found location in cache
+      if (locs_verbose)
+	trace("LSIIC: %.12f _%d_ [%d %.4f %.2f %.2f]",      
+		      Scheduler::instance().clock(),
+		      parent->addr(),
+		      iphdr->daddr(),
+		      qryTarget->ts,
+		      qryTarget->loc.x,
+		      qryTarget->loc.y);
+      // Mark DST for Agent
+      iphdr->dx() = qryTarget->loc.x;
+      iphdr->dy() = qryTarget->loc.y;
+      iphdr->dz() = qryTarget->loc.z;
+      
+      // Mark DST for LocService
+      locshdr->dst.id = qryTarget->id;
+      locshdr->dst.ts = qryTarget->ts;
+      locshdr->dst.loc.x = qryTarget->loc.x;
+      locshdr->dst.loc.y = qryTarget->loc.y;
+      locshdr->dst.loc.z = qryTarget->loc.z;
+      
+      // Update SRC Info
+      locshdr->type_ = LOCS_DATA;
+      locshdr->src.id = parent->addr();
+      locshdr->src.ts = Scheduler::instance().clock();
+      mn_->getLoc(&locshdr->src.loc.x, &locshdr->src.loc.y, &locshdr->src.loc.z);
+      
+      return true;
+    }
+
+    // No Location can be found in the Location Cache, so we'll
+    // check if the dst is already queried and if it is not, we'll
+    // send a Location Request Packet
+
+    // Check if DST has been queried
+
+    locrequest* request = (locrequest*)reqtable->search(iphdr->daddr());
+
+    if (!request) {
+	
+	// DST has not been queried in a long time (if ever)
+	//   -> start new cycle if requests can still be sent
+
+        // Inquire SeqNo from Cache in case we had requested
+        //  this target before
+	int seqno_ = seqnocache->find(iphdr->daddr());
+	if (seqno_ == -1) { seqno_ = 0; }
+
+	// Generate Request
+#ifdef ALLOW_MAX_FLOOD
+	Packet *pkt = genRequest(iphdr->daddr(), seqno_,RLS_REQ_MAXHOP);
+#else
+	Packet *pkt = genRequest(iphdr->daddr(), seqno_,RLS_REQ_INITHOP);
+#endif
+	struct hdr_locs *locsh = HDR_LOCS(pkt);
+	struct hdr_cmn *cmnh = HDR_CMN(pkt);
+
+	// Keep info about having sent this packet in caches
+	unsigned int key_ = key(locsh->src.id,locsh->dst.id);
+	double now = Scheduler::instance().clock();
+
+	struct seqnoentry tmpfrw = { 
+	    key_, now, locsh->seqno_ 
+	};
+	forwcache->add(&tmpfrw);    
+
+	struct locrequest tmpreq = { 
+	    iphdr->daddr(), now, locsh->maxhop_,locsh->seqno_ 
+	};
+	reqtable->add(&tmpreq);
+
+	struct seqnoentry tmpsqn = { 
+	    locsh->dst.id, now, locsh->seqno_ 
+	};
+	seqnocache->add(&tmpsqn);
+
+#ifndef ALLOW_MAX_FLOOD
+	// Schedule next Request Cycle
+	double findelay = (RLS_REQTABLE_HOP_TIMEOUT*locsh->maxhop_);
+	reqtimer->add(locsh->dst.id, findelay);
+#endif
+
+	if (locs_verbose)
+	    trace("LSSRC: %.12f _%d_ %d (%d->%d) %d",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  cmnh->uid(),
+			  locsh->src.id,
+			  locsh->dst.id,
+			  locsh->seqno_);     
+	
+	sendRequest(pkt);  
+	
+    }else{
+
+	// Request has been sent and is handled by timer or timeout
+	if (locs_verbose && locs_show_in_progress) {
+	    struct hdr_cmn *cmnhdr = HDR_CMN(p);
+	    trace("LSRCIP: %.12f _%d_ %d (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  cmnhdr->uid(),
+			  iphdr->saddr(),
+			  iphdr->daddr()); 
+	}
+    }
+    return false;
+}
+
+void ReaLocService::nextRequestCycle(nsaddr_t dst_) {
+    
+    locrequest* request = (locrequest*)reqtable->search(dst_);
+
+    if (!request) { // request expired; don't try any longer
+	return;
+    }
+
+    if (request->maxhop >= RLS_REQ_MAXHOP) {
+		
+	// Max Hop Distance exceeded; DST can not be reached
+	if (locs_verbose)
+	    trace("LSMHDE: %.12f _%d_ (%d->%d)",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  parent->addr(),
+			  dst_);         
+	request->dst = NO_NODE;
+	  
+    }else{
+
+	// Maybe DST is further away, increase radius
+#ifdef ALLOW_EXP_REQUEST
+	unsigned int this_maxhop = (request->maxhop << 1);
+	if (this_maxhop > RLS_REQ_MAXHOP)
+	    this_maxhop = RLS_REQ_MAXHOP;
+#else
+	unsigned int this_maxhop = (request->maxhop + RLS_REQ_LINSTEPHOP);
+#endif
+
+	// Inquire SeqNo from Cache
+	int seqno_ = seqnocache->find(dst_);
+	if (seqno_ == -1) { seqno_ = 0; }
+
+	// Generate Request
+	Packet *pkt = genRequest(dst_, (request->seqno + 1),this_maxhop);
+	struct hdr_locs *locsh = HDR_LOCS(pkt);
+	struct hdr_cmn *cmnh = HDR_CMN(pkt);
+  
+	// Keep info about having sent this packet in caches
+	unsigned int key_ = key(locsh->src.id,locsh->dst.id);
+	double now = Scheduler::instance().clock();
+
+	struct seqnoentry tmpfrw = { 
+	    key_, now, locsh->seqno_ 
+	};
+	forwcache->add(&tmpfrw);    
+
+	struct locrequest tmpreq = { 
+	    dst_, now, locsh->maxhop_,locsh->seqno_ 
+	};
+	reqtable->add(&tmpreq);
+
+	struct seqnoentry tmpsqn = { 
+	    locsh->dst.id, now, locsh->seqno_ 
+	};
+	seqnocache->add(&tmpsqn);
+
+	// Schedule next Request Cycle
+	double findelay = (RLS_REQTABLE_HOP_TIMEOUT*locsh->maxhop_);
+	reqtimer->add(locsh->dst.id, findelay);
+
+	if (locs_verbose)
+	    trace("LSNRC: %.12f _%d_ %d (%d->%d) %d [%d]",
+			  Scheduler::instance().clock(),
+			  parent->addr(),
+			  cmnh->uid(),
+			  locsh->src.id,
+			  locsh->dst.id,
+			  locsh->seqno_,
+			  this_maxhop);  
+
+	sendRequest(pkt);
+    }
+}
+
+Packet* ReaLocService::genReply(Packet* req, struct nodelocation* infosrc) {
+
+    Packet *pkt = parent->allocpkt();
+
+    struct hdr_ip *req_iph = HDR_IP(req);
+    struct hdr_locs *req_locsh = HDR_LOCS(req);
+
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+    
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    iph->daddr() = req_iph->saddr();
+    iph->ttl() = RLS_TTL;
+    
+    iph->dx_ = req_locsh->src.loc.x;
+    iph->dy_ = req_locsh->src.loc.y;
+    iph->dz_ = req_locsh->src.loc.z;
+    
+    locsh->init();
+    locsh->type_ = LOCS_REPLY;
+    locsh->src.id = infosrc->id;
+    locsh->src.ts = infosrc->ts;
+    locsh->src.loc.x = infosrc->loc.x;
+    locsh->src.loc.y = infosrc->loc.y;
+    locsh->src.loc.z = infosrc->loc.z;
+
+    locsh->seqno_ = 0;
+    locsh->maxhop_ = RLS_TTL+1;
+    
+    locsh->dst.id = req_locsh->src.id;
+    locsh->dst.ts = req_locsh->src.ts;
+    locsh->dst.loc.x = req_locsh->src.loc.x;
+    locsh->dst.loc.y = req_locsh->src.loc.y;
+    locsh->dst.loc.z = req_locsh->src.loc.z;
+    
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->next_hop_ = NO_NODE;
+    cmnh->xmit_failure_ = 0;
+    
+    cmnh->direction() = hdr_cmn::DOWN;
+    
+    return pkt;
+}
+
+Packet* ReaLocService::genRequest(nsaddr_t dst_, int seqno_, int maxhop_) {
+
+    Packet *pkt = parent->allocpkt();
+
+    struct hdr_locs *locsh = HDR_LOCS(pkt);
+    struct hdr_ip *iph = HDR_IP(pkt);
+    struct hdr_cmn *cmnh = HDR_CMN(pkt);
+
+
+    locsh->init();
+    locsh->type_ = LOCS_REQUEST;
+    locsh->src.id = parent->addr();
+    locsh->src.ts = Scheduler::instance().clock();
+    locsh->seqno_ = seqno_;
+    locsh->maxhop_ = maxhop_;
+    mn_->getLoc(&locsh->src.loc.x, &locsh->src.loc.y, &locsh->src.loc.z);
+    locsh->dst.id = dst_;
+
+    // Initilize LastHop Info for Directional Flooding 
+    locsh->lasthop.id = parent->addr();
+    locsh->lasthop.ts = Scheduler::instance().clock();
+    locsh->lasthop.loc.x = locsh->src.loc.x;
+    locsh->lasthop.loc.y = locsh->src.loc.y;
+    locsh->lasthop.loc.z = locsh->src.loc.z;
+
+    iph->sport() = RT_PORT;
+    iph->dport() = RT_PORT;
+    iph->saddr() = parent->addr();
+    //iph->daddr() = IP_BROADCAST;
+    iph->daddr() = dst_;
+    iph->ttl() = RLS_TTL;
+
+    cmnh->ptype() = PT_LOCS;
+    cmnh->addr_type_ = NS_AF_INET;
+    cmnh->num_forwards() = 0;
+    cmnh->xmit_failure_ = 0;
+    cmnh->size() = parent->hdr_size(pkt);
+
+    
+    return pkt;
+}
+
+/********/
+/* Size */
+/********/
+
+int ReaLocService::hdr_size(Packet* p) {
+
+    struct hdr_cmn *cmnh = HDR_CMN(p);
+    struct hdr_locs *locsh = HDR_LOCS(p);
+
+    // Defining Base Field Types in Bytes
+    const unsigned int id         = 4;
+    const unsigned int locCoord   = 3;
+    const unsigned int timeStamp  = 2;
+    const unsigned int TTL        = 1;
+    const unsigned int ReqSeqNo   = 1;
+    const unsigned int position   = locCoord + locCoord;
+
+    if (cmnh->ptype() == PT_LOCS) { // LOCS Packet
+
+	switch (locsh->type_) {
+	    case LOCS_REQUEST: 
+#ifdef ALLOW_DIRECTIONAL_FLOODING
+		// For suppression all pkts need lasthop info
+		return (2*id + 3*position + timeStamp + id + TTL + ReqSeqNo);
+#else
+		return (id + 2*position + timeStamp + id + TTL + ReqSeqNo);
+#endif
+	    case LOCS_REPLY:
+		return (2*id + 2*position + 2*timeStamp + TTL);  
+	    default:
+		printf("Invalid LOCS Packet wants to know it's size !\n");
+		abort();
+	}	
+    }
+    
+    // Data Packet
+    return (2*id + 2*position);
+}
+#endif // _ReaLocService_cc
diff -u -r --new-file ./locservices/realocservice.h ../../ns-2.33-hls_working/ns-2.33/locservices/realocservice.h
--- ./locservices/realocservice.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/locservices/realocservice.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,160 @@
+/*
+
+  Contacts: 
+  Michael Kaesemann (mikael@uni-mannheim.de)
+
+  Permission to use, copy, modify, and distribute this software and its
+  documentation in source and binary forms is hereby granted, provided 
+  that the above copyright notice appears in all copies and the author is 
+  acknowledged in all documentation pertaining to any such copy or
+  derivative work.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+  WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+
+#ifndef _ReaLocService_h
+#define _ReaLocService_h
+
+#include "locservice.h"
+#include "ls_queued_timer.h"
+#include <random.h>
+
+// NOTE: Sizes are prime numbers, because they are 
+//       implemented as Chained Hashes - mk
+#define RLS_TTL                   64
+#define RLS_LOCCACHE_TIMEOUT      5.0
+#define RLS_LOCCACHE_SIZE         97
+#define RLS_REQ_MAXHOP            32
+#define RLS_REQ_INITHOP           2
+#define RLS_REQ_LINSTEPHOP        2
+#define RLS_REQTABLE_HOP_TIMEOUT  0.030
+#define RLS_REQTABLE_TIMEOUT      (RLS_REQ_MAXHOP * RLS_REQTABLE_HOP_TIMEOUT)
+#define RLS_REQTABLE_SIZE         199
+#define RLS_FORWCACHE_TIMEOUT     10.0
+#define RLS_FORWCACHE_SIZE        97
+
+// This one is not a Hash, so no prime number is needed
+#define RLS_HEAP_SIZE             32
+
+#define RLS_IMMEDIATE_NOTIFICATION true
+
+// Mix x & y into one unique key (at least for a reasonable number of nodes, i.e 0.5*2^sizeof(int))
+#define key(x,y)  (((x)<<16)+(y)) 
+
+// Max Request Broadcast Delay
+#define RLS_MAX_BCAST_DELAY    0.015 /* 0-15 ms Delay; inactive if DF is active */
+
+#define ALLOW_EXP_REQUEST
+#define ALLOW_MAX_FLOOD
+#undef  ALLOW_CACHED_REPLY
+#undef  ALLOW_MULTIPLE_REPLIES
+
+// Request Suppression
+#undef ALLOW_REQUEST_SUPPRESSION      
+#define RLS_REQDELAY_SIZE        8    /* Initial delay queue size       */
+#define RLS_SUPRAD_TIME          0.02 /* RAD of broadcasts              */
+#define RLS_SUPINFOCACHE_TIMEOUT 20   /* Wait no longer than 20 secs    */
+                                      /* for rebroadcasts of a pkt      */
+#define RLS_SUPINFOCACHE_SIZE    97
+#define RLS_DIST_THRESHOLD       45   /* nodes closer than this         */
+			              /* should not rebroadcast         */
+#define RLS_CNT_THRESHOLD        4    /* pkts heard more often than     */
+                                      /* this should not be rebroadcast */
+// Directional Flooding
+#define ALLOW_DIRECTIONAL_FLOODING
+#define RLS_DF_MAX_DELAY  0.020   /* 0.0375 Max Delay for Req Forwarding   */
+
+// Debugging
+#define locs_verbose          true
+#define locs_show_processing  false
+#define locs_show_in_progress false
+
+class ReaLocService;
+
+class RLSRequestScheduler : public QueuedTimer {
+    
+ public:
+    RLSRequestScheduler(class ReaLocService *ls, int size)
+	: QueuedTimer(size) 
+	{ ls_ = ls; }
+    void handle();
+
+ private:
+    ReaLocService* ls_; 
+
+};
+
+class RLSRequestDelay : public QueuedTimer {
+    
+ public:
+    RLSRequestDelay(class ReaLocService *ls, int size)
+	: QueuedTimer(size) 
+	{ ls_ = ls; }
+    void handle();
+    void deleteInfo(void* info);
+
+ private:
+    ReaLocService* ls_; 
+
+};
+
+class ReaLocService : public LocationService {
+
+ public:
+    ReaLocService(class Agent *p);
+    ~ReaLocService();
+    void recv(Packet* &p);
+    bool poslookup(Packet *p);
+    void evaluatePacket(const Packet *p);
+    void sleep();
+    int hdr_size(Packet* p);
+    void callback(Packet* &p);
+
+ protected:
+    void nextRequestCycle(nsaddr_t dst_);
+    void forwardRequest(Packet* &p);
+
+ private:
+
+    class LSRequestCache *reqtable;
+    class LSLocationCache *loccache;
+    class LSSeqNoCache *forwcache;
+    class LSSeqNoCache *seqnocache;
+
+    class RLSRequestScheduler *reqtimer;
+    //friend class GPSR_Agent;
+    friend class PBRAgent;
+    friend class RLSRequestScheduler;
+    friend class RLSRequestDelay;
+
+#ifdef ALLOW_REQUEST_SUPPRESSION
+    class RLSRequestDelay *reqdelay;
+    class LSSupCache *supinfocache;
+#endif
+
+    void recvRequest(Packet* &p);
+    void recvReply(Packet* &p);
+    void sendRequest(Packet* &p);
+    void piggybackSourceLocation(Packet *p);
+    void piggybackLasthopLocation(Packet *p);
+    void evaluateLocation(Packet *p);
+    void updateLocation(Packet *p);
+    void updatePosition(struct nodelocation &entry, struct hdr_ip* iph=NULL);
+    Packet* genRequest(nsaddr_t dst_, int seqno_, int maxhop_);
+    Packet* genReply(Packet* req, struct nodelocation* infosrc);
+    bool suppressedPkt(Packet* &p);
+
+    inline double bcastDelay() { 
+	return (Random::uniform(RLS_MAX_BCAST_DELAY));
+    }
+
+    inline double distance(double x1, double y1, double x2, double y2) {
+	return sqrt( ((x1 - x2)*(x1 - x2)) + ((y1 - y2)*(y1 - y2)) );
+    }
+};
+
+#endif // _ReaLocService_h
+
diff -u -r --new-file ./mac/mac-802_11.cc ../../ns-2.33-hls_working/ns-2.33/mac/mac-802_11.cc
--- ./mac/mac-802_11.cc	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/mac/mac-802_11.cc	2006-04-05 15:14:18.000000000 +0200
@@ -306,7 +306,14 @@
 			// command added to support event tracing by Sushmita
                         et_ = (EventTrace *)TclObject::lookup(argv[2]);
                         return (TCL_OK);
-                }
+		} else if (strcmp(argv[1], "load-trace") == 0) {
+			if (strcmp(argv[2], "") == 0) { return(TCL_OK); }
+			int mode;
+			const char* id = argv[2];
+			Tcl& tcl = Tcl::instance(); 
+			ch = Tcl_GetChannel(tcl.interp(), (char*)id, &mode);
+			return(TCL_OK);
+		} 
 	}
 	return Mac::command(argc, argv);
 }
diff -u -r --new-file ./mac/mac-802_11.h ../../ns-2.33-hls_working/ns-2.33/mac/mac-802_11.h
--- ./mac/mac-802_11.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/mac/mac-802_11.h	2006-04-05 15:14:18.000000000 +0200
@@ -368,7 +368,11 @@
 	inline int	hdr_dst(char* hdr, int dst = -2);
 	inline int	hdr_src(char* hdr, int src = -2);
 	inline int	hdr_type(char* hdr, u_int16_t type = 0);
-	
+
+// ->
+	inline int	getLoad() { return macLoad_; }
+// inserted - to
+
 	inline int bss_id() { return bss_id_; }
 	
 	// Added by Sushmita to support event tracing
@@ -590,6 +594,10 @@
	NsObject*	logtarget_;
	NsObject*       EOTtarget_;     // given a copy of packet at TX end

+// ->
+	int		macLoad_;	//!< current load on MAC layer - MT
+	Tcl_Channel ch;			//!< used for logging into file opened through TCL - MT
+// inserted - to

	/* ============================================================
	   Duplicate Detection state
diff -u -r --new-file ./mac/mac.h ../../ns-2.33-hls_working/ns-2.33/mac/mac.h
--- ./mac/mac.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/mac/mac.h	2006-04-05 15:14:18.000000000 +0200
@@ -178,6 +178,11 @@
 	virtual void sendDown(Packet* p);
 	virtual void sendUp(Packet *p);

+// ->
+	virtual void sleep() {asleep = true;}
+        virtual void wakeup() {asleep = false;}
+// inserted - to
+
 	virtual void resume(Packet* p = 0);
 	virtual void installTap(Tap *t) { tap_ = t; }
 	
@@ -226,6 +231,11 @@
 	virtual int initialized() { 
 		return (netif_ && uptarget_ && downtarget_); 
 	}
+
+// ->
+	bool asleep; //added by Jinyang: put the Mac to Sleep
+// inserted - to
+
 	int index_;		// MAC address
 	double bandwidth_;      // channel bitrate
 	double delay_;		// MAC overhead
diff -u -r --new-file ./Makefile.in ../../ns-2.33-hls_working/ns-2.33/Makefile.in
--- ./Makefile.in	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/Makefile.in	2006-04-05 15:14:18.000000000 +0200
@@ -323,6 +323,21 @@
	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
	apps/pbc.o \
+	\
+	locservices/hdr_locs.o \
+	locservices/realocservice.o locservices/omnilocservice.o locservices/gridlocservice.o \
+	locservices/ls_queued_timer.o \
+	locservices/chc.o locservices/chc_caches.o \
+	\
+	mobile/geo_util.o \
+	\
+	hls/hls.o \
+	hls/quadratic.o \
+	hls/hls_basic.o \
+	hls/hls_advanced.o \
+	\
+	gpsr/gpsr.o \
+	\
 	@V_STLOBJ@


diff -u -r --new-file ./mobile/geo_util.cc ../../ns-2.33-hls_working/ns-2.33/mobile/geo_util.cc
--- ./mobile/geo_util.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/mobile/geo_util.cc	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,290 @@
+/*
+  This is a collection of functions that were globally defined in
+  multiple files.
+*/
+using namespace std;
+
+#include "geo_util.h"
+#include <math.h>
+//#include <vector>
+
+/** calculates the distance in 3 Dimensions */
+double distance(double x1, double y1, double z1, double x2, double y2,
+		       double z2)
+{
+  double dist = sqrt((x1 - x2)*(x1 - x2) +
+		     (y1 - y2)*(y1 - y2) +
+		     (z1 - z2)*(z1 - z2));
+  return dist;
+}
+
+/** calculates the bearing (in radian) */
+double bearing(double x1, double y1, double x2, double y2)
+{
+  double brg;
+
+  // XXX only deal with 2D for now
+  // XXX check for (0, 0) args, a domain error
+  brg = atan2(y2 - y1, x2 - x1);
+  while (brg < 0)
+    brg += 2*M_PI;
+  return brg;
+}
+
+int cross_segment(double x1, double y1, double x2, double y2,
+						 double x3, double y3, double x4, double y4,
+						 double *xi /*= 0*/, double *yi /*= 0*/)
+{
+	double dy[2], dx[2], m[2], b[2];
+	double xint, yint;
+	
+	dy[0] = y2 - y1; // dsty - pty
+	dx[0] = x2 - x1; // dstx - ptx
+	dy[1] = y4 - y3; // ne->y - myy
+	dx[1] = x4 - x3; // ne->x - myx
+	m[0] = dy[0] / dx[0];
+	m[1] = dy[1] / dx[1];
+	b[0] = y1 - m[0] * x1;
+	b[1] = y3 - m[1] * x3;
+	if (m[0] != m[1]) {
+		// slopes not equal, compute intercept
+		xint = (b[0] - b[1]) / (m[1] - m[0]);
+		yint = m[1] * xint + b[1];
+		// is intercept in both line segments?
+		if ((xint <= maxd(x1, x2)) && (xint >= mind(x1, x2)) &&
+			(yint <= maxd(y1, y2)) && (yint >= mind(y1, y2)) &&
+			(xint <= maxd(x3, x4)) && (xint >= mind(x3, x4)) &&
+			(yint <= maxd(y3, y4)) && (yint >= mind(y3, y4))) {
+			if (xi && yi) {
+				*xi = xint;
+				*yi = yint;
+			}
+			return 1;
+		}
+	}
+	return 0;
+}
+
+double norm(double tmp_bear){
+    float to_norm = tmp_bear;
+    if(to_norm < -1000.0)
+      to_norm = 0.0;
+    while(to_norm <= 0)
+	to_norm += 2*M_PI;
+    if(to_norm > 1000.0)
+      to_norm = 0.0;
+    while(to_norm > 2*M_PI)
+	to_norm -= 2*M_PI;
+    
+    return (double)to_norm;
+}
+
+/** returns x with a_i + b_i * x = a_j + b_j * x */
+bool cut(double a_i, double b_i, double a_j, double b_j, double *x, double *y){
+  /*
+    a_i + b_i * x = a_j + b_j * x
+    x = (a_j - a_i) / (b_i - b_j)
+  */
+    
+  if(b_i == b_j)
+    return false;
+
+  *x = (a_j - a_i) / (b_i - b_j);
+  *y = a_j + b_j * *x;
+  return true;
+
+}
+
+/**
+ * here are some statistical functions 
+ * which are student-t distribution, incomplete beta function and gammaln function
+ */
+
+/** gammaln returns ln(\Gamma(xx)) */
+double gammln(double xx){
+    double x,y,tmp,ser;
+    
+    static double cof[6]={76.18009172947146,-86.50532032941677,
+			  24.01409824083091,-1.231739572450155,
+			  0.1208650973866179e-2,-0.5395239384953e-5};
+
+    y = x = xx;
+    tmp = x + 5.5;
+    tmp -= (x+0.5)*log(tmp);
+    ser = 1.000000000190015;
+
+    for (int j=0; j<=5; j++)
+	ser += cof[j] / ++y;
+
+    return -tmp+log(2.5066282746310005 * ser / x);
+}
+
+
+/** Used by betai: Evaluates continued fraction for incomplete beta function by modi ed Lentz's method (x5.2). */
+double betacf(double a, double b, double x){
+    /* 228 Chapter 6. Special Functions*/ 
+
+    int m, m2;
+    double aa, c, d, del, h, qab, qam, qap;
+
+    /* These q's will be used in factors that occur in the coe cients (6.4.6).*/
+    qab = a + b;
+    qap = a + 1.0;
+    qam = a - 1.0;
+
+    /* First step of Lentz's method.*/
+    c = 1.0;
+    d = 1.0 - qab * x / qap;
+    if (fabs(d) < FPMIN)
+	d=FPMIN;
+    d = 1.0 / d;
+    h = d;
+    for (m=1; m<=MAXIT; m++) {
+	m2 = 2 * m;
+	aa = m * (b-m)*x / ((qam+m2) * (a+m2));
+
+        /* One step (the even one) of the recurrence.*/
+	d = 1.0 + aa * d;
+	if (fabs(d) < FPMIN)
+	    d=FPMIN;
+	c = 1.0 + aa / c;
+	if (fabs(c) < FPMIN)
+	    c = FPMIN;
+	d = 1.0 / d;
+	h *= d*c;
+	aa = -(a+m)*(qab+m)*x / ((a+m2)*(qap+m2));
+
+        /* Next step of the recurrence (the odd one).*/
+	d = 1.0 + aa * d;
+	if (fabs(d) < FPMIN)
+	    d=FPMIN;
+	c = 1.0 + aa / c;
+	if (fabs(c) < FPMIN)
+	    c = FPMIN;
+	d = 1.0 / d;
+	del = d * c;
+	h *= del;
+
+	/* Are we done? */
+	if (fabs(del-1.0) < EPS)
+	    break;
+    }
+ 
+    if (m > MAXIT) 
+	nrerror("a or b too big, or MAXIT too small in betacf");
+
+    return h;
+}
+
+
+
+/** Returns the incomplete beta function Ix(a; b). */
+double betai(double a, double b, double x)
+{
+    double bt;
+    if (x < 0.0 || x > 1.0)
+	nrerror("Bad x in routine betai");
+
+    if (x == 0.0 || x == 1.0){
+	bt = 0.0;
+    }else{
+	/*Factors in front of the continued fraction.*/
+	bt = exp(gammln(a+b) - gammln(a) - gammln(b) + a*log(x) + b*log(1.0-x));
+    }
+
+    /* Use continued fraction directly.*/
+    if (x < (a+1.0) / (a+b+2.0)){
+	return bt * betacf(a,b,x) / a;
+    }else{ 
+	/* Use continued fraction after making the symmetry transformation.*/
+	return 1.0 - bt * betacf(b,a,1.0-x) / b;
+    }
+}
+
+/** return student-t's quantil */
+double student(double t, double nu){
+    return 1 - betai(nu/2.0, 0.5, nu/(nu+pow(t,2)));
+}
+
+//float select(unsigned long k, unsigned long n, vector<float>& arr){
+float select(unsigned long k, unsigned long n, float *arr){
+  unsigned long i,ir,j,l,mid;
+  float a,temp;
+  i=0;
+  l=1;
+  ir=n;
+  for (;;){
+    if (ir <= l+1){
+      /* Active partition contains 1 or 2e lements. */
+      if (ir == l+1 && arr[ir] < arr[l]){
+	/* Case of 2el ements. */
+	swap(&arr[l],&arr[ir]);
+      }
+      temp = arr[k];
+      return temp;
+    }else{
+      mid=(l+ir) >> 1;
+      /* Choose median of left, center, and right elements as partitioning element a. Also rearrange so that arr[l] d arr[l+1], arr[ir] e arr[l+1]. */
+      swap(&arr[mid],&arr[l+1]);
+      if (arr[l] > arr[ir]){
+	swap(&arr[l],&arr[ir]);
+      }
+      if (arr[l+1] > arr[ir]){
+	swap(&arr[l+1],&arr[ir]);
+      }
+      if (arr[l] > arr[l+1]){
+	swap(&arr[l],&arr[l+1]);
+      }
+      i=l+1;
+      /* Initialize pointers for partitioning. */
+      j=ir;
+      a=arr[l+1];
+      /* Partitioning element. */
+
+      for (;;){
+	/* Beginning of innermost loop. */
+	do i++;
+	while (arr[i] < a);
+	/* Scan up to  nd element > a. */
+	do j--;
+	while (arr[j] > a);
+	/* Scan down to  nd element < a. */
+	if (j < i)
+	  break;
+	/* Pointers crossed. Partitioning complete. */
+	swap(&arr[i],&arr[j]);
+      }
+      /* End of innermost loop. */
+      arr[l+1]=arr[j];
+      /* Insert partitioning element. */
+      arr[j]=a;
+      if (j >= k)
+	ir=j-1;
+      /* Keep active the partition that contains the kth element. */
+      if (j <= k)
+	l=i;
+    }
+  }
+}
+
+
+
+
+// /************************************************************************
+//  * C code
+//  ***********************************************************************/
+
+
+// /** allocate a float vector with subscript range v[nl..nh] */ 
+// float *vector(long nl, long nh){
+//   float *v;
+//   v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));
+//   if (!v) nrerror("allocation failure in vector()");
+//   return v-nl+NR_END;
+// }
+
+// /** free a float vector allocated with vector() */ 
+// void free_vector(float *v, long nl, long nh){
+//   free((FREE_ARG) (v+nl-NR_END));
+// }
+
diff -u -r --new-file ./mobile/geo_util.h ../../ns-2.33-hls_working/ns-2.33/mobile/geo_util.h
--- ./mobile/geo_util.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/mobile/geo_util.h	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,96 @@
+/*
+  This is a collection of functions that were globally defined in
+  multiple files.
+*/
+
+
+#ifndef GEO_UTIL_H
+#define GEO_UTIL_H
+
+#include "stdio.h"
+//#include <vector>
+
+/*#ifndef MIN
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#endif // MIN*/
+#ifndef max
+#define max(a,b) (((a)<(b))?(b):(a))
+#endif // max
+
+#ifndef SWAP
+#define SWAP(a,b) temp=(a);(a)=(b);(b)=temp;
+#endif
+
+#ifndef SIGN
+#define SIGN(a,b) ((b) >= 0.0 ? fabs(a) : -fabs(a))
+#endif
+
+inline void swap(float *a, float *b){
+  float temp = *a;
+  *a = *b;
+  *b = temp;
+}
+
+
+double distance(double x1, double y1, double z1, double x2, double y2,
+		double z2);
+    
+double bearing(double x1, double y1, double x2, double y2);
+
+int cross_segment(double, double, double, double,
+		  double, double, double, double,
+		  double * = 0, double * = 0);
+
+double norm(double);
+
+bool cut(double, double, double, double, double *, double *);
+
+/** statistical functions */
+inline void nrerror(char error[]){
+    sprintf("%s", error);
+}
+
+#define MAXIT 100
+#define EPS 3.0e-7
+#define FPMIN 1.0e-30
+
+#define NR_END 1
+#define FREE_ARG char*
+
+double gammln(double);
+double betacf(double, double, double);
+double betai(double, double, double);
+double student(double, double);
+
+float select(unsigned long, unsigned long, float *);//vector<float>&);
+
+//double mind(double, double);
+
+inline double mind(double a, double b){
+  return a<b?a:b;
+}
+
+inline double maxd(double a, double b){
+  return a>b?a:b;
+}
+
+/*
+template<class T> class Vec : public vector<T>{
+ public:
+  Vec() : vector<T>() { }
+  Vec(int s) : vector<T>(s) { }
+
+  T& operator[](int i) { return at(i);}
+  const T& operator[](int i) const { return at(i); }
+};
+*/
+
+/* extern "C"{ */
+/* #include <stdio.h> */
+/* #include <stdlib.h> */
+/* float *vector(long, long); */
+/* void free_vector(float *, long, long); */
+/* } */
+
+
+#endif // GEO_UTIL_H
diff -u -r --new-file ./mobile/god.cc ../../ns-2.33-hls_working/ns-2.33/mobile/god.cc
--- ./mobile/god.cc	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/mobile/god.cc	2006-04-05 15:14:18.000000000 +0200
@@ -88,6 +88,26 @@
 	num_send = 0;
 	active = false;
 	allowTostop = false;
+
+// ->
+	rrange_ = 250.0; //250m
+	bandwidth_ = 2.0e6; //2MBit
+	path_analysis_ = 1;
+
+	bind("rrange_", &rrange_);
+	bind("bandwidth_", &bandwidth_);
+	bind("path_analysis_", &path_analysis_);
+
+	// Aggregation
+	tracetarget = NULL;
+	T = NULL;
+	memset(&gpsr_cache,0,sizeof(struct gpsr_stat));
+	evaluate_cache = new struct ptype_stat*[PT_NTYPE];
+	for (int j=0; j < PT_NTYPE; j++) {
+		evaluate_cache[j] = NULL;
+	}
+// insterted - to
+
 }
 
 
@@ -931,9 +951,34 @@
 
                         instance_ = this;
 
+// ->
+			// Nodelist should use the mb_node structure to have everything
+			//  old and new synchronized
+			nodelist = mb_node;
+			awake = new bool[num_nodes];
+                        for (int i=0;i<num_nodes;i++) {
+                                awake[i] = true;
+                        }
+
+			S = new DHeapEntry[num_nodes];
+                        Q = new DHeap(num_nodes);
+
                         return TCL_OK;
                 }
 
+
+		/* 
+		   If God is to function as Physical Channel, it needs to know
+		   the Radio Range
+		*/
+		if(strcmp(argv[1], "radio_range") == 0) {
+			rrange_ = atof(argv[2]);
+			if(rrange_ == 0)
+                                return TCL_ERROR;
+                        return TCL_OK;
+		}
+// inserted - to
+
 		if (strcasecmp(argv[1], "num_data_types") == 0) {
 		  assert(num_data_types == 0);
 
@@ -981,6 +1026,18 @@
                         return TCL_OK;
                 }
 		*/
+		// ->
+		// Aggregation
+		TclObject *obj;
+		if (strcasecmp(argv[1], "tracetarget") == 0) {
+			if ((obj = TclObject::lookup(argv[2])) == 0) {
+				fprintf(stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1], argv[2]);
+				return TCL_ERROR;
+			}
+			tracetarget = (Trace *) obj;
+			return TCL_OK;
+		}
+		// inserted - to
 
         }
 	else if (argc == 4) {
@@ -1075,7 +1132,216 @@
 }
 
 
+////////////// Following functions are added for functionality of position based routing /////////////
+void 
+God::signOn(nsaddr_t index)  {
+	assert(index<num_nodes);
+	awake[index] = true; 
+}
+
+void 
+God::signOff(nsaddr_t index) {
+	assert(index<num_nodes);
+	awake[index] = false; 
+}
+
+bool 
+God::isAwake(nsaddr_t index) { 
+	assert(index<num_nodes);
+	return (awake[index]);
+}
+
+int 
+God::shortestPathLength(nsaddr_t src, nsaddr_t dst) {
+        if (!path_analysis_) { return (UNREACHABLE); }
+
+        // Sanity Check
+        if ((src>=num_nodes)||(src<0)||
+            (dst>=num_nodes)||(dst<0))
+        { return (UNREACHABLE); }
+
+        S = new DHeapEntry[num_nodes];
+        Q = new DHeap(num_nodes);
+
+        Q->clean();
+        //DHeap Q(num_nodes);
+        struct DHeapEntry* u;
+        struct DHeapEntry* v;
+
+        // Init S and build the Heap
+        initSingleSource(Q, (int)src);
+
+        while (!Q->empty()) {
+                u = Q->extract_min();
+                // Prune to stop search when we've found our dst
+                if (u->id == dst) break;
+                Q->iter_init();
+                while ((v=Q->iter()) != NULL) {
+                        if( isNeighbor(u->id,v->id) )
+                                relax(Q, u, v, 1);
+                }
+        }
+
+        return (S[dst].cost);
+}
+
+int
+God::greedyPathLength(nsaddr_t src, nsaddr_t dst) {
+        if (!path_analysis_) { return (UNREACHABLE); }
+
+        // Sanity Check
+        if ((src>=num_nodes)||(src<0)||
+            (dst>=num_nodes)||(dst<0))
+        { return (UNREACHABLE); }
+
+        double src_x,src_y,src_z;
+        double dst_x,dst_y,dst_z;
+        nsaddr_t last_hop = src;
+        nsaddr_t next_hop = -1;
+        int hops = 0;
+
+        mb_node[src]->getLoc(&src_x,&src_y,&src_z);
+        mb_node[dst]->getLoc(&dst_x,&dst_y,&dst_z);
+        long double best_dist = (((dst_x-src_x)*(dst_x-src_x))+((dst_y-src_y)*(dst_y-src_y)));
+        while (last_hop != dst) {
+                for (int i=0; i<num_nodes; i++) {
+                        if (isNeighbor(last_hop,i)) {
+                                mb_node[i]->getLoc(&src_x,&src_y,&src_z);
+                                long double dist = (((dst_x-src_x)*(dst_x-src_x))+((dst_y-src_y)*(dst_y-src_y)));
+
+                                // if his dist is less than the best i found so far mark it as next hop
+                                if (dist < best_dist) {
+                                        next_hop = i;
+                                        best_dist = dist;
+                                }
+                        }
+                }
+
+                if (next_hop != -1) {
+                        last_hop = next_hop;
+                        next_hop = -1;
+                        hops++;
+                }else{
+                        hops = UNREACHABLE;
+                        break;
+                }
+        }
+        return hops;
+}
 
+bool
+God::isNeighbor(int src, int dst) {
+
+        if ((src>=num_nodes)||(src<0)||
+            (dst>=num_nodes)||(dst<0))
+        { return (false); }
+
+        if ((!isAwake(src)) || (!isAwake(dst))) { return false; }
+
+        double src_x,src_y,src_z;
+        double dst_x,dst_y,dst_z;
+        mb_node[src]->getLoc(&src_x,&src_y,&src_z);
+        mb_node[dst]->getLoc(&dst_x,&dst_y,&dst_z);
+        double sqrdist = (((dst_x-src_x)*(dst_x-src_x))+((dst_y-src_y)*(dst_y-src_y)));
+
+        if (sqrdist <= (rrange_*rrange_)) { return true; }
+        else { return false; }
+}
+
+void
+God::initSingleSource(DHeap* Q, int s) {
+        for(int i=0; i<num_nodes; i++) {
+                S[i].id = i;
+                S[i].pred = NULL;
+                if (i==s) { S[i].cost = 0; }
+                else { S[i].cost = UNREACHABLE; }
+
+                Q->insert(&S[i]);
+        }
+}
+
+void
+God::relax(DHeap* Q, struct DHeapEntry* u, struct DHeapEntry* v, int cost) {
+        if (v->cost > (u->cost + cost)) {
+                Q->remove(v);
+                v->cost = (u->cost + cost);
+                v->pred = u;
+                Q->insert(v);
+        }
+}
+
+
+int
+DHeap::find(struct DHeapEntry* elem) {
+        unsigned int i;
+
+        //for (i=0; i<maxsize; i++)
+        for(i=0; i<heapsize; i++)
+                if (equal(elems[i],elem))
+                        return ++i;
+        return 0;
+}
+
+void
+DHeap::insert(struct DHeapEntry* elem) {
+        unsigned int i, par;
+
+        i = heapsize++;
+        par = parent(i);
+        while ((i > 0) && (lessthan(elem,elems[par]))) {
+                elems[i] = elems[par];
+                i = par;
+                par = parent(i);
+        }
+        elems[i] = elem;
+	return;
+}
+
+struct
+DHeapEntry* DHeap::extract_min() {
+        struct DHeapEntry*      min;
+
+        if (heapsize == 0)
+                return NULL;
+        min = elems[0];
+        elems[0] = elems[--heapsize];
+        elems[heapsize] = NULL;
+        heapify(0);
+
+        return min;
+}
+
+void
+DHeap::heapify(unsigned int i) {
+        unsigned int    l, r, x;
+
+        while (i < heapsize) {
+                l = left(i); r = right(i);
+                if (r < heapsize) {
+                        if (lessthan(elems[l],elems[r])) x = l;
+                        else                             x = r;
+                } else
+                        x = (l < heapsize ? l : i);
+                if ((x != i) && lessthan(elems[x], elems[i])) {
+                        swap(i, x); i = x;
+                } else {
+                        break;
+                }
+        }
+}
+
+struct
+DHeapEntry* DHeap::remove(struct DHeapEntry* elem) {
+
+        int     i = find(elem);
+        if (i == -1)
+                return NULL;
+        for (--i; i; i = parent(i)) {
+                swap(i, parent(i));
+        }
+        return extract_min();
+}
+//////////////////// inserted - to ///////////////////////
 
 
 
diff -u -r --new-file ./mobile/god.h ../../ns-2.33-hls_working/ns-2.33/mobile/god.h
--- ./mobile/god.h	2005-10-20 06:45:22.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/mobile/god.h	2006-04-05 15:14:18.000000000 +0200
@@ -53,6 +53,9 @@
 #include "node.h"
 #include "diffusion/hash_table.h"
 
+// ->
+#include "mobilenode.h"
+// inserted to
 
 // Added by Chalermek  12/1/99
 
@@ -116,6 +119,126 @@
 	double Z;
 };
 
+
+// Heap Elements for Djikstra's Algo
+struct DHeapEntry{
+  int id;
+  int cost;
+  DHeapEntry* pred;
+};
+
+class DHeap {
+
+ public:
+  DHeap(int size) {
+    elems = new DHeapEntry*[size];
+    for (int i=0; i<size; i++)
+      elems[i] = NULL;
+    maxsize = size;
+    heapsize = 0;
+    inverted = false;
+  }
+
+  ~DHeap() {
+    delete [] elems;
+  }
+
+  void heapify(unsigned int i);
+  void insert(struct DHeapEntry* elem);
+  int find(struct DHeapEntry* elem);
+  struct DHeapEntry* remove(struct DHeapEntry* elem);
+  struct DHeapEntry* extract_min();
+
+
+  inline void invert() { inverted = !inverted; }
+  inline unsigned int   parent(unsigned int i)  { return ((i - 1) / 2); }
+  inline unsigned int   left(unsigned int i)    { return ((i * 2) + 1); }
+  inline unsigned int   right(unsigned int i)   { return ((i + 1) * 2); }
+
+  inline void clean() {
+      for (unsigned int i=0; i<maxsize; i++)
+          elems[i] = NULL;
+      heapsize = 0;
+      inverted = false;
+  }
+
+  inline struct DHeapEntry* get(int i) {
+    if (elems[i]==NULL)
+      return NULL;
+    else
+      return elems[i];
+  }
+
+  inline bool empty() {
+    if (heapsize==0) return true;
+    else return false;
+  }
+
+  inline int size() {
+    return heapsize;
+  }
+
+  inline void iter_init() {
+    heapiter = 0;
+  }
+
+  inline struct DHeapEntry* iter() {
+    if (heapiter >= heapsize) {
+      heapiter = 0;
+      return NULL;
+    } else {
+      return elems[heapiter++];
+    }
+  }
+
+  inline void copy(DHeap * heap){
+    heap->clean();
+    for(int i=0; i<this->heapsize; i++){
+      heap->insert(this->elems[i]);
+    }
+  }
+
+
+ private:
+  struct DHeapEntry** elems;
+  bool inverted;
+  unsigned int maxsize;
+  unsigned int heapsize;
+  unsigned int heapiter;
+
+  inline struct DHeapEntry* tell_min() {
+    return (heapsize > 0 ? elems[0] : NULL);
+  };
+
+  inline void swap(unsigned int i, unsigned int j) {
+    DHeapEntry* helper = elems[i];
+    elems[i] = elems[j];
+    elems[j] = helper;
+    return;
+  };
+
+  inline bool equal(struct DHeapEntry* q1, struct DHeapEntry* q2) {
+    if ((q1->id == q2->id) &&
+        (q1->cost == q2->cost) &&
+        (q1->pred == q2->pred))
+      return true;
+    else
+      return false;
+  }
+
+  inline bool lessthan(struct DHeapEntry* q1, struct DHeapEntry* q2) {
+    if (inverted) {
+      if (q1->cost > q2->cost) { return true; }
+      else { return false; }
+    }else{
+      if (q1->cost < q2->cost) { return true; }
+      else { return false; }
+    }
+  }
+};
+// copied - to
+
+
 // ------------------------
 
 
@@ -200,6 +323,32 @@
 		return gridsize_;
 	}
 
+
+// ->
+	const double getRadioRange() { return rrange_; }
+
+	bool getPosition(int dst, double* x, double* y, double*z) {
+		if ((dst < 0) || (dst >= num_nodes)) { return false; }
+		if (mb_node[dst]) { mb_node[dst]->getLoc(x,y,z); return true; }
+		return false;
+	}
+
+	bool isAwake(nsaddr_t index);
+	void signOn(nsaddr_t index);
+	void signOff(nsaddr_t index);
+
+	int path_analysis_;
+	void initSingleSource(DHeap* Q, int s);
+	void relax(DHeap* heap, struct DHeapEntry* u, struct DHeapEntry* v, int cost);
+	int shortestPathLength(nsaddr_t src, nsaddr_t dst);
+	int greedyPathLength(nsaddr_t src, nsaddr_t dst);
+	bool isNeighbor(int src, int dst);
+
+	MobileNode **mb_node; // mb_node[i] giving pointer to object 
+                              // mobile node i
+	MobileNode **nodelist; 
+// inserted - to
+
   // -----------------------
 
 
@@ -215,7 +364,7 @@
 
         bool active;
         bool allowTostop;
-        MobileNode **mb_node; // mb_node[i] giving pointer to object 
+//	MobileNode **mb_node; // mb_node[i] giving pointer to object 
                               // mobile node i
         NodeStatus *node_status;
         int *next_hop;        // next_hop[i * num_nodes + j] giving
@@ -228,6 +377,32 @@
         int gridX;
         int gridY;
 
+// ->
+	struct ptype_stat {
+	  packet_t ptype;
+	  unsigned int transmissions;
+	  unsigned int traffic;
+	  unsigned int area[3];
+	  unsigned int nrte_drops;
+	  unsigned int shortest;
+	  unsigned int greedy;
+	};
+	struct gpsr_stat {
+	  unsigned int drop, recv, send, forw;
+	};
+	class Trace *tracetarget;
+	class Topography      *T; 
+	struct ptype_stat** evaluate_cache;
+	struct gpsr_stat gpsr_cache;
+
+	double rrange_;
+	double bandwidth_;
+
+	bool *awake;
+	DHeapEntry* S;
+	DHeap* Q;
+// inserted - to
+
 };
 
 #endif
diff -u -r --new-file ./queue/priqueue.cc ../../ns-2.33-hls_working/ns-2.33/queue/priqueue.cc
--- ./queue/priqueue.cc	2005-10-20 06:45:23.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/queue/priqueue.cc	2006-04-05 15:14:18.000000000 +0200
@@ -188,6 +188,15 @@
 	}
 }
 
-
+// ->
+void
+PriQueue::clear()
+{
+        Packet *p;
+        while((p = deque())) {
+                drop(p, DROP_IFQ_SLEEP);
+        }
+}
+// inserted - to
 
 
diff -u -r --new-file ./queue/priqueue.h ../../ns-2.33-hls_working/ns-2.33/queue/priqueue.h
--- ./queue/priqueue.h	2005-10-20 06:45:23.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/queue/priqueue.h	2006-04-05 15:14:18.000000000 +0200
@@ -70,6 +70,9 @@
         Packet* filter(nsaddr_t id);
 
 	void	Terminate(void);
+// ->
+	void	clear();
+// inserted - to
 private:
         int Prefer_Routing_Protocols;
  
diff -u -r --new-file ./tcl/lib/ns-default.tcl ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-default.tcl
--- ./tcl/lib/ns-default.tcl	2005-10-20 06:45:23.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-default.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -659,6 +659,12 @@
 # Wireless simulation support 
 #
 
+# ->
+ God set rrange_ 250
+ God set bandwidth_ 2.0e6
+ God set path_analysis_ 1
+# inserted - to
+
 Mac set debug_ false
 ARPTable set debug_ false
 ARPTable set avoidReordering_ false ; #not used
@@ -1350,6 +1356,16 @@
 Agent/DSRAgent set sport_ 255
 Agent/DSRAgent set dport_ 255
 
+# ->
+Agent/GPSR set active_ 1
+
+Agent/GPSR set cc_alpha_ 0
+Agent/GPSR set use_beacon_ 0
+Agent/GPSR set use_congestion_control_ 0
+Agent/GPSR set use_reactive_beacon_ 0
+Agent/GPSR set locservice_type_ 3
+# inserted - to
+
 Agent/MIPBS set adSize_ 48
 Agent/MIPBS set shift_ 0
 Agent/MIPBS set mask_ [AddrParams set ALL_BITS_SET]
@@ -1446,6 +1462,9 @@
 Queue set util_check_intv_ 0.2 ;	# Changed from 1 to 0.2, 2/25/05.
 Queue set util_records_ 5 ; 		# Changed from 0 to 5, 2/25/05.
 
+CMUTrace set aggregate_mac_ 0
+CMUTrace set aggregate_rtr_ 0
+
 # Quick Start definitions end here
 
 Delayer set debug_ false
diff -u -r --new-file ./tcl/lib/ns-lib.tcl ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-lib.tcl
--- ./tcl/lib/ns-lib.tcl	2005-10-20 06:45:23.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-lib.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -195,6 +195,10 @@
 source ../mobility/dsr.tcl
 source ../mobility/com.tcl
 
+# GPSR
+source ../mobility/gpsr.tcl
+# inserted - 2.11.05 - to
+
 source ../plm/plm.tcl
 source ../plm/plm-ns.tcl
 source ../plm/plm-topo.tcl
@@ -624,6 +630,12 @@
		    DSDV {
			    set ragent [$self create-dsdv-agent $node]
		    }
+	# ->
+	    # GPSR
+	    GPSR {
+		    set ragent [$self create-gpsr-agent $node]
+	    }
+	# insterted - to 
		    DSR {
			    $self at 0.0 "$node start-dsr"
		    }
@@ -814,6 +824,24 @@
 	return $ragent
 }
 
+# GPSR
+Simulator instproc create-gpsr-agent { node } {
+	# Create a gpsr routing agent for this node
+	set ragent [new Agent/GPSR]
+	# Setup address (supports hier-addr) for gpsr agent
+	# and mobilenode
+	set addr [$node node-addr]
+	#$ragent addr $addr
+	$ragent node $node
+	if [Simulator set mobile_ip_] {
+		$ragent port-dmux [$node demux]
+	}
+	$node addr $addr
+	$node set ragent_ $ragent
+	$self at 0.0 "$ragent start-gpsr"    ;# start updates
+	return $ragent
+}
+# inserted - to
 
 Simulator instproc create-dumb-agent { node } {
 	
diff -u -r --new-file ./tcl/lib/ns-mobilenode.tcl ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-mobilenode.tcl
--- ./tcl/lib/ns-mobilenode.tcl	2005-10-20 06:45:23.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-mobilenode.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -159,6 +159,15 @@
 	if { $arptable_ != "" } {
 		$arptable_ reset 
 	}
+
+# ->
+	# Special processing for GPSR
+	set gpsronly [string first "GPSR" [[$self set ragent_] info class]] 
+	if {$gpsronly != -1 } {
+		[$self set ragent_] resetSB
+	}
+# inserted - to
+
 }
 
 #
@@ -192,6 +201,11 @@
 		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
 	}
 	
+	# Special processing for GPSR
+	set gpsronly [string first "GPSR" [$agent info class]] 
+	if {$gpsronly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
 	#<zheng: add>
 	# Special processing for ZBR
 	#set zbronly [string first "ZBR" [$agent info class]] 
@@ -206,6 +220,14 @@
 		return
 	}
 
+# ->
+	# Special processing for GPSR
+	set gpsronly [string first "GPSR" [$agent info class]] 
+	if {$gpsronly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
+# inserted - to
+
 	# Attaching a normal agent
 	set namfp [$ns get-nam-traceall]
 	if { [Simulator set AgentTrace_] == "ON" } {
@@ -257,8 +279,10 @@
 	set dmux_ [$self demux]
 	set classifier_ [$self entry]
 
+# ->
 	# let the routing agent know about the port dmux
-	$agent port-dmux $dmux_
+#	$agent port-dmux $dmux_
+# outcommented - inserted - to
 
 	if { [Simulator set RouterTrace_] == "ON" } {
 		#
diff -u -r --new-file ./tcl/lib/ns-packet.tcl ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-packet.tcl
--- ./tcl/lib/ns-packet.tcl	2005-10-20 06:45:23.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/tcl/lib/ns-packet.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -171,6 +171,10 @@
 	Encap 	# common/encap.cc
         IPinIP 	# IP encapsulation 
 	HDLC 	# High Level Data Link Control
+# ->
+	LOCS 	# Location Services
+	GPSR 	# Greedy Permineter Stateless Routing (Routing Protocol)
+# inserted - to
 } {
 	add-packet-header $prot
 }
diff -u -r --new-file ./tcl/mobility/gpsr.tcl ../../ns-2.33-hls_working/ns-2.33/tcl/mobility/gpsr.tcl
--- ./tcl/mobility/gpsr.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ../../ns-2.33-hls_working/ns-2.33/tcl/mobility/gpsr.tcl	2006-04-05 15:14:18.000000000 +0200
@@ -0,0 +1,222 @@
+# gpsr.tcl -- TCL-world configuration of GPSR routing for ns-2
+
+#
+#
+#    Copyright (C) 2000 President and Fellows of Harvard College
+#
+#    All rights reserved.
+#
+#    NOTICE: This software is provided "as is", without any warranty,
+#    including any implied warranty for merchantability or fitness for a
+#    particular purpose.  Under no circumstances shall Harvard University
+#    or its faculty, staff, students or agents be liable for any use of,
+#    misuse of, or inability to use this software, including incidental
+#    and consequential damages.
+#
+#    License is hereby given to use, modify, and redistribute this
+#    software, in whole or in part, for any commercial or non-commercial
+#    purpose, provided that the user agrees to the terms of this
+#    copyright notice, including disclaimer of warranty, and provided
+#    that this copyright notice, including disclaimer of warranty, is
+#    preserved in the source code and documentation of anything derived
+#    from this software.  Any redistributor of this software or anything
+#    derived from this software assumes responsibility for ensuring that
+#    any parties to whom such a redistribution is made are fully aware of
+#    the terms of this license and disclaimer.
+#
+#    Author: Brad Karp, Harvard University EECS, July, 1999
+#
+
+# ======================================================================
+# Default Script Options
+# ======================================================================
+Agent/GPSR set sport_        0
+Agent/GPSR set dport_        0
+Agent/GPSR set bint_         0.5 ;# beacon interval
+Agent/GPSR set bdesync_      0.5 ;# beacon desync random component
+Agent/GPSR set bexp_         [expr 3*([Agent/GPSR set bint_]+[Agent/GPSR set bdesync_]*[Agent/GPSR set bint_])] ;# beacon timeout interval
+Agent/GPSR set pint_         1.5 ;# peri probe interval
+Agent/GPSR set pdesync_      0.5 ;# peri probe desync random component
+Agent/GPSR set lpexp_        8.0 ;# peris unused timeout interval
+Agent/GPSR set use_mac_      0        ;# use link breakage feedback from MAC
+Agent/GPSR set use_peri_     0	      ;# probe and use perimeters
+Agent/GPSR set verbose_      0        ;# 
+Agent/GPSR set drop_debug_   0        ;#
+Agent/GPSR set peri_proact_  1	      ;# proactively generate peri probes
+Agent/GPSR set use_implicit_beacon_ 0 ;# all packets act as beacons; promisc.
+Agent/GPSR set use_planar_   0        ;# planarize graph
+Agent/GPSR set use_loop_detect_ 0     ;# look for unexpected loops in peris
+Agent/GPSR set use_timed_plnrz_ 0     ;# replanarize periodically
+
+# ->
+set opt(ragent)         Agent/GPSR
+# <- inserted - mk
+set opt(pos)		NONE			;# Box or NONE
+
+if { $opt(pos) == "Box" } {
+	puts "*** GPSR using Box configuration..."
+}
+
+# ======================================================================
+Agent instproc init args {
+    eval $self next $args
+}       
+
+Agent/GPSR instproc init args {
+    eval $self next $args
+}       
+
+# ===== Get rid of the warnings in bind ================================
+
+# ======================================================================
+
+proc create-gpsr-routing-agent { node id } {
+    global ns_ ragent_ tracefd opt
+
+    #
+    #  Create the Routing Agent and attach it to port 255.
+    #
+    #set ragent_($id) [new $opt(ragent) $id]
+    set ragent_($id) [new $opt(ragent)]
+    set ragent $ragent_($id)
+
+    ## setup address (supports hier-addr) for dsdv agent 
+    ## and mobilenode
+    set addr [$node node-addr]
+    
+    #$ragent addr $addr
+    #$ragent node $node
+
+    $ragent node $node
+    if [Simulator set mobile_ip_] {
+	$ragent port-dmux [$node set dmux_]
+    }
+    $node addr $addr
+    $node set ragent_ $ragent
+    
+    # ->
+    #$node attach $ragent 255
+    $node attach $ragent [Node set rtagent_port_]
+    # <- replaced - mk
+
+    ##$ragent set target_ [$node set ifq_(0)]	;# ifq between LL and MAC
+        
+    # XXX FIX ME XXX
+    # Where's the DSR stuff?
+    #$ragent ll-queue [$node get-queue 0]    ;# ugly filter-queue hack
+    $ns_ at 0.0 "$ragent_($id) start-gpsr"	;# start updates
+
+    #
+    # Drop Target (always on regardless of other tracing)
+    #
+    set drpT [cmu-trace Drop "RTR" $node]
+    $ragent drop-target $drpT
+    
+    #
+    # Log Target
+    #
+    set T [new Trace/Generic]
+    $T target [$ns_ set nullAgent_]
+    $T attach $tracefd
+    $T set src_ $id
+    $ragent tracetarget $T
+
+    # ifq
+    $ragent add-ifq [$node set ifq_(0)]
+}
+
+
+proc gpsr-create-mobile-node { id args } {
+    global ns ns_ chan prop topo tracefd opt node_
+    
+    set ns_ [Simulator instance]
+    # ->
+    #if {[Simulator set EnableHierRt_]} {
+    if [Simulator hier-addr?] {
+    # <- replaced - mk
+	if [Simulator set mobile_ip_] {
+	    set node_($id) [new MobileNode/MIPMH $args]
+	} else {
+	    set node_($id) [new Node/MobileNode/BaseStationNode $args]
+	}
+    } else {
+	set node_($id) [new Node/MobileNode]
+    }
+    set node $node_($id)
+    $node random-motion 0		;# disable random motion
+    $node topography $topo
+    
+    # ->
+    # XXX Activate energy model so that we can use sleep, etc. But put on 
+    # a very large initial energy so it'll never run out of it.
+    if [info exists opt(energy)] {
+    	$node addenergymodel [new $opt(energy) $node 1000 0.5 0.2]
+    }
+    # <- inserted - mk
+
+    #
+    # This Trace Target is used to log changes in direction
+    # and velocity for the mobile node.
+    #
+    set T [new Trace/Generic]
+    $T target [$ns_ set nullAgent_]
+    $T attach $tracefd
+    $T set src_ $id
+    $node log-target $T
+
+    # ->
+    if ![info exist opt(err)] {
+	set opt(err) ""
+    }
+    # ->
+    if ![info exist opt(outerr)] {
+	set opt(outerr) ""
+    }
+    # <- inserted - to
+    if ![info exist opt(fec)] {
+	set opt(fec) ""
+    }
+    # <- inserted - mk
+
+    # ->
+    #$node add-interface $chan $prop $opt(ll) $opt(mac)	\
+	#    $opt(ifq) $opt(ifqlen) $opt(netif) $opt(ant)
+#    $node add-interface $chan $prop $opt(ll) $opt(mac)	\
+#	    $opt(ifq) $opt(ifqlen) $opt(netif) $opt(ant) $opt(err) $opt(fec)
+#    # <- replaced - mk
+    # ->
+    $node add-interface $chan $prop $opt(ll) $opt(mac)	\
+	    $opt(ifq) $opt(ifqlen) $opt(netif) $opt(ant) $topo $opt(err) $opt(outerr) $opt(fec)
+    # <- replaced - to
+    #
+    # Create a Routing Agent for the Node
+    #
+    create-$opt(rp)-routing-agent $node $id
+    
+    # ============================================================
+    
+	if { $opt(pos) == "Box" } {
+		#
+		# Box Configuration
+		#
+		set spacing 200
+		set maxrow 7
+		set col [expr ($id - 1) % $maxrow]
+		set row [expr ($id - 1) / $maxrow]
+		$node set X_ [expr $col * $spacing]
+		$node set Y_ [expr $row * $spacing]
+		$node set Z_ 0.0
+		$node set speed_ 0.0
+
+		$ns_ at 0.0 "$node_($id) start"
+	}
+	return $node
+}
+
+
+
+
+
+
+
+
diff -u -r --new-file ./trace/cmu-trace.cc ../../ns-2.33-hls_working/ns-2.33/trace/cmu-trace.cc
--- ./trace/cmu-trace.cc	2005-10-20 06:45:25.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/trace/cmu-trace.cc	2006-04-05 15:14:18.000000000 +0200
@@ -60,6 +60,13 @@
 #include "wpan/p802_15_4nam.h"
 //</zheng: add for 802.15.4>
 
+//->
+#include "locservices/hdr_locs.h" // locservices
+#include <gpsr/gpsr.h>              // GPSR
+  // inserted - wk
+#include <hls/hls_basic.h>
+// inserted - to
+
 #include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
 
 
@@ -602,7 +609,7 @@
 }
 
 /* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
- * (with help from Florina Almenrez <florina@@it,uc3m,es>)
+ * (with help from Florina Almenrez <florina@@it,uc3m,es>)
  */
 void
 CMUTrace::format_sctp(Packet* p,int offset)
@@ -943,6 +950,298 @@
         }
 }
 
+// ->
+void
+CMUTrace::format_locs(Packet *p, int offset)
+{
+        struct hdr_locs *locsh = HDR_LOCS(p);
+
+        sprintf(pt_->buffer() + offset,
+                "%d [%d %.3f (%.3f,%.3f) (%d:%d)]->[%d %.3f (%.3f,%.3f) (%d:%d)]",
+                locsh->type_,
+                locsh->src.id,
+                locsh->src.ts,
+                locsh->src.loc.x,
+                locsh->src.loc.y,
+                locsh->src.sqr.grid,
+                locsh->src.sqr.order,
+                locsh->dst.id,
+                locsh->dst.ts,
+                locsh->dst.loc.x,
+                locsh->dst.loc.y,
+                locsh->dst.sqr.grid,
+                locsh->dst.sqr.order);
+
+        // Fields introduced with RLS
+        offset = strlen(pt_->buffer());
+        sprintf(pt_->buffer() + offset,
+                " : %d %d",
+                locsh->seqno_,
+                locsh->maxhop_);
+
+        // Fields introduced with GLS
+	offset = strlen(pt_->buffer());
+	sprintf(pt_->buffer() + offset,
+		" : %s %d %d [%d:%d] [%.3f] [%d %.3f (%.3f,%.3f) (%d:%d)]",
+		locsh->updreason_,
+		locsh->callback_,
+		locsh->in_correct_grid,
+		locsh->upddst_.grid,
+		locsh->upddst_.order,
+		locsh->dst.timeout,
+		locsh->next.id,
+		locsh->next.ts,
+		locsh->next.loc.x,
+		locsh->next.loc.y,
+		locsh->next.sqr.grid,
+		locsh->next.sqr.order);
+
+}
+// Addition for GPSR Traces
+void
+CMUTrace::format_gpsr(Packet *p, int offset)
+{
+	struct hdr_cmn *cmnh   = HDR_CMN(p);
+	struct hdr_ip *iph     = HDR_IP(p);
+	struct hdr_gpsr *gpsrh = HDR_GPSR(p);
+	struct hdr_locs *locsh = HDR_LOCS(p);
+
+	char op = (char) type_;
+
+	int gpath = -1;
+	int spath = -1;
+
+	if (tracetype == TR_ROUTER) {
+		if ((op == DROP)||(op == SEND)){
+			gpath = God::instance()->greedyPathLength(src_,iph->daddr());
+			spath = God::instance()->shortestPathLength(src_,iph->daddr());
+		}
+		if (op == RECV){
+			gpath = God::instance()->greedyPathLength(src_,iph->saddr());
+			spath = God::instance()->shortestPathLength(src_,iph->saddr());
+		}
+		if (gpath == UNREACHABLE) { gpath = -1; }
+		if (spath == UNREACHABLE) { spath = -1; }
+	}
+	
+	switch (op) {
+	    case DROP:
+	    case SEND:
+		    if (locsh->valid_){
+			    if (aggregate_rtr) {
+				    sprintf(pt_->buffer() + offset,
+					    "%d %d [%d %d]",
+					    gpsrh->mode_,
+					    cmnh->num_forwards_,
+					    gpath,
+					    spath);
+			    }else{
+				    sprintf(pt_->buffer() + offset,
+					    "%d %d [%d %d] [%.2f/%.2f/%.5f]->[%.2f/%.2f/%.5f]",
+					    gpsrh->mode_,
+					    cmnh->num_forwards_,
+					    gpath,
+					    spath,
+					    locsh->src.loc.x,
+					    locsh->src.loc.y,
+					    locsh->src.ts,
+					    locsh->dst.loc.x,
+					    locsh->dst.loc.y,
+					    locsh->dst.ts);
+			    }
+		    }else{
+			    sprintf(pt_->buffer() + offset,
+				    "%d %d [%d %d]",
+				    gpsrh->mode_,
+				    cmnh->num_forwards_,
+				    gpath,
+				    spath);
+		    }
+		    break;
+	    case RECV:
+		    sprintf(pt_->buffer() + offset,
+			    "%d %d [%d %d]",
+			    gpsrh->mode_,
+			    cmnh->num_forwards_,
+			    gpath,
+			    spath);
+		    break;
+	    default:
+		    sprintf(pt_->buffer() + offset,
+			    "%d %d [%d %d]",
+			    gpsrh->mode_,
+			    cmnh->num_forwards_,
+			    0,0);
+	}
+}
+
+// only fields with values in it are traced
+void
+CMUTrace::format_hls(Packet *p, int offset)
+{	
+   struct hdr_hls *h = HDR_HLS(p);
+   switch(h->type_)
+	   {
+	   case HLS_UPDATE : // update
+		sprintf(pt_->buffer() + offset,
+			"%d [%d %.4f (%.2f,%.2f) <%d>] <%d %.2f %.2f (%d)> %s",
+			// src
+			h->type_,
+			h->src.id,
+			h->src.ts,
+			h->src.pos.x,
+			h->src.pos.y,
+			h->src.targetcell,
+			// cell
+			h->cell.id,
+			h->cell.pos.x,
+			h->cell.pos.y,
+			h->cell.level, 
+			h->updreason_);	
+	   case HLS_HANDOVER :	
+		sprintf(pt_->buffer() + offset,
+			"%d <%d %.2f %.2f (%d)> %d",		
+			h->type_,
+			// cell
+			h->cell.id,
+			h->cell.pos.x,
+			h->cell.pos.y,
+			h->cell.level, 
+			h->numberOfNodeinfosToHandover);	    
+		break;      
+	   case HLS_REQUEST :	
+		sprintf(pt_->buffer() + offset,
+			"%d [%d %.4f (%.2f,%.2f)]->[%d] <%d %.2f %.2f (%d)> (%d_%d)",
+			// src
+			h->type_,
+			h->src.id,
+			h->src.ts,
+			h->src.pos.x,
+			h->src.pos.y,
+			// dst
+			h->dst.id,
+			// cell
+			h->cell.id,
+			h->cell.pos.x,
+			h->cell.pos.y,
+			h->cell.level,
+			
+			// reqid
+			h->reqid.node,
+			h->reqid.nr);	    
+		break;			    
+	   case HLS_CELLCAST_REQUEST :		    		    
+		sprintf(pt_->buffer() + offset,
+			"%d [%d (%.2f,%.2f)]->[%d] <%d %.2f %.2f (%d)> (%d_%d)",
+			// src
+			h->type_,
+			h->src.id,
+			h->src.pos.x,
+			h->src.pos.y,
+			// dst
+			h->dst.id,
+			// cell
+			h->cell.id,
+			h->cell.pos.x,
+			h->cell.pos.y,
+			h->cell.level,
+			
+			// reqid
+			h->reqid.node,
+			h->reqid.nr);
+		break;
+	   case HLS_CELLCAST_REPLY :		    		    
+		sprintf(pt_->buffer() + offset,
+			"%d [%d %.4f (%.2f,%.2f)]->[%d %.4f (%.2f,%.2f)] (%d_%d)",
+			// src
+			h->type_,
+			h->src.id,
+			h->src.ts,
+			h->src.pos.x,
+			h->src.pos.y,
+			// dst
+			h->dst.id,
+			h->dst.ts,
+			h->dst.pos.x,
+			h->dst.pos.y,		
+			// reqid
+			h->reqid.node,
+			h->reqid.nr);
+		break;
+	   case HLS_REPLY :	      
+		sprintf(pt_->buffer() + offset,
+			"%d [%d %.4f (%.2f,%.2f) <%d>]->[%d %.4f (%.2f,%.2f) <%d>] (%d_%d)",
+			// src
+			h->type_,
+			h->src.id,
+			h->src.ts,
+			h->src.pos.x,
+			h->src.pos.y,
+			h->src.targetcell,
+			// dst
+			h->dst.id,
+			h->dst.ts,
+			h->dst.pos.x,
+			h->dst.pos.y,
+			h->dst.targetcell,			    
+			// reqid
+			h->reqid.node,
+			h->reqid.nr);		    
+		break;
+	   case HLS_CIRCLECAST_REQUEST :		    		    
+		   sprintf(pt_->buffer() + offset,
+			   "%d [%d (%.2f,%.2f)]->[%d] <%d,%d,%d,%d,%d,%d,%d,%d> (%d_%d)",
+			   // src
+			   h->type_,
+			   h->src.id,
+			   h->src.pos.x,
+			   h->src.pos.y,
+			   // dst
+			   h->dst.id,
+			   // cells
+			   h->neighbors[0],
+			   h->neighbors[1],
+			   h->neighbors[2],
+			   h->neighbors[3],
+			   h->neighbors[4],
+			   h->neighbors[5],
+			   h->neighbors[6],
+			   h->neighbors[7],
+			   // reqid
+			   h->reqid.node,
+			   h->reqid.nr);
+		   break;
+	   }
+	/*  the following is a model for tracing all fields in the HLS header
+	  sprintf(pt_->buffer() + offset,
+	  "%d [%d %.4f (%.2f,%.2f) <%d>]->[%d %.4f (%.2f,%.2f) <%d>] <%d %.2f %.2f) (%d)> (%d_%d)",
+	  // src
+	  h->type_,
+	  h->src.id,
+	  h->src.ts,
+	  h->src.pos.x,
+	  h->src.pos.y,
+	  h->src.targetcell,
+	  // dst
+	  h->dst.id,
+	  h->dst.ts,
+	  h->dst.pos.x,
+	  h->dst.pos.y,
+	  h->dst.targetcell,
+	  // cell
+	  h->cell.id,
+	  h->cell.pos.x,
+	  h->cell.pos.y,
+	  h->cell.level,
+	  
+	  // reqid
+	  h->reqid.node,
+	  h->reqid.nr);
+	*/
+}
+// insterted - to
+
+
 void
 CMUTrace::nam_format(Packet *p, int offset)
 {
@@ -1237,6 +1536,21 @@
 	        case PT_DIFF:
 			break;
 		case PT_GAF:
+			break;
+
+// ->
+		case PT_GPSR: // GPSR
+			// inserted
+			format_gpsr(p, offset);
+			break;
+		case PT_HLS : // hierarchical location service
+			format_hls(p,offset);
+			break;
+		case PT_LOCS: // Locservices
+			format_locs(p, offset);
+			break;
+// inserted - to
+
 		case PT_PING:
 			break;
 		default:
diff -u -r --new-file ./trace/cmu-trace.h ../../ns-2.33-hls_working/ns-2.33/trace/cmu-trace.h
--- ./trace/cmu-trace.h	2005-10-20 06:45:25.000000000 +0200
+++ ../../ns-2.33-hls_working/ns-2.33/trace/cmu-trace.h	2006-04-05 15:14:18.000000000 +0200
@@ -84,6 +84,17 @@
 #define DROP_RTR_MAC_CALLBACK           "CBK"   // MAC callback
 #define DROP_RTR_SALVAGE	        "SAL"
 
+
+// -> Additions
+#define DROP_RTR_NEXT_SRCRT_HOP         "NSRH"  // MAC next srcrt hop dead
+#define DROP_RTR_SLEEP                  "SLPR"  // node is put to sleep
+#define DROP_SB_FULL                    "SBF"
+#define DROP_SB_TOUT                    "SBT"
+#define DROP_IFQ_SLEEP                  "SLPI"  // link layer is put to sleep
+#define DROP_LOCS_NONXTLS               "NNLS"  // no next location server
+// end Additions - inserted - to
+
+
 #define DROP_IFQ_QFULL                  "IFQ"   // no buffer space in IFQ
 #define DROP_IFQ_ARP_FULL               "ARP"   // dropped by ARP
 #define DROP_IFQ_FILTER                 "FIL"
@@ -159,6 +170,14 @@
 	void	format_tora(Packet *p, int offset);
         void    format_imep(Packet *p, int offset);
         void    format_aodv(Packet *p, int offset);
+// ->
+	void	format_locs(Packet *p, int offset);
+	void    format_hls(Packet *p, int offset);
+	void    format_gpsr(Packet *p, int offset);
+
+	int aggregate_mac;
+	int aggregate_rtr;
+// inserted - to
 
 	// This holds all the tracers added at run-time
 	static PacketTracer *pktTrc_;
